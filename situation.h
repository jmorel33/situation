/***************************************************************************************************
*
*   -- The "Situation" Advanced Platform Awareness, Control, and Timing --
*   Core API library v2.3.1A
*   (c) 2025 Jacques Morel
*   MIT Licenced
*
*   A single-file, cross-platform C/C++ library providing unified, low-level access and control over essential application subsystems. Its purpose is to abstract away platform-specific complexities,
*   offering a lean yet powerful API for building sophisticated, high-performance software.
*
*   The library's philosophy is reflected in its name, granting developers complete situational "Awareness," precise "Control," and fine-grained "Timing."
*
*   It provides deep **Awareness** of the host system through APIs for querying hardware and multi-monitor display information, and by handling operating system events like window focus and file drops.
*
*   This foundation enables precise **Control** over the entire application stack, from window management (fullscreen, borderless) and input devices (keyboard, mouse, gamepad) to a comprehensive audio
*
*   pipeline with playback, capture, and real-time effects. This control extends to the graphics and compute pipeline, abstracting modern OpenGL and Vulkan through a unified command-buffer model.
*   It offers simplified management of GPU resources—such as shaders, meshes, and textures—and includes powerful utilities for high-quality text rendering and robust filesystem I/O.
*
*   Finally, its **Timing** capabilities range from high-resolution performance measurement and frame rate management to an advanced **Temporal Oscillator System** for creating complex, rhythmically
*   synchronized events. By handling the foundational boilerplate of platform interaction, "Situation" empowers developers to focus on core application logic, enabling the creation of responsive and
*   sophisticated software—from games and creative coding projects to data visualization tools—across all major desktop platforms.
*
***************************************************************************************************
*
*   License (MIT)
*   -------------
*   Copyright (c) 2025 Jacques Morel
*
*   Permission is hereby granted, free of charge, to any person obtaining a copy
*   of this software and associated documentation files (the "Software"), to deal
*   in the Software without restriction, including without limitation the rights
*   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*   copies of the Software, and to permit persons to whom the Software is
*   furnished to do so, subject to the following conditions:
*
*   The above copyright notice and this permission notice shall be included in all
*   copies or substantial portions of the Software.
*
*   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
*   SOFTWARE.
*
***************************************************************************************************/

/*
Compilation command (adjust paths/libs for your system):
GCC (Linux/MinGW):
gcc main.c -o situation_demo \
    -I. -I./ext -I./ext/glad/include -I./ext/GLFW  # Adjust include paths for headers
    -L/path/to/glfw/libs                           # If GLFW lib is not in standard path
    -lglfw3 -lGL -lm -ldl -lpthread                # Common Linux libs
    # For MinGW on Windows, add Windows specific libs:
    # -lgdi32 -lopengl32 -lwinmm -luser32 -lshell32 -liphlpapi -lsetupapi -ldxgi -lole32 -lpropsys -lshlwapi
Use code with caution.
Bash
If you installed GLFW, Miniaudio, GLAD headers, and CGLM headers via a package manager like pacman in MSYS2/MinGW, the -I flags for them might not be needed if they are in the compiler's default search paths.
 However, you'll still need -I. if situation.h is in the current directory and #include "ext/glad.c" implies ext is a subdirectory.
A more self-contained MinGW command assuming headers are somewhat organized:
gcc main.c -o situation_demo.exe -I. -Iext \
    -lglfw3 -lsqlite3 \ # If you had sqlite3 (not used by situation.h but by earlier tests)
    -lgdi32 -lopengl32 -lwinmm -luser32 -lshell32 -lole32 -liphlpapi -lsetupapi -ldxgi -lpropsys -lshlwapi \
    -lm
Use code with caution.
Bash
(Note: The -lsqlite3 might not be needed if your situation.h doesn't use it, but your earlier test program did. The provided situation.h doesn't list SQLite3 as a direct dependency).
*/

#ifndef SITUATION_H
#define SITUATION_H

/**
 * @brief The public-facing macro. It now ALWAYS calls the logging function.
 *      The logging function itself will decide whether to print to stderr based on the build type.
 */
#define SIT_CHECK_GL_ERROR() _SituationLogGLError(__FILE__, __LINE__)

// --- [IMPORTANT] User must define the backend to use ---
#if !defined(SITUATION_USE_VULKAN) && !defined(SITUATION_USE_OPENGL)
    #error "You must define either SITUATION_USE_VULKAN or SITUATION_USE_OPENGL before including situation.h"
#endif
#if defined(SITUATION_USE_VULKAN) && defined(SITUATION_USE_OPENGL)
    #error "You can only define one renderer backend (SITUATION_USE_VULKAN or SITUATION_USE_OPENGL)"
#endif

// --- [OPTIONAL] Define this to enable runtime GLSL -> SPIR-V compilation for both backends.
// #define SITUATION_ENABLE_SHADER_COMPILER

// --- Check for valid configurations ---
#if defined(SITUATION_USE_VULKAN) && !defined(SITUATION_ENABLE_SHADER_COMPILER)
    #error "The Vulkan backend requires SITUATION_ENABLE_SHADER_COMPILER to be defined."
#endif


/**
 * @brief API Declaration Control (for Shared Library / DLL support)
 */
#if defined(_WIN32)
    #if defined(SITUATION_BUILD_SHARED)
        #define SITAPI __declspec(dllexport) // Exporting functions from the DLL
    #elif defined(SITUATION_USE_SHARED)
        #define SITAPI __declspec(dllimport) // Importing functions from the DLL
    #else
        #define SITAPI // Static library or header-only, no special declaration needed
    #endif
#else // On other platforms like Linux or macOS, attribute visibility is preferred
    #if defined(SITUATION_BUILD_SHARED)
        #define SITAPI __attribute__((visibility("default")))
    #else
        #define SITAPI // No special declaration needed for static or header-only
    #endif
#endif

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h> // For fmodf, fmaxf, fminf
#include <float.h> // For FLT_MAX
#ifndef M_PI // Define M_PI if not already defined (common for MSVC)
    #define M_PI 3.14159265358979323846
#endif

/**
 * @brief Core dependencies
 */
#include <cglm/cglm.h>
#include <GLFW/glfw3.h>
#include <miniaudio.h>

/**
 * @brief Backend-specific includes
 */
#if defined(SITUATION_USE_OPENGL)
    #include <glad.h>
#elif defined(SITUATION_USE_VULKAN)
    #include <vulkan/vulkan.h>
#endif

/**
 * @brief Optional Shader Compiler (shaderc)
 */
#if defined(SITUATION_ENABLE_SHADER_COMPILER)
    #include <shaderc/shaderc.h>
#endif

/**
 * @brief Platform-specific includes
 */
#if defined(_WIN32)
    #ifndef WIN32_LEAN_AND_MEAN
        #define WIN32_LEAN_AND_MEAN
    #endif
    #ifndef NOMINMAX
        #define NOMINMAX
    #endif
    #include <windows.h>
    #include <ws2tcpip.h>       // For network adapter info
    #include <iphlpapi.h>       // For GetAdaptersAddresses
    #include <objbase.h>        // For CoInitialize/CoUninitialize
    #ifdef SITUATION_ENABLE_DXGI // Optional DXGI for GPU info
        #include <dxgi.h>
    #endif
    #include <Xinput.h>         // For gamepad vibration
    #include <setupapi.h>       // For SetupDiGetClassDevs
    #include <devguid.h>        // For GUID_DEVCLASS_xxx
    #include <shlobj.h>         // For SHGetKnownFolderPath
#else                           // For non-Windows (e.g., Linux for GetUserDirectory)
    #include <unistd.h>         // For getuid (potentially), sysconf
    #include <sys/types.h>      // For getpwuid (potentially)
    #include <pwd.h>            // For getpwuid (potentially)
    #include <sys/statvfs.h>    // For storage info on Linux
    #include <sys/sysinfo.h>    // For RAM info on Linux
#endif

/**
 * @brief Configuration Defines
 */
#define SITUATION_VULKAN_MAX_FRAMES_IN_FLIGHT 2

#define SITUATION_MAX_STORAGE_DEVICES 8
#define SITUATION_MAX_NETWORK_ADAPTERS 8
#define SITUATION_MAX_INPUT_DEVICES 16
#define SITUATION_MAX_DEVICE_NAME_LEN 128
#define SITUATION_MAX_CPU_NAME_LEN 64
#define SITUATION_MAX_GPU_NAME_LEN 128
#define SITUATION_MAX_MONITOR_NAME_LEN 128
#define SITUATION_MAX_ERROR_MSG_LEN 512
#define SITUATION_MAX_SHADER_LOG_LEN 1024

#define SITUATION_MAX_VIRTUAL_DISPLAYS 16
#define SITUATION_MAX_AUDIO_SOUNDS_QUEUED 32
#define SITUATION_AUDIO_CALLBACK_TEMP_BUFFER_FRAMES 2048

#define SITUATION_KEY_QUEUE_MAX 64                  // Added for keyboard input queue
#define SITUATION_CHAR_QUEUE_MAX 64                 // Added for char input queue

#define SITUATION_MAX_JOYSTICKS 2                   // Max joysticks to track (e.g., for local multiplayer)
#define SITUATION_MAX_JOYSTICK_BUTTONS 15           // Gamepad API has 15 buttons (A, B, X, Y, etc.)
#define SITUATION_MAX_JOYSTICK_AXES 6               // Gamepad API has 6 axes (LX, LY, RX, RY, LT, RT)
#define SITUATION_JOYSTICK_DEADZONE_L 0.10f         // Default deadzone for left analog stick
#define SITUATION_JOYSTICK_DEADZONE_R 0.10f         // Default deadzone for right analog stick

/**
 * @brief Key Codes (from GLFW, re-defined for API stability)
 */
#define SIT_KEY_SPACE              32
#define SIT_KEY_APOSTROPHE         39  /* ' */
#define SIT_KEY_COMMA              44  /* , */
#define SIT_KEY_MINUS              45  /* - */
#define SIT_KEY_PERIOD             46  /* . */
#define SIT_KEY_SLASH              47  /* / */
#define SIT_KEY_0                  48
#define SIT_KEY_1                  49
#define SIT_KEY_2                  50
#define SIT_KEY_3                  51
#define SIT_KEY_4                  52
#define SIT_KEY_5                  53
#define SIT_KEY_6                  54
#define SIT_KEY_7                  55
#define SIT_KEY_8                  56
#define SIT_KEY_9                  57
#define SIT_KEY_SEMICOLON          59  /* ; */
#define SIT_KEY_EQUAL              61  /* = */
#define SIT_KEY_A                  65
#define SIT_KEY_B                  66
#define SIT_KEY_C                  67
#define SIT_KEY_D                  68
#define SIT_KEY_E                  69
#define SIT_KEY_F                  70
#define SIT_KEY_G                  71
#define SIT_KEY_H                  72
#define SIT_KEY_I                  73
#define SIT_KEY_J                  74
#define SIT_KEY_K                  75
#define SIT_KEY_L                  76
#define SIT_KEY_M                  77
#define SIT_KEY_N                  78
#define SIT_KEY_O                  79
#define SIT_KEY_P                  80
#define SIT_KEY_Q                  81
#define SIT_KEY_R                  82
#define SIT_KEY_S                  83
#define SIT_KEY_T                  84
#define SIT_KEY_U                  85
#define SIT_KEY_V                  86
#define SIT_KEY_W                  87
#define SIT_KEY_X                  88
#define SIT_KEY_Y                  89
#define SIT_KEY_Z                  90
#define SIT_KEY_LEFT_BRACKET       91  /* [ */
#define SIT_KEY_BACKSLASH          92  /* \ */
#define SIT_KEY_RIGHT_BRACKET      93  /* ] */
#define SIT_KEY_GRAVE_ACCENT       96  /* ` */
#define SIT_KEY_WORLD_1            161 /* non-US #1 */
#define SIT_KEY_WORLD_2            162 /* non-US #2 */

// --- Function keys ---
#define SIT_KEY_ESCAPE             256
#define SIT_KEY_ENTER              257
#define SIT_KEY_TAB                258
#define SIT_KEY_BACKSPACE          259
#define SIT_KEY_INSERT             260
#define SIT_KEY_DELETE             261
#define SIT_KEY_RIGHT              262
#define SIT_KEY_LEFT               263
#define SIT_KEY_DOWN               264
#define SIT_KEY_UP                 265
#define SIT_KEY_PAGE_UP            266
#define SIT_KEY_PAGE_DOWN          267
#define SIT_KEY_HOME               268
#define SIT_KEY_END                269
#define SIT_KEY_CAPS_LOCK          280
#define SIT_KEY_SCROLL_LOCK        281
#define SIT_KEY_NUM_LOCK           282
#define SIT_KEY_PRINT_SCREEN       283
#define SIT_KEY_PAUSE              284
#define SIT_KEY_F1                 290
#define SIT_KEY_F2                 291
#define SIT_KEY_F3                 292
#define SIT_KEY_F4                 293
#define SIT_KEY_F5                 294
#define SIT_KEY_F6                 295
#define SIT_KEY_F7                 296
#define SIT_KEY_F8                 297
#define SIT_KEY_F9                 298
#define SIT_KEY_F10                299
#define SIT_KEY_F11                300
#define SIT_KEY_F12                301
#define SIT_KEY_F13                302
#define SIT_KEY_F14                303
#define SIT_KEY_F15                304
#define SIT_KEY_F16                305
#define SIT_KEY_F17                306
#define SIT_KEY_F18                307
#define SIT_KEY_F19                308
#define SIT_KEY_F20                309
#define SIT_KEY_F21                310
#define SIT_KEY_F22                311
#define SIT_KEY_F23                312
#define SIT_KEY_F24                313
#define SIT_KEY_F25                314

// --- Keypad keys ---
#define SIT_KEY_KP_0               320
#define SIT_KEY_KP_1               321
#define SIT_KEY_KP_2               322
#define SIT_KEY_KP_3               323
#define SIT_KEY_KP_4               324
#define SIT_KEY_KP_5               325
#define SIT_KEY_KP_6               326
#define SIT_KEY_KP_7               327
#define SIT_KEY_KP_8               328
#define SIT_KEY_KP_9               329
#define SIT_KEY_KP_DECIMAL         330
#define SIT_KEY_KP_DIVIDE          331
#define SIT_KEY_KP_MULTIPLY        332
#define SIT_KEY_KP_SUBTRACT        333
#define SIT_KEY_KP_ADD             334
#define SIT_KEY_KP_ENTER           335
#define SIT_KEY_KP_EQUAL           336

// --- Modifier keys (positional) ---
#define SIT_KEY_LEFT_SHIFT         340
#define SIT_KEY_LEFT_CONTROL       341
#define SIT_KEY_LEFT_ALT           342
#define SIT_KEY_LEFT_SUPER         343 // Windows/Command/Meta key
#define SIT_KEY_RIGHT_SHIFT        344
#define SIT_KEY_RIGHT_CONTROL      345
#define SIT_KEY_RIGHT_ALT          346
#define SIT_KEY_RIGHT_SUPER        347
#define SIT_KEY_MENU               348

// --- Modifier Bitmasks ---
#define SIT_MOD_SHIFT              0x0001
#define SIT_MOD_CONTROL            0x0002
#define SIT_MOD_ALT                0x0004
#define SIT_MOD_SUPER              0x0008
#define SIT_MOD_CAPS_LOCK          0x0010
#define SIT_MOD_NUM_LOCK           0x0020


/**
 * @brief Basic Math Types
 */
typedef struct ColorHSV { float h, s, v; } ColorHSV; // Hue = 0.0f to 360.0f degrees, Saturation = 0.0f grayscale to 1.0f color, Value/Brightness = 0.0f to 1.0f
typedef struct ColorYPQA { unsigned char y, p, q, a; } ColorYPQA; // Luminance (0-255), Phase (0-255), Quadrature (0-255), Alpha (0-255)
typedef struct ColorRGBA { unsigned char r, g, b, a; } ColorRGBA;
typedef ColorRGBA Color;
typedef struct Vector2 { float x; float y; } Vector2;
typedef struct Rectangle { float x, y, width, height; } Rectangle;

typedef struct SituationImage {
    void *data;                                     // Image raw data (RGBA, 32-bit)
    int width;                                      // Image width
    int height;                                     // Image height
} SituationImage;

/**
 * @brief Specifies the type of flip operation to perform on an image.
 */
typedef enum SituationImageFlipMode {
    SIT_FLIP_VERTICAL,                              // Flips the image top-to-bottom.
    SIT_FLIP_HORIZONTAL,                            // Flips the image left-to-right.
    SIT_FLIP_BOTH                                   // Flips both vertically and horizontally (180-degree rotation).
} SituationImageFlipMode;

/**
 * @brief manage a loaded font
 */
typedef struct SituationFont {
    void *fontData;                                 // The raw data buffer of the .ttf file
    void *stbFontInfo;                              // A pointer to the stbtt_fontinfo struct
} SituationFont;

/**
 * @brief Renderer Abstraction
 */
typedef enum {
    SIT_RENDERER_OPENGL,
    SIT_RENDERER_VULKAN
} SituationRendererType;

/**
 * @brief Defines a set of common, pre-configured layouts for compute pipelines.
 * @details This enum is passed to SituationCreateComputePipeline* to select an appropriate
 *          VkPipelineLayout that matches the resources declared in the compute shader.
 */
typedef enum {
    SIT_COMPUTE_LAYOUT_ONE_SSBO,                    // A layout for shaders that use one Shader Storage Buffer Object (SSBO) at set 0.
    SIT_COMPUTE_LAYOUT_TWO_SSBOS,                   // A layout for shaders that use two SSBOs at sets 0 and 1.
    SIT_COMPUTE_LAYOUT_IMAGE_AND_SSBO,              // A layout for shaders that use one Storage Image at set 0 and one SSBO at set 1.
    SIT_COMPUTE_LAYOUT_PUSH_CONSTANT,               // A layout for shaders that use a 64-byte push constant for small data.
    SIT_COMPUTE_LAYOUT_EMPTY,                       // A layout for simple shaders that take no external resources.
} SituationComputeLayoutType;

/**
 * @brief Opaque handle for a command buffer
 */
typedef struct SituationCommandBuffer_t* SituationCommandBuffer;

/**
 * @brief Error Handling
 */
typedef enum {
    //----------------------------------------------------------------
    // --- Core & System Errors (0-99) ---
    //----------------------------------------------------------------
    SITUATION_SUCCESS = 0,
    SITUATION_ERROR_GENERAL,                        // A generic, unspecified error occurred.
    SITUATION_ERROR_NOT_IMPLEMENTED,                // A feature is declared but not implemented for the current backend.
    SITUATION_ERROR_NOT_INITIALIZED,                // A core library function was called before SituationInit().
    SITUATION_ERROR_ALREADY_INITIALIZED,            // SituationInit() was called more than once.
    SITUATION_ERROR_INIT_FAILED,                    // Core library initialization failed.
    SITUATION_ERROR_SHUTDOWN_FAILED,                // Core library shutdown failed.
    SITUATION_ERROR_INVALID_PARAM,                  // A function was called with an invalid parameter (e.g., NULL pointer, out-of-range value).
    SITUATION_ERROR_MEMORY_ALLOCATION,              // A memory allocation (malloc, calloc, realloc) failed.

    //----------------------------------------------------------------
    // --- Platform & Window Errors (100-199) ---
    //----------------------------------------------------------------
    SITUATION_ERROR_GLFW_FAILED = 100,              // A call to the underlying GLFW library failed.
    SITUATION_ERROR_WINDOW_FOCUS,                   // An operation related to window focus failed.
    SITUATION_ERROR_DEVICE_QUERY,                   // Failed to query system hardware or device information.
    SITUATION_ERROR_TIMER_SYSTEM,                   // An error occurred within the internal timer/oscillator system.
    SITUATION_ERROR_COM_FAILED,                     // [Win32] Failed to initialize the COM library.
    SITUATION_ERROR_DXGI_FAILED,                    // [Win32] A call to the DXGI library failed (e.g., for GPU info).

    //----------------------------------------------------------------
    // --- Display & Virtual Display Errors (200-299) ---
    //----------------------------------------------------------------
    SITUATION_ERROR_DISPLAY_QUERY = 200,            // Failed to query physical monitor information.
    SITUATION_ERROR_DISPLAY_SET,                    // Failed to set a display mode on a physical monitor.
    SITUATION_ERROR_VIRTUAL_DISPLAY_LIMIT,          // The maximum number of virtual displays has been reached.
    SITUATION_ERROR_VIRTUAL_DISPLAY_INVALID_ID,     // An invalid virtual display ID was provided.

    //----------------------------------------------------------------
    // --- Filesystem Errors (300-399) ---
    //----------------------------------------------------------------
    SITUATION_ERROR_FILE_ACCESS = 300,              // A generic file or directory access error occurred.
    SITUATION_ERROR_PATH_NOT_FOUND,                 // The specified file or directory was not found.
    SITUATION_ERROR_PATH_INVALID,                   // The specified path is invalid or contains illegal characters.
    SITUATION_ERROR_PERMISSION_DENIED,              // Permission was denied for the requested file operation.
    SITUATION_ERROR_DISK_FULL,                      // The disk is full; cannot complete a write operation.
    SITUATION_ERROR_FILE_LOCKED,                    // The file is locked or currently in use by another process.
    SITUATION_ERROR_DIR_NOT_EMPTY,                  // A directory is not empty and cannot be deleted non-recursively.
    SITUATION_ERROR_FILE_ALREADY_EXISTS,            // The specified file already exists where it shouldn't.
    SITUATION_ERROR_PATH_IS_DIRECTORY,              // A file operation was attempted on a path that is a directory.
    SITUATION_ERROR_PATH_IS_FILE,                   // A directory operation was attempted on a path that is a file.
    
    //----------------------------------------------------------------
    // --- Audio Errors (400-499) ---
    //----------------------------------------------------------------
    SITUATION_ERROR_AUDIO_CONTEXT = 400,            // Failed to initialize the audio context (MiniAudio).
    SITUATION_ERROR_AUDIO_DEVICE,                   // Failed to initialize, start, or stop an audio device.
    SITUATION_ERROR_AUDIO_SOUND_LIMIT,              // The sound playback queue limit was reached.
    SITUATION_ERROR_AUDIO_CONVERTER,                // Failed to configure a data format/rate converter for a sound.
    SITUATION_ERROR_AUDIO_DECODING,                 // Failed to decode an audio file.
    SITUATION_ERROR_AUDIO_INVALID_OPERATION,        // An invalid operation was attempted on a sound (e.g., cropping a stream).

    //----------------------------------------------------------------
    // --- Resource & Rendering Errors (500-599) ---
    //----------------------------------------------------------------
    SITUATION_ERROR_RESOURCE_INVALID = 500,         // An invalid handle (shader, mesh, texture, buffer) was passed to a function.
    SITUATION_ERROR_BUFFER_MAP_FAILED,              // Failed to map a GPU buffer to CPU memory.
    SITUATION_ERROR_BUFFER_INVALID_SIZE,            // A buffer operation was attempted with an out-of-bounds offset or size.
    SITUATION_ERROR_RENDER_COMMAND_FAILED,          // A command failed to be recorded to a command buffer.
    SITUATION_ERROR_RENDER_PASS_ACTIVE,             // An operation was attempted that is illegal during a render pass.
    SITUATION_ERROR_NO_RENDER_PASS_ACTIVE,          // A drawing operation was attempted outside of a render pass.

    //----------------------------------------------------------------
    // --- OpenGL Specific Errors (600-699) ---
    //----------------------------------------------------------------
    SITUATION_ERROR_OPENGL_GENERAL = 600,           // A generic OpenGL error occurred (glGetError).
    SITUATION_ERROR_OPENGL_LOADER_FAILED,           // Failed to load OpenGL functions (GLAD).
    SITUATION_ERROR_OPENGL_UNSUPPORTED,             // A required OpenGL version or extension is not supported by the driver.
    SITUATION_ERROR_OPENGL_SHADER_COMPILE,          // GLSL shader compilation failed.
    SITUATION_ERROR_OPENGL_SHADER_LINK,             // GLSL shader program linking failed.
    SITUATION_ERROR_OPENGL_FBO_INCOMPLETE,          // A Framebuffer Object is not complete and cannot be used for rendering.

    //----------------------------------------------------------------
    // --- Vulkan Specific Errors (700-799) ---
    //----------------------------------------------------------------
    SITUATION_ERROR_VULKAN_INIT_FAILED = 700,       // General Vulkan initialization failed.
    SITUATION_ERROR_VULKAN_INSTANCE_FAILED,         // Failed to create a VkInstance.
    SITUATION_ERROR_VULKAN_DEVICE_FAILED,           // Failed to select a physical or create a logical device.
    SITUATION_ERROR_VULKAN_UNSUPPORTED,             // A required Vulkan layer, extension, or feature is unsupported.
    SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED,        // A swapchain operation failed (creation, acquire, present).
    SITUATION_ERROR_VULKAN_COMMAND_FAILED,          // A command pool or buffer operation failed.
    SITUATION_ERROR_VULKAN_RENDERPASS_FAILED,       // Failed to create a VkRenderPass.
    SITUATION_ERROR_VULKAN_FRAMEBUFFER_FAILED,      // Failed to create a VkFramebuffer.
    SITUATION_ERROR_VULKAN_PIPELINE_FAILED,         // Failed to create a graphics or compute pipeline.
    SITUATION_ERROR_VULKAN_SYNC_OBJECT_FAILED,      // Failed to create a fence or semaphore.
    SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED,     // A GPU memory allocation failed (VMA).
    SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED        // A descriptor set or pool operation failed.
} SituationError;

/**
 * @brief Device Information Structures
 */
typedef struct {
    char cpu_name[SITUATION_MAX_CPU_NAME_LEN];
    int cpu_cores;
    float cpu_clock_speed_ghz;
    char gpu_name[SITUATION_MAX_GPU_NAME_LEN];
    uint64_t gpu_dedicated_memory_bytes;            // Primarily via DXGI on Windows
    uint64_t total_ram_bytes;
    uint64_t available_ram_bytes;
    int storage_device_count;
    char storage_device_names[SITUATION_MAX_STORAGE_DEVICES][SITUATION_MAX_DEVICE_NAME_LEN];
    uint64_t storage_capacity_bytes[SITUATION_MAX_STORAGE_DEVICES];
    uint64_t storage_free_bytes[SITUATION_MAX_STORAGE_DEVICES];
    int network_adapter_count;
    char network_adapter_names[SITUATION_MAX_NETWORK_ADAPTERS][SITUATION_MAX_DEVICE_NAME_LEN];
    int input_device_count;
    char input_device_names[SITUATION_MAX_INPUT_DEVICES][SITUATION_MAX_DEVICE_NAME_LEN];
} SituationDeviceInfo;

/**
 * @brief Physical Display Management Structures
 */
typedef struct {
    int width;
    int height;
    int refresh_rate;
    int color_depth;                                // Can be tricky to get reliably for all modes/APIs
} SituationDisplayMode;

typedef struct {
    char name[SITUATION_MAX_MONITOR_NAME_LEN];      // Win32 device name
    int situation_monitor_id;                       // Internal ID, corresponds to index in cached_physical_displays_array
    GLFWmonitor* glfw_monitor_handle;               // Corresponding GLFW monitor handle, if matched
    bool is_primary;
    SituationDisplayMode current_mode;
    SituationDisplayMode* available_modes;          // Caller must free
    int available_mode_count;
} SituationDisplayInfo;

/**
 * @brief Defines standard system cursor shapes.
 */
typedef enum {
    SIT_CURSOR_DEFAULT = 0,                         // The default, platform-specific arrow
    SIT_CURSOR_ARROW,                               // A standard arrow cursor
    SIT_CURSOR_IBEAM,                               // The text input I-beam
    SIT_CURSOR_CROSSHAIR,                           // A crosshair for targeting
    SIT_CURSOR_HAND,                                // A pointing hand, for links or buttons
    SIT_CURSOR_HRESIZE,                             // Horizontal resize arrow (e.g., <->)
    SIT_CURSOR_VRESIZE                              // Vertical resize arrow (e.g., ^ v)
} SituationCursor;

/**
 * @brief Defines the color blending mode for a virtual display during compositing.
 * @details These modes determine how a virtual display's texture is drawn onto the main framebuffer.
 */
typedef enum {
    // --- Standard & Simple Modes ---
    SITUATION_BLEND_ALPHA,                          // Default alpha blending. Final = Src * SrcAlpha + Dst * (1 - SrcAlpha). Ideal for UI.
    SITUATION_BLEND_ADDITIVE,                       // Brightening blend (Src + Dst). Black is transparent. Good for glows, sparks.
    SITUATION_BLEND_MULTIPLY,                       // Darkening blend (Src * Dst). White is transparent. Good for shadows, tinting.
    SITUATION_BLEND_SCREEN,                         // Brightening blend, less harsh than additive. Inverts, multiplies, and inverts again.
    SITUATION_BLEND_NONE,                           // Opaque blend (Final = Src). Ignores alpha and overwrites destination.

    // --- Photoshop-Style Blend Modes (require custom shader) ---
    SITUATION_BLEND_OVERLAY,                        // Combines Multiply and Screen. Preserves highlights and shadows of the destination.
    SITUATION_BLEND_SOFT_LIGHT,                     // Darkens or lightens, depending on source color. A softer version of Hard Light.
    SITUATION_BLEND_HARD_LIGHT,                     // Combines Multiply and Screen based on source color. A harsher version of Overlay.
    SITUATION_BLEND_COLOR_DODGE,                    // Brightens the destination color to reflect the source color.
    SITUATION_BLEND_COLOR_BURN,                     // Darkens the destination color to reflect the source color.
    SITUATION_BLEND_DARKEN,                         // Selects the darker of the source and destination pixels.
    SITUATION_BLEND_LIGHTEN,                        // Selects the lighter of the source and destination pixels.
    SITUATION_BLEND_DIFFERENCE,                     // Subtracts the darker color from the lighter color. Black shows no change.
    SITUATION_BLEND_EXCLUSION,                      // Similar to Difference but with lower contrast.
} SituationBlendMode;

/**
 * @brief Defines the scaling and filtering method for a virtual display.
 */
typedef enum {
    // @brief Smoothly stretches the VD to fill its defined rectangle (via offset/resolution).
    // Ignores aspect ratio. Uses GL_LINEAR filtering (blurry). Good for high-res UI.
    SITUATION_SCALING_STRETCH,

    // @brief Sharp, aspect-correct scaling that fills the screen as much as possible.
    // Uses GL_NEAREST filtering (sharp). This is your requested "sharp stretch" mode.
    // This will leave minimal black bars (letterbox/pillarbox).
    SITUATION_SCALING_FIT,

    // @brief Sharp, aspect-correct, integer-only scaling.
    // Guarantees all game pixels are perfect squares on screen, but may leave larger black bars.
    // Uses GL_NEAREST filtering (sharp). This is the "pixel perfect" purist mode.
    SITUATION_SCALING_INTEGER

} SituationScalingMode;

/** @brief Specifies how an attachment's contents should be treated at the start of a render pass. */
typedef enum {
    SIT_LOAD_OP_LOAD,       // Preserve the existing contents of the attachment.
    SIT_LOAD_OP_CLEAR,      // Clear the attachment to a specified value.
    SIT_LOAD_OP_DONT_CARE   // The existing contents are undefined and can be discarded.
} SituationAttachmentLoadOp;

/** @brief Specifies how an attachment's contents should be treated at the end of a render pass. */
typedef enum {
    SIT_STORE_OP_STORE,     // The rendered contents will be stored in memory for later access.
    SIT_STORE_OP_DONT_CARE  // The rendered contents are not needed after the pass and can be discarded.
} SituationAttachmentStoreOp;

/** @brief Defines the clear values for color and depth/stencil attachments. */
typedef struct {
    ColorRGBA color;
    float     depth;
    uint32_t  stencil;
} SituationClearValue;

/** @brief Configuration for a single attachment (color or depth) in a render pass. */
typedef struct {
    SituationAttachmentLoadOp  loadOp;
    SituationAttachmentStoreOp storeOp;
    SituationClearValue        clear;
} SituationAttachmentInfo;

/** @brief Complete configuration for beginning a render pass. */
typedef struct {
    int                     display_id;     // The render target (-1 for main window, >= 0 for a Virtual Display).
    SituationAttachmentInfo color_attachment;
    SituationAttachmentInfo depth_attachment;
} SituationRenderPassInfo;

/**
 * @brief Window State Management
 * @details These flags are now custom defines, their values are arbitrary but must be unique bits. Their functionality will be mapped to GLFW operations.
 */
#define SITUATION_FLAG_WINDOW_TOPMOST           0x00000001  // GLFW_FLOATING
#define SITUATION_FLAG_WINDOW_HIDDEN            0x00000002  // glfwHideWindow/ShowWindow
#define SITUATION_FLAG_WINDOW_FROZEN            0x00000004  // Conceptual, app-defined
#define SITUATION_FLAG_FULLSCREEN_MODE          0x00000008  // glfwSetWindowMonitor
#define SITUATION_FLAG_WINDOW_UNDECORATED       0x00000010  // GLFW_DECORATED attribute
#define SITUATION_FLAG_WINDOW_ALWAYS_RUN        0x00000020  // No direct GLFW equivalent, typically always runs when visible
#define SITUATION_FLAG_WINDOW_MINIMIZED         0x00000040  // glfwIconifyWindow, GLFW_ICONIFIED attribute
#define SITUATION_FLAG_WINDOW_MAXIMIZED         0x00000080  // glfwMaximizeWindow, GLFW_MAXIMIZED attribute
#define SITUATION_FLAG_WINDOW_UNFOCUSED         0x00000100  // Queryable state (GLFW_FOCUSED), not settable
#define SITUATION_FLAG_WINDOW_RESIZABLE         0x00000200  // GLFW_RESIZABLE attribute
#define SITUATION_FLAG_BORDERLESS_WINDOWED_MODE 0x00000400  // Achieved via undecorated + specific size/pos
#define SITUATION_FLAG_MSAA_4X_HINT             0x00000800  // glfwWindowHint(GLFW_SAMPLES, 4)
#define SITUATION_FLAG_VSYNC_HINT               0x00001000  // glfwSwapInterval(1)

typedef enum { // Enum can still use the defines for clarity in API
    SITUATION_WINDOW_STATE_ON_TOP         = SITUATION_FLAG_WINDOW_TOPMOST,
    SITUATION_WINDOW_STATE_HIDDEN         = SITUATION_FLAG_WINDOW_HIDDEN,
    SITUATION_WINDOW_STATE_FROZEN         = SITUATION_FLAG_WINDOW_FROZEN,
    SITUATION_WINDOW_STATE_FULLSCREEN     = SITUATION_FLAG_FULLSCREEN_MODE,
    SITUATION_WINDOW_STATE_UNDECORATED    = SITUATION_FLAG_WINDOW_UNDECORATED,
    SITUATION_WINDOW_STATE_ALWAYS_RUN     = SITUATION_FLAG_WINDOW_ALWAYS_RUN,
    SITUATION_WINDOW_STATE_MINIMIZED      = SITUATION_FLAG_WINDOW_MINIMIZED,
    SITUATION_WINDOW_STATE_MAXIMIZED      = SITUATION_FLAG_WINDOW_MAXIMIZED,
    // SITUATION_WINDOW_STATE_UNFOCUSED   // Removed as it's not a settable state directly
    SITUATION_WINDOW_STATE_RESIZABLE      = SITUATION_FLAG_WINDOW_RESIZABLE,
    SITUATION_WINDOW_STATE_BORDERLESS     = SITUATION_FLAG_BORDERLESS_WINDOWED_MODE,
    SITUATION_WINDOW_STATE_MSAA_4X_HINT   = SITUATION_FLAG_MSAA_4X_HINT,
    SITUATION_WINDOW_STATE_VSYNC_HINT     = SITUATION_FLAG_VSYNC_HINT
} SituationWindowStateFlags;

// In your global state or a new rendering state struct
typedef struct {
    mat4 view;
    mat4 projection;
    // Add other per-view data here like camera position
} ViewDataUBO;

#ifdef SITUATION_IMPLEMENTATION
#if defined(SITUATION_USE_VULKAN)
// Forward declare VMA types used in public-facing structs
struct VmaAllocation_T;
typedef struct VmaAllocation_T* VmaAllocation;
#endif
#endif

/**
 * @brief Opaque handle for a compute pipeline.
 * @details In OpenGL, this represents a linked shader program containing only a compute shader.
 */
typedef struct {
    uint64_t id;

#if defined(SITUATION_IMPLEMENTATION)
    // Backend-specific handles, hidden from the public API user.
#if defined(SITUATION_USE_VULKAN)
    VkPipeline vk_pipeline;
    VkPipelineLayout vk_pipeline_layout;
#elif defined(SITUATION_USE_OPENGL)
    GLuint gl_program_id;
#endif
#endif
} SituationComputePipeline;

/**
 * @brief Opaque handle for a generic GPU data buffer (e.g., an SSBO).
 */
typedef struct {
    uint64_t id;
    size_t size_in_bytes;
#if defined(SITUATION_IMPLEMENTATION)
#if defined(SITUATION_USE_VULKAN)
    VkBuffer vk_buffer;
    VmaAllocation vma_allocation;
    VkBufferUsageFlags vk_usage_flags; // Store the flags used for creation
    // --- Persistent Descriptor Set for this buffer ---
    VkDescriptorSet descriptor_set; // Add this line
    // --- Optional: Store layout if needed for updates or debugging ---
    // VkDescriptorSetLayout descriptor_layout; // Uncomment if needed
#elif defined(SITUATION_USE_OPENGL)
    GLuint gl_buffer_id;
#endif
#endif
} SituationBuffer;

/**
 * @brief Represents a mesh of vertices and indices stored on the GPU.
 * @details This is an opaque handle to the underlying graphics resources (VBO/EBO/VAO for OpenGL, VkBuffers for Vulkan).
        The library manages the creation and destruction of these resources.
 */
typedef struct {
    uint64_t id; // Internal identifier or handle
    int index_count;

#if defined(SITUATION_IMPLEMENTATION)
    // Backend-specific handles, hidden from the public API user.
#if defined(SITUATION_USE_VULKAN)
    VkBuffer vertex_buffer;
    VmaAllocation vertex_buffer_memory;
    VkBuffer index_buffer;
    VmaAllocation index_buffer_memory;
#elif defined(SITUATION_USE_OPENGL)
    GLuint vao_id; // Vertex Array Object
    GLuint vbo_id; // Vertex Buffer Object
    GLuint ebo_id; // Element (Index) Buffer Object
#endif
#endif
} SituationMesh;

// Forward-declaration for the internal uniform map implementation struct.
// The full definition is hidden inside the SITUATION_IMPLEMENTATION block.
struct _SituationUniformMap;

// Enums for the 'type' parameter
typedef enum {
    SIT_UNIFORM_FLOAT,
    SIT_UNIFORM_VEC2,
    SIT_UNIFORM_VEC3,
    SIT_UNIFORM_VEC4,
    SIT_UNIFORM_INT,
    SIT_UNIFORM_IVEC2,
    SIT_UNIFORM_IVEC3,
    SIT_UNIFORM_IVEC4,
    SIT_UNIFORM_MAT4
} SituationUniformType;

// --- Shader Handle ---
typedef struct {
    uint64_t id; // Public identifier for the shader

#if defined(SITUATION_IMPLEMENTATION)
    // Backend-specific handles, hidden from the public API user
#if defined(SITUATION_USE_OPENGL)
    GLuint gl_program_id; // OpenGL shader program ID
    // Use a pointer to our internal hash map struct
    struct _SituationUniformMap* uniform_map; 
#elif defined(SITUATION_USE_VULKAN)
    VkPipeline vk_pipeline;
    VkPipelineLayout vk_pipeline_layout;
#endif
#endif
} SituationShader;

/**
 * @brief Opaque handle for a generic GPU texture resource.
 */
typedef struct {
    uint64_t id;            // Public identifier
    int width;
    int height;

#if defined(SITUATION_IMPLEMENTATION)
    // Backend-specific handles, hidden from the public API user.
#if defined(SITUATION_USE_VULKAN)
    VkImage image;
    VkImageView image_view;
    VkSampler sampler;
    VmaAllocation allocation;
    VkDescriptorSet descriptor_set;
#elif defined(SITUATION_USE_OPENGL)
    GLuint gl_texture_id;
#endif
#endif
} SituationTexture;

/**
 * @brief Represents a single drawable part of a larger 3D model.
 * @details A model can be composed of multiple sub-meshes, each with its own material properties and GPU mesh resource.
 */
typedef struct SituationModelMesh {
    char name[SITUATION_MAX_DEVICE_NAME_LEN]; // Name of the mesh from the model file
    SituationMesh gpu_mesh;                   // The handle to the GPU vertex/index data

    // --- PBR Material Properties ---
    // These are loaded directly from the GLTF material definition.
    vec4 base_color_factor;                   // The base color tint (RGBA)
    float metallic_factor;                    // How metallic the surface is [0-1]
    float roughness_factor;                   // How rough the surface is [0-1]
    vec3 emissive_factor;                     // The color of light emitted by the surface

    // --- Texture Handles ---
    // These point to textures that are also part of the model.
    SituationTexture base_color_texture;      // Albedo/Diffuse map
    SituationTexture metallic_roughness_texture; // Packed Metal (R), Rough (G) map
    SituationTexture normal_texture;          // Normal map
    SituationTexture occlusion_texture;       // Ambient Occlusion map
    SituationTexture emissive_texture;        // Emissive/Glow map
} SituationModelMesh;

/**
 * @brief Represents a complete 3D model, loaded from a file.
 * @details This is a container for all the meshes and materials that make up a model.
 *          It is the result of a call to SituationLoadModel.
 */
typedef struct SituationModel {
    uint64_t id;                              // A unique ID for the model object
    int mesh_count;                           // The number of sub-meshes in this model
    SituationModelMesh* meshes;               // A pointer to an array of this model's meshes

    // --- Resource Management (Internal) ---
#if defined(SITUATION_IMPLEMENTATION)
    // We need to track all textures loaded with this model so we can unload them properly.
    int texture_count;
    SituationTexture* all_model_textures;
#endif
} SituationModel;

// --- Virtual Display Structures ---
typedef struct {
    int id;                        // Internal ID for API use
    vec2 resolution;
    vec2 offset;                   // Screen position for rendering (top-left)
    float opacity;                 // Alpha blending (0.0f to 1.0f)
    bool visible;                  // Whether to render this display
    int z_order;                   // Z-order for compositing (lower drawn first)

    // Timing and animation related
    uint64_t frame_count;
    double frame_time_multiplier;
    double elapsed_time_seconds;
    float cycle_animation_value;
    double last_update_time_seconds;
    double frame_delta_time_seconds;
    
    // Optimization related (new)
    bool is_dirty;                  // True if content needs to be re-rendered
    SituationScalingMode scaling_mode;
    SituationBlendMode blend_mode;

    // Backend-specific handles
#if defined(SITUATION_IMPLEMENTATION)
#if defined(SITUATION_USE_VULKAN)
    struct {
        VkImage image;
        VmaAllocation image_memory;
        VkImageView image_view;
        VkImage depth_image;
        VmaAllocation depth_image_memory;
        VkImageView depth_image_view;
        VkFramebuffer framebuffer;
        VkSampler sampler;
        VkRenderPass render_pass; // Each VD has its own render pass
    } vk;
#elif defined(SITUATION_USE_OPENGL)
    struct {
        GLuint fbo_id;                 // OpenGL Framebuffer Object ID
        GLuint texture_id;             // OpenGL Texture ID for color attachment
        GLuint depth_rbo_id;           // OpenGL Renderbuffer for depth
    } gl;
#endif
#endif
} SituationVirtualDisplay;

// --- Audio Control Structures ---

typedef void (*SituationAudioProcessorCallback)(void* buffer, unsigned int frames, int channels, int sampleRate, void* userData);

typedef struct {
    int sample_rate;
    int channels;
    int bit_depth;
} SituationAudioFormat;

typedef struct {
    char name[SITUATION_MAX_DEVICE_NAME_LEN];
    ma_device_id id;
    int situation_internal_id;
    bool is_default_playback;
    bool is_default_capture;
} SituationAudioDeviceInfo;

typedef enum {
    SITUATION_FILTER_NONE,
    SITUATION_FILTER_LOWPASS,
    SITUATION_FILTER_HIGHPASS
} SituationFilterType;

typedef struct {
    ma_decoder decoder;
    ma_data_converter converter;
    bool is_initialized;
    bool converter_initialized;
    bool is_looping;
    bool is_streamed; // Flag to indicate if sound is from a stream
    uint64_t cursor_frames;
    uint64_t total_frames;
    float volume;       // Per-sound volume (0.0 to N.N, 1.0 is normal)
    float pan;          // Stereo pan (-1.0 full left, 0.0 center, 1.0 full right)
    float pitch;        // Pitch multiplier (1.0 is normal, > 1.0 is higher, < 1.0 is lower)
    void* stream_user_data; // New: User data for stream callbacks

    // --- Effects Chain ---
    struct {
        // Biquad Filter (for LPF/HPF)
        bool filter_enabled;
        ma_biquad biquad;
        SituationFilterType filter_type;
        float filter_cutoff_hz;
        float filter_q;

        // Echo (Delay)
        bool echo_enabled;
        ma_delay delay;
        float echo_delay_sec;
        float echo_feedback;
        float echo_wet_mix;

        // Reverb
        bool reverb_enabled;
        ma_reverb reverb;
        float reverb_room_size;
        float reverb_damping;
        float reverb_wet_mix;
        float reverb_dry_mix;
    } effects;

    // --- Custom DSP Processors ---
    SituationAudioProcessorCallback* processors;
    void** processor_user_data;
    int processor_count;
    
} SituationSound;

// --- Timer System Structures ---
#define SITUATION_MAX_OSCILLATORS 256
#define SITUATION_TIMER_GRID_PERIOD_EDGES 60.0
#define SITUATION_TIMER_GRIDILON 1.182940076

typedef struct {
    double period_seconds[SITUATION_MAX_OSCILLATORS];
    uint64_t state_current[4];
    uint64_t state_previous[4];
    uint64_t trigger_count[SITUATION_MAX_OSCILLATORS];
    double next_trigger_time_seconds[SITUATION_MAX_OSCILLATORS];
    double last_ping_time_seconds[SITUATION_MAX_OSCILLATORS];
    double current_system_time_seconds;
    bool is_initialized;
} SituationTimerSystem;

// Core Lifecycle & Error Handling
typedef struct {
    int window_width;
    int window_height;
    const char* window_title;
    uint32_t initial_active_window_flags;
    uint32_t initial_inactive_window_flags;
    // Vulkan specific options
    bool enable_vulkan_validation;
    uint32_t max_frames_in_flight;
    const char** required_vulkan_extensions;
    uint32_t required_vulkan_extension_count;
} SituationInitInfo;

/**
 * @brief Helper enum to specify the type of data provided to the GL compute program creation function.
 */
typedef enum {
    SITUATION_GL_SHADER_SOURCE_TYPE_GLSL,  // Standard null-terminated GLSL string
    SITUATION_GL_SHADER_SOURCE_TYPE_SPIRV  // SPIR-V bytecode
} SituationGLShaderSourceType;

/**
 * @brief Flags indicating which previous pipeline stages have written to memory.
 * @details Used to specify the source of a memory dependency in a pipeline barrier.
 */
typedef enum {
    SITUATION_BARRIER_VERTEX_SHADER_WRITE   = 1 << 0,
    SITUATION_BARRIER_FRAGMENT_SHADER_WRITE = 1 << 1,
    SITUATION_BARRIER_COMPUTE_SHADER_WRITE  = 1 << 2,
    SITUATION_BARRIER_TRANSFER_WRITE        = 1 << 3, // For buffer copies
} SituationBarrierSrcFlags;

/**
 * @brief Flags indicating which subsequent pipeline stages will read from memory.
 * @details Used to specify the destination of a memory dependency in a pipeline barrier.
 */
typedef enum {
    SITUATION_BARRIER_VERTEX_SHADER_READ   = 1 << 0,
    SITUATION_BARRIER_FRAGMENT_SHADER_READ = 1 << 1,
    SITUATION_BARRIER_COMPUTE_SHADER_READ  = 1 << 2,
    SITUATION_BARRIER_TRANSFER_READ        = 1 << 3,
    SITUATION_BARRIER_INDIRECT_COMMAND_READ = 1 << 4,
} SituationBarrierDstFlags;

/**
 * @brief Flags defining how a buffer will be used by the GPU.
 * These flags allow the backend (OpenGL/Vulkan) to optimize memory allocation and access patterns. Combine flags using bitwise OR.
 */
typedef enum {
    SITUATION_BUFFER_USAGE_VERTEX_BUFFER      = 1 << 0, /**< Buffer will be used as a source of vertex data (e.g., glVertexAttribPointer). */
    SITUATION_BUFFER_USAGE_INDEX_BUFFER       = 1 << 1, /**< Buffer will be used as a source of index data (e.g., glDrawElements). */
    SITUATION_BUFFER_USAGE_UNIFORM_BUFFER     = 1 << 2, /**< Buffer will be used as a Uniform Buffer Object (UBO). */
    SITUATION_BUFFER_USAGE_STORAGE_BUFFER     = 1 << 3, /**< Buffer will be used as a Shader Storage Buffer Object (SSBO). */
    SITUATION_BUFFER_USAGE_INDIRECT_BUFFER    = 1 << 4, /**< Buffer will be used for indirect drawing commands (e.g., glMultiDrawElementsIndirect). */
    SITUATION_BUFFER_USAGE_TRANSFER_SRC       = 1 << 5, /**< Buffer can be used as a source for transfer operations (e.g., copying data). */
    SITUATION_BUFFER_USAGE_TRANSFER_DST       = 1 << 6, /**< Buffer can be used as a destination for transfer operations (e.g., uploading data). */
    // Add more flags as needed for specific features
    // Combination flags for common use cases
    SITUATION_BUFFER_USAGE_VERTEX_AND_STORAGE = SITUATION_BUFFER_USAGE_VERTEX_BUFFER | SITUATION_BUFFER_USAGE_STORAGE_BUFFER
} SituationBufferUsageFlags;

// --- Callback and Type Definitions ---
typedef void (*SituationFileDropCallback)(int count, const char** paths, void* user_data);                      // Function pointer for file drop events.
typedef void (*SituationFocusCallback)(bool has_focus, void* user_data);                                        // Function pointer for window focus change events.
typedef ma_uint64 (*SituationStreamReadCallback)(void* pUserData, void* pBufferOut, ma_uint64 bytesToRead);     // Function pointer for custom audio stream "read" operations.
typedef ma_result (*SituationStreamSeekCallback)(void* pUserData, ma_int64 byteOffset, ma_seek_origin origin);  // Function pointer for custom audio stream "seek" operations.
typedef void (*SituationKeyCallback)(int key, int scancode, int action, int mods, void* user_data);             // Function pointer for keyboard key events.
typedef void (*SituationMouseButtonCallback)(int button, int action, int mods, void* user_data);                // Function pointer for mouse button events.
typedef void (*SituationCursorPosCallback)(vec2 position, void* user_data);                                     // Function pointer for mouse cursor movement events.
typedef void (*SituationScrollCallback)(vec2 offset, void* user_data);                                          // Function pointer for mouse scroll wheel events.
typedef void (*SituationJoystickCallback)(int jid, int event, void* user_data);                                 // Function pointer for joystick connection/disconnection events.
// GLFW has its own error callback: typedef void (*GLFWerrorfun)(int error_code, const char* description);

//----------------------------------------------------------------------------------
// --- API Declarations ---
//----------------------------------------------------------------------------------
/**
 * @section API Usage Guide
 *
 * @b 1. @b Lifecycle
 * The library follows a strict lifecycle:
 *   - Call `SituationInit()` once at the start of your application.
 *   - Enter a main loop that runs until `SituationWindowShouldClose()` returns true.
 *   - Call `SituationShutdown()` once before your application exits.
 * All API functions (except where noted) must be called between `SituationInit()` and `SituationShutdown()`.
 *
 * @b 2. @b Main @b Loop @b Structure
 * A correct "Situation" main loop has three distinct phases per frame:
 *   1.  **Input:** Call `SituationPollInputEvents()` to gather all OS events.
 *   2.  **Update:** Call `SituationUpdateTimers()` to calculate delta time, then run your application logic.
 *   3.  **Render:** Call `SituationAcquireFrameCommandBuffer()`, record all your drawing commands using `SituationCmd*` functions, and finish with `SituationEndFrame()`.
 *
 * @b 3. @b Resource @b Management @b (CRITICAL)
 * The library uses explicit, manual resource management. This is a core design principle.
 *   - Any resource created with a `SituationCreate*` or `SituationLoad*` function (e.g., `SituationCreateMesh`, `SituationLoadTexture`) **MUST** be explicitly freed with its corresponding `SituationDestroy*` or `SituationUnload*` function.
 *   - Any function that returns a `char*` (e.g., `SituationGetLastErrorMsg`, `SituationGetBasePath`) returns a new block of memory. The **caller is responsible for freeing this memory** using `free()`.
 *   - Failure to follow these rules will result in GPU and CPU memory leaks. The library will print warnings for leaked GPU resources at shutdown.
 *
 * @b 4. @b Handles @b vs. @b Pointers
 * The API uses two patterns for interacting with objects:
 *   - **Handles (by value):** Opaque structs like `SituationMesh` or `SituationShader` are typically passed by value to drawing or binding functions (e.g., `SituationCmdDrawMesh(my_mesh)`).
 *   - **Pointers (for modification):** When a function needs to modify or destroy a resource, you must pass a pointer to its handle (e.g., `SituationDestroyMesh(&my_mesh)`). This allows the function to invalidate the handle by setting its internal ID to 0.
 *
 * @b 5. @b Thread @b Safety
 * The library is **strictly single-threaded**. All `SITAPI` functions must be called from the same thread that called `SituationInit()`. Asynchronous operations (like asset loading) must be handled by the user, ensuring that no `SITAPI` calls are made from worker threads.
 */
 
//==================================================================================
// Core Module: Application Lifecycle and System
//==================================================================================

// --- Application Lifecycle & State ---
SITAPI SituationError SituationInit(int argc, char** argv, const SituationInitInfo* init_info); // Initialize the library, create window and graphics context.
SITAPI void SituationPollInputEvents(void);                                             // Poll for all input events (keyboard, mouse, joystick). Call once per frame.
SITAPI void SituationUpdateTimers(void);                                                // Update all internal timers (frame timer, temporal system). Call after polling events.
SITAPI void SituationUpdate(void);                                                      // DEPRECATED: Use SituationPollInputEvents() and SituationUpdateTimers().
SITAPI void SituationShutdown(void);                                                    // Shut down the library and release all resources.
SITAPI bool SituationIsInitialized(void);                                               // Check if the library has been successfully initialized.
SITAPI bool SituationWindowShouldClose(void);                                           // Check if the application should close (e.g., user clicked X).
SITAPI void SituationPauseApp(void);                                                    // Pause the application's internal state (e.g., audio).
SITAPI void SituationResumeApp(void);                                                   // Resume a paused application.
SITAPI bool SituationIsAppPaused(void);                                                 // Check if the application is currently paused.

// --- Frame Timing & FPS Management ---
SITAPI void SituationSetTargetFPS(int fps);                                             // Set a desired frame rate cap (0 for uncapped).
SITAPI float SituationGetFrameTime(void);                                               // Get the time in seconds for the last frame to complete (deltaTime).
SITAPI int SituationGetFPS(void);                                                       // Get the current frames-per-second value.

// --- Callbacks and Event Handling ---
SITAPI char* SituationGetLastErrorMsg(void);                                            // Get the last error message as a string (caller must free).
SITAPI void SituationSetExitCallback(void (*callback)(void* user_data), void* user_data); // Set a callback to run just before shutdown.
SITAPI void SituationSetResizeCallback(void (*callback)(int width, int height, void* user_data), void* user_data); // Set a callback for window framebuffer resize events.
SITAPI void SituationSetFocusCallback(SituationFocusCallback callback, void* user_data); // Set a callback for window focus events.
SITAPI void SituationSetFileDropCallback(SituationFileDropCallback callback, void* user_data); // Set a callback for file drop events.

// --- Command-Line Argument Queries ---
SITAPI bool SituationIsArgumentPresent(const char* arg_name);                           // Check if a command-line argument (e.g., "-server") was provided.
SITAPI const char* SituationGetArgumentValue(const char* arg_name);                     // Get the value of an argument (e.g., "jungle" from "-level:jungle").

// --- System & Hardware Information ---
SITAPI SituationDeviceInfo SituationGetDeviceInfo(void);                                // Get detailed information about system hardware (CPU, GPU, RAM, etc.).
SITAPI char* SituationGetUserDirectory(void);                                           // Get the full path to the current user's home directory (caller must free).
SITAPI char SituationGetCurrentDriveLetter(void);                                       // Get the drive letter of the running executable (Windows only).
SITAPI bool SituationGetDriveInfo(char drive_letter, uint64_t* out_total_capacity_bytes, uint64_t* out_free_space_bytes, char* out_volume_name, int volume_name_len); // Get info for a specific drive (Windows only).
SITAPI void SituationOpenFile(const char* filePath);                                    // Open a file or folder with its default application.

//==================================================================================
// Window and Display Module
//==================================================================================
// --- Window State Management ---
SITAPI void SituationSetWindowState(uint32_t flags);                                    // Set window configuration state using flags (additive).
SITAPI void SituationClearWindowState(uint32_t flags);                                  // Clear window configuration state flags.
SITAPI void SituationToggleFullscreen(void);                                            // Toggle window between fullscreen and windowed mode.
SITAPI void SituationToggleBorderlessWindowed(void);                                    // Toggle window between borderless and decorated mode.
SITAPI void SituationMaximizeWindow(void);                                              // Maximize the window if it's resizable.
SITAPI void SituationMinimizeWindow(void);                                              // Minimize the window (iconify).
SITAPI void SituationRestoreWindow(void);                                               // Restore a minimized or maximized window.
SITAPI void SituationSetWindowFocused(void);                                            // Set the window to be focused.

// --- Window Property Management ---
SITAPI void SituationSetWindowTitle(const char *title);                                 // Set the title for the window.
SITAPI void SituationSetWindowIcon(SituationImage image);                               // Set the icon for the window (single image).
SITAPI void SituationSetWindowIcons(SituationImage *images, int count);                 // Set the icon for the window (multiple sizes).
SITAPI void SituationSetWindowPosition(int x, int y);                                   // Set the window position on the screen.
SITAPI void SituationSetWindowSize(int width, int height);                              // Set the window dimensions.
SITAPI void SituationSetWindowMinSize(int width, int height);                           // Set the window minimum dimensions.
SITAPI void SituationSetWindowMaxSize(int width, int height);                           // Set the window maximum dimensions.
SITAPI void SituationSetWindowOpacity(float opacity);                                   // Set window opacity [0.0f to 1.0f].

// --- Window State Queries ---
SITAPI bool SituationIsWindowState(uint32_t flag);                                      // Check if a specific window state flag is set.
SITAPI bool SituationIsWindowFullscreen(void);                                          // Check if the window is currently in fullscreen mode.
SITAPI bool SituationIsWindowHidden(void);                                              // Check if the window is currently hidden.
SITAPI bool SituationIsWindowMinimized(void);                                           // Check if the window is currently minimized.
SITAPI bool SituationIsWindowMaximized(void);                                           // Check if the window is currently maximized.
SITAPI bool SituationHasWindowFocus(void);                                              // Check if the window is currently focused.
SITAPI bool SituationIsWindowResized(void);                                             // Check if the window was resized in the last frame.

// --- Window & Screen Dimension Queries ---
SITAPI int SituationGetScreenWidth(void);                                               // Get the current logical width of the window.
SITAPI int SituationGetScreenHeight(void);                                              // Get the current logical height of the window.
SITAPI int SituationGetRenderWidth(void);                                               // Get the current render width (backbuffer size, considers HiDPI).
SITAPI int SituationGetRenderHeight(void);                                              // Get the current render height (backbuffer size, considers HiDPI).
SITAPI void SituationGetWindowSize(int* width, int* height);                            // Get the current logical window size.
SITAPI Vector2 SituationGetWindowPosition(void);                                        // Get the window's top-left position on the screen.
SITAPI Vector2 SituationGetWindowScaleDPI(void);                                        // Get the DPI scaling factor for the window.

// --- Physical Display (Monitor) Management ---
SITAPI int SituationGetMonitorCount(void);                                              // Get the number of connected monitors.
SITAPI int SituationGetCurrentMonitor(void);                                            // Get the index of the monitor the window is on.
SITAPI SituationDisplayInfo* SituationGetDisplays(int* count);                          // Get information for all displays (caller must free).
SITAPI void SituationRefreshDisplays(void);                                             // Force a refresh of the cached display information.
SITAPI SituationError SituationSetDisplayMode(int monitor_id, const SituationDisplayMode* mode, bool fullscreen); // Set the display mode for a monitor.
SITAPI void SituationSetWindowMonitor(int monitor_id);                                  // Set the window to be fullscreen on a specific monitor.
SITAPI const char* SituationGetMonitorName(int monitor_id);                             // Get the human-readable name of a monitor.
SITAPI int SituationGetMonitorWidth(int monitor_id);                                    // Get the width of a monitor's current video mode.
SITAPI int SituationGetMonitorHeight(int monitor_id);                                   // Get the height of a monitor's current video mode.
SITAPI int SituationGetMonitorPhysicalWidth(int monitor_id);                            // Get the physical width of a monitor in millimeters.
SITAPI int SituationGetMonitorPhysicalHeight(int monitor_id);                           // Get the physical height of a monitor in millimeters.
SITAPI int SituationGetMonitorRefreshRate(int monitor_id);                              // Get the refresh rate of a monitor.
SITAPI Vector2 SituationGetMonitorPosition(int monitor_id);                             // Get the top-left position of a monitor on the desktop.

// --- Cursor, Clipboard and File Drops ---
SITAPI void SituationSetCursor(SituationCursor cursor);                                 // Set the mouse cursor to a standard shape.
SITAPI void SituationShowCursor(void);                                                  // Show the mouse cursor.
SITAPI void SituationHideCursor(void);                                                  // Hide the mouse cursor.
SITAPI void SituationDisableCursor(void);                                               // Hide and lock the cursor, providing raw mouse motion.
SITAPI const char* SituationGetClipboardText(void);                                     // Get text from the system clipboard.
SITAPI void SituationSetClipboardText(const char* text);                                // Set text in the system clipboard.
SITAPI bool SituationIsFileDropped(void);                                               // Check if a file was dropped into the window this frame.
SITAPI char** SituationLoadDroppedFiles(int* count);                                    // Get the paths of dropped files (returns a copy, caller must free).
SITAPI void SituationUnloadDroppedFiles(char** paths, int count);                       // Unload the file path list returned by SituationLoadDroppedFiles.

// --- Advanced Window Profile Management ---
SITAPI SituationError SituationSetWindowStateProfiles(uint32_t active_flags, uint32_t inactive_flags); // Set the flag profiles for when the window is focused vs. unfocused.
SITAPI SituationError SituationApplyCurrentProfileWindowState(void);                    // Manually apply the appropriate window state profile based on current focus.
SITAPI SituationError SituationToggleWindowStateFlags(SituationWindowStateFlags flags_to_toggle); // Toggle flags in the current profile and apply the result.
SITAPI uint32_t SituationGetCurrentActualWindowStateFlags(void);                        // Gets flags based on current GLFW window state

//==================================================================================
// Image Module: CPU-side Image and Font Loading and Manipulation
//==================================================================================
// --- Image Loading and Unloading ---
SITAPI SituationImage SituationLoadImage(const char *fileName);                         // Load an image from a file into CPU memory (RAM).
SITAPI SituationImage SituationLoadImageFromMemory(const char *fileType, const unsigned char *fileData, int dataSize); // Load an image from a memory buffer.
SITAPI void SituationUnloadImage(SituationImage image);                                 // Unload an image's pixel data from memory.
SITAPI bool SituationIsImageValid(SituationImage image);                                // Check if an image has been loaded successfully.

// --- Image Exporting ---
SITAPI bool SituationExportImage(SituationImage image, const char *fileName);           // Export image data to a file (PNG, BMP supported).

// --- Image Generation & Copying ---
SITAPI SituationImage SituationImageCopy(SituationImage image);                         // Create a new image by copying another.
SITAPI void SituationImageDraw(SituationImage *dst, SituationImage src, Rectangle srcRect, Vector2 dstPos); // Copying portion of one image into another image at destination placement
SITAPI void SituationImageDrawAlpha(SituationImage *dst, SituationImage src, Rectangle srcRect, Vector2 dstPos, ColorRGBA tint);
SITAPI SituationImage SituationGenImageColor(int width, int height, ColorRGBA color);   // Generate a new image of a solid color.
SITAPI SituationImage SituationGenImageGradient(int width, int height, ColorRGBA tl, ColorRGBA tr, ColorRGBA bl, ColorRGBA br); // Generate a new image with a gradient.

// --- Image Manipulation (Modifies image in-place) ---
SITAPI void SituationImageCrop(SituationImage *image, Rectangle crop);                  // Crop an image to a specific rectangle.
SITAPI void SituationImageResize(SituationImage *image, int newWidth, int newHeight);   // Resize an image using default bicubic scaling.
SITAPI void SituationImageFlip(SituationImage *image, SituationImageFlipMode mode);     // Flip an image.
SITAPI void SituationImageAdjustHSV(SituationImage *image, float hue_shift, float sat_factor, float val_factor, float mix);   // Control an image by Hue Saturation and Brightness.

// --- Font Management ---
SITAPI SituationFont SituationLoadFont(const char *fileName);                           // Load a font from a TTF/OTF file for CPU rendering.
SITAPI void SituationUnloadFont(SituationFont font);                                    // Unload a CPU-side font and free its memory.
SITAPI Rectangle SituationMeasureText(SituationFont font, const char *text, float fontSize); // Measure the pixel dimensions of a string before drawing.
SITAPI void SituationImageDrawCodepoint(SituationImage *dst, SituationFont font, int codepoint, Vector2 position, float fontSize, float rotationDegrees, float skewFactor, ColorRGBA fillColor, ColorRGBA outlineColor, float outlineThickness); // Draw a single Unicode character with advanced styling onto an image.
SITAPI void SituationImageDrawText(SituationImage *dst, SituationFont font, const char *text, Vector2 position, float fontSize, float spacing, ColorRGBA tint ); // Draw a simple, tinted text string onto an image.
SITAPI void SituationImageDrawTextEx(SituationImage *dst, SituationFont font, const char *text, Vector2 position, float fontSize, float spacing, float rotationDegrees, float skewFactor, ColorRGBA fillColor, ColorRGBA outlineColor, float outlineThickness); // Draw a text string with advanced styling (rotation, outline) onto an image.

//==================================================================================
// Graphics Module: Rendering, Shaders, and GPU Resources
//==================================================================================
// --- Frame Lifecycle & Command Buffer ---
SITAPI bool SituationAcquireFrameCommandBuffer(void);                                   // Prepare the backend for a new frame of rendering commands.
SITAPI SituationCommandBuffer SituationGetMainCommandBuffer(void);                      // Get the primary command buffer for the current frame.
SITAPI SituationError SituationEndFrame(void);                                          // Submit all commands for the frame and present the result.

// --- Abstracted Rendering Commands ---
SITAPI SituationError SituationCmdBeginRenderToDisplay(SituationCommandBuffer cmd, int display_id, ColorRGBA clear_color);              // [DEPRECATED] Begins a render pass on a target (-1 for main window), clearing it.
SITAPI SituationError SituationCmdEndRender(SituationCommandBuffer cmd);                                                                // [DEPRECATED] End the current render pass.
SITAPI void SituationCmdSetViewport(SituationCommandBuffer cmd, float x, float y, float width, float height);                           // Sets the dynamic viewport and scissor for the current render pass.
SITAPI void SituationCmdSetScissor(SituationCommandBuffer cmd, int x, int y, int width, int height);                                    // Sets the dynamic scissor rectangle to clip rendering.
SITAPI SituationError SituationCmdBindPipeline(SituationCommandBuffer cmd, SituationShader shader);                                     // Binds a graphics pipeline (shader program) for subsequent draws.
SITAPI SituationError SituationCmdDrawMesh(SituationCommandBuffer cmd, SituationMesh mesh);                                             // [High-Level] Records a command to draw a complete, pre-configured mesh.
SITAPI void SituationCmdDrawQuad(SituationCommandBuffer cmd, mat4 model, vec4 color);                                                   // [High-Level] Record a command to draw a simple, colored 2D quad.
SITAPI void SituationCmdSetPushConstant(SituationCommandBuffer cmd, uint32_t contract_id, const void* data, size_t size);               // [Core] Set a small block of per-draw uniform data (push constant).
SITAPI SituationError SituationCmdBindDescriptorSet(SituationCommandBuffer cmd, uint32_t set_index, SituationBuffer buffer);            // [Core] Binds a buffer's descriptor set (UBO/SSBO) to a set index.
SITAPI SituationError SituationCmdBindTextureSet(SituationCommandBuffer cmd, uint32_t set_index, SituationTexture texture);             // [Core] Binds a texture's descriptor set (sampler/storage) to a set index.
SITAPI SituationError SituationCmdBindComputeTexture(SituationCommandBuffer cmd, uint32_t binding, SituationTexture texture);           // [Core] Binds a texture as a storage image for compute shaders.
SITAPI void SituationCmdSetVertexAttribute(SituationCommandBuffer cmd, uint32_t location, int size, SituationDataType type, bool normalized, size_t offset); // [Core] Define the format of a vertex attribute for the active VAO.
SITAPI void SituationCmdDraw(SituationCommandBuffer cmd, uint32_t vertex_count, uint32_t instance_count, uint32_t first_vertex, uint32_t first_instance); // [Core] Record a non-indexed draw call.
SITAPI void SituationCmdDrawIndexed(SituationCommandBuffer cmd, uint32_t index_count, uint32_t instance_count, uint32_t first_index, int32_t vertex_offset, uint32_t first_instance); // [Core] Record an indexed draw call.
SITAPI SituationError SituationCmdBeginRenderPass(SituationCommandBuffer cmd, const SituationRenderPassInfo* info);                     // Begins a render pass with detailed configuration.
SITAPI void SituationCmdEndRenderPass(SituationCommandBuffer cmd);                                                                      // Ends the current render pass.

// --- Graphics Resource Management ---
SITAPI SituationMesh SituationCreateMesh(const void* vertex_data, int vertex_count, size_t vertex_stride, const uint32_t* index_data, int index_count); // Create a mesh from vertex and index data.
SITAPI void SituationDestroyMesh(SituationMesh* mesh);                                  // Unload a mesh from GPU memory.

// --- Shader Management ---
SITAPI SituationShader SituationLoadShader(const char* vs_path, const char* fs_path);   // Load a graphics shader pipeline from vertex and fragment files.
SITAPI SituationShader SituationLoadShaderFromMemory(const char* vs_code, const char* fs_code); // Create a graphics shader pipeline from in-memory GLSL source.
SITAPI void SituationUnloadShader(SituationShader* shader);                             // Unload a graphics shader pipeline and free its GPU resources.

// --- Shader Interaction & Synchronization ---
SITAPI SituationError SituationSetShaderUniform(SituationShader shader, const char* uniform_name, const void* data, SituationUniformType type); // [OpenGL] Set a standalone uniform value by name (uses a cache).
SITAPI void SituationCmdPipelineBarrier(SituationCommandBuffer cmd, uint32_t src_flags, uint32_t dst_flags); // Insert a fine-grained pipeline barrier for synchronization.

// --- Texture Management ---
SITAPI SituationTexture SituationCreateTexture(SituationImage image, bool generate_mipmaps); // Create a texture from a CPU-side image.
SITAPI void SituationDestroyTexture(SituationTexture* texture);                         // Unload a texture from GPU memory.

// --- Compute Shader Pipeline ---
SITAPI SituationComputePipeline SituationCreateComputePipeline(const char* compute_shader_path, SituationComputeLayoutType layout_type); // Create a compute pipeline from a shader file.
SITAPI SituationComputePipeline SituationCreateComputePipelineFromMemory(const char* compute_shader_source, SituationComputeLayoutType layout_type); // Create a compute pipeline from in-memory GLSL source.
SITAPI void SituationDestroyComputePipeline(SituationComputePipeline* pipeline);        // Destroy a compute pipeline and free its GPU resources.
SITAPI void SituationCmdBindComputePipeline(SituationCommandBuffer cmd, SituationComputePipeline pipeline); // Bind a compute pipeline for a subsequent dispatch.
SITAPI void SituationCmdDispatch(SituationCommandBuffer cmd, uint32_t group_count_x, uint32_t group_count_y, uint32_t group_count_z); // Record a command to dispatch compute shader work groups.

// --- GPU Buffer Management ---
SITAPI SituationBuffer SituationCreateBuffer(size_t size, const void* initial_data, SituationBufferUsageFlags usage_flags); // Create a generic GPU data buffer (e.g., SSBO).
SITAPI void SituationDestroyBuffer(SituationBuffer* buffer);                            // Destroy a GPU buffer.
SITAPI SituationError SituationUpdateBuffer(SituationBuffer buffer, size_t offset, size_t size, const void* data); // Update data in a GPU buffer.
SITAPI SituationError SituationGetBufferData(SituationBuffer buffer, size_t offset, size_t size, void* out_data); // Read data from a GPU buffer.

// --- Virtual Displays (Render Targets) ---
SITAPI int SituationCreateVirtualDisplay(vec2 resolution, double frame_time_mult, int z_order, SituationScalingMode scaling_mode, SituationBlendMode blend_mode); // Create an off-screen render target.
SITAPI SituationError SituationDestroyVirtualDisplay(int display_id);                   // Destroy a virtual display.
SITAPI void SituationRenderVirtualDisplays(SituationCommandBuffer cmd);                 // Composite all visible virtual displays to the current target.
SITAPI SituationError SituationConfigureVirtualDisplay(int display_id, vec2 offset, float opacity, int z_order, bool visible, double frame_time_mult, SituationBlendMode blend_mode); // Configure a virtual display's properties.
SITAPI SituationVirtualDisplay* SituationGetVirtualDisplay(int display_id);             // Get a pointer to a virtual display's state.
SITAPI SituationError SituationSetVirtualDisplayScalingMode(int display_id, SituationScalingMode scaling_mode); // Set the scaling/filtering mode for a virtual display.
SITAPI void SituationSetVirtualDisplayDirty(int display_id, bool is_dirty);             // Mark a virtual display as needing to be re-rendered.
SITAPI bool SituationIsVirtualDisplayDirty(int display_id);                             // Check if a virtual display is marked as dirty.
SITAPI double SituationGetLastVDCompositeTimeMS(void);                                  // Get the time taken for the last virtual display composite pass.
SITAPI void SituationGetVirtualDisplaySize(int display_id, int* width, int* height);    // Get the internal resolution of a virtual display.

// --- 3D Model Utilities ---
SITAPI SituationModel SituationLoadModel(const char* file_path);                        // Loads a complete 3D model and its textures from a GLTF file.
SITAPI void SituationUnloadModel(SituationModel* model);                                // Frees all GPU and CPU resources associated with a loaded model.
SITAPI void SituationDrawModel(SituationCommandBuffer cmd, SituationModel model, mat4 transform); // Draws all sub-meshes of a model with a single root transformation.
SITAPI bool SituationSaveModelAsGltf(SituationModel model, const char* file_path);      // Exports a model to a human-readable .gltf and a .bin file for debugging.

// --- Image & Screenshot Utilities ---
SITAPI SituationImage SituationLoadImageFromScreen(void);                               // Get a copy of the current screen backbuffer as an image.
SITAPI bool SituationTakeScreenshot(const char *fileName);                              // Take a screenshot and save it to a file (PNG or BMP).

// --- Backend-Specific Accessors ---
SITAPI SituationRendererType SituationGetRendererType(void);                            // Get the current active renderer type (OpenGL or Vulkan).
SITAPI GLFWwindow* SituationGetGLFWwindow(void);                                        // Get the raw GLFW window handle.
#ifdef SITUATION_USE_VULKAN
SITAPI VkInstance SituationGetVulkanInstance(void);                                     // Get the raw Vulkan instance handle.
SITAPI VkDevice SituationGetVulkanDevice(void);                                         // Get the raw Vulkan logical device handle.
SITAPI VkPhysicalDevice SituationGetVulkanPhysicalDevice(void);                         // Get the raw Vulkan physical device handle.
SITAPI VkRenderPass SituationGetMainWindowRenderPass(void);                             // Get the render pass for the main window.
#endif

// --- [DEPRECATED] Use SituationCmdBindDescriptorSet() or SituationCmdBindTextureSet() instead. ---
SITAPI SituationError SituationCmdBindUniformBuffer(SituationCommandBuffer cmd, uint32_t contract_id, SituationBuffer buffer);          // [DEPRECATED] [Core] Bind a Uniform Buffer Object (UBO) to a shader binding point.
SITAPI SituationError SituationCmdBindTexture(SituationCommandBuffer cmd, uint32_t set_index, SituationTexture texture);                // [DEPRECATED] [Core] Bind a texture and sampler to a shader binding point.
SITAPI SituationError SituationCmdBindComputeBuffer(SituationCommandBuffer cmd, uint32_t binding, SituationBuffer buffer);              // [DEPRECATED] Bind a buffer to a compute shader binding point.
SITAPI SituationShader SituationLoadComputeShader(const char* cs_path);                                                                 // [DEPRECATED] Load a compute shader from a file. Use SituationCreateComputePipeline instead.
SITAPI SituationShader SituationLoadComputeShaderFromMemory(const char* cs_code);                                                       // [DEPRECATED] Create a compute shader from memory. Use SituationCreateComputePipelineFromMemory instead.
SITAPI void SituationMemoryBarrier(SituationCommandBuffer cmd, uint32_t barrier_bits);                                                  // [DEPRECATED] Insert a coarse-grained memory barrier. Use SituationCmdPipelineBarrier instead.

//==================================================================================
// Input Module: Keyboard, Mouse, and Gamepad
//==================================================================================
// --- Keyboard Input ---
SITAPI bool SituationIsKeyDown(int key);                                                // Check if a key is currently held down (a state).
SITAPI bool SituationIsKeyUp(int key);                                                  // Check if a key is currently up (a state).
SITAPI bool SituationIsKeyPressed(int key);                                             // Check if a key was pressed down this frame (an event).
SITAPI bool SituationIsKeyReleased(int key);                                            // Check if a key was released this frame (an event).
SITAPI int SituationGetKeyPressed(void);                                                // Get the next key from the press queue (no repeats).
SITAPI int SituationPeekKeyPressed(void);                                               // Peek at the next key in the press queue without consuming it.
SITAPI unsigned int SituationGetCharPressed(void);                                      // Get the next character from the text input queue.
SITAPI bool SituationIsLockKeyPressed(int lock_key_mod);                                // Check if a lock key (Caps, Num) is currently active.
SITAPI bool SituationIsScrollLockOn(void);                                              // Check if Scroll Lock is currently toggled on.
SITAPI bool SituationIsModifierPressed(int modifier);                                   // Check if a modifier key (Shift, Ctrl, Alt) is pressed.
SITAPI void SituationSetKeyCallback(SituationKeyCallback callback, void* user_data);    // Set a callback for key events.

// --- Mouse Input ---
SITAPI vec2 SituationGetMousePosition(void);                                            // Get the mouse position within the window.
SITAPI vec2 SituationGetMouseDelta(void);                                               // Get the mouse movement since the last frame.
SITAPI float SituationGetMouseWheelMove(void);                                          // Get vertical mouse wheel movement.
SITAPI vec2 SituationGetMouseWheelMoveV(void);                                          // Get vertical and horizontal mouse wheel movement.
SITAPI bool SituationIsMouseButtonDown(int button);                                     // Check if a mouse button is currently held down (a state).
SITAPI bool SituationIsMouseButtonPressed(int button);                                  // Check if a mouse button was pressed down this frame (an event).
SITAPI bool SituationIsMouseButtonReleased(int button);                                 // Check if a mouse button was released this frame.
SITAPI void SituationSetMousePosition(vec2 pos);                                        // Set the mouse position within the window.
SITAPI void SituationSetMouseOffset(vec2 offset);                                       // Set a software offset for the mouse position.
SITAPI void SituationSetMouseScale(vec2 scale);                                         // Set a software scale for the mouse position and delta.
SITAPI void SituationSetMouseButtonCallback(SituationMouseButtonCallback callback, void* user_data); // Set a callback for mouse button events.
SITAPI void SituationSetCursorPosCallback(SituationCursorPosCallback callback, void* user_data); // Set a callback for mouse movement events.
SITAPI void SituationSetScrollCallback(SituationScrollCallback callback, void* user_data); // Set a callback for mouse scroll events.

// --- Gamepad Input ---
SITAPI bool SituationIsJoystickPresent(int jid);                                        // Check if a joystick/gamepad is connected.
SITAPI bool SituationIsGamepad(int jid);                                                // Check if a connected joystick has a standard gamepad mapping.
SITAPI const char* SituationGetJoystickName(int jid);                                   // Get the human-readable name of a joystick/gamepad.
SITAPI void SituationSetJoystickCallback(SituationJoystickCallback callback, void* user_data); // Set a callback for joystick connection events.
SITAPI int SituationSetGamepadMappings(const char *mappings);                           // Load a new set of gamepad mappings from a string.
SITAPI int SituationGetGamepadButtonPressed(void);                                      // Get the next gamepad button from the press queue.
SITAPI bool SituationIsGamepadButtonDown(int jid, int button);                          // Check if a gamepad button is currently held down (a state).
SITAPI bool SituationIsGamepadButtonPressed(int jid, int button);                       // Check if a gamepad button was pressed down this frame (an event).
SITAPI bool SituationIsGamepadButtonReleased(int jid, int button);                      // Check if a gamepad button was released this frame (an event).
SITAPI int SituationGetGamepadAxisCount(int jid);                                       // Get the number of axes for a gamepad.
SITAPI float SituationGetGamepadAxisValue(int jid, int axis);                           // Get the value of a gamepad axis (deadzone applied).
SITAPI void SituationSetGamepadVibration(int jid, float left_motor, float right_motor); // Set gamepad vibration/rumble (Windows only).

//==================================================================================
// Audio Module
//==================================================================================

// --- Audio Device Management ---
SITAPI SituationAudioDeviceInfo* SituationGetAudioDevices(int* count);                  // Get a list of available audio playback devices (caller must free).
SITAPI SituationError SituationSetAudioDevice(int internal_id, const SituationAudioFormat* format); // Set the active audio device.
SITAPI int SituationGetAudioPlaybackSampleRate(void);                                   // Get the sample rate of the current audio device.
SITAPI SituationError SituationSetAudioPlaybackSampleRate(int sample_rate);             // Re-initialize the audio device with a new sample rate.
SITAPI float SituationGetAudioMasterVolume(void);                                       // Get the master volume for the audio device.
SITAPI SituationError SituationSetAudioMasterVolume(float volume);                      // Set the master volume for the audio device.
SITAPI bool SituationIsAudioDevicePlaying(void);                                        // Check if the audio device is currently playing.
SITAPI SituationError SituationPauseAudioDevice(void);                                  // Pause audio playback on the device.
SITAPI SituationError SituationResumeAudioDevice(void);                                 // Resume audio playback on the device.

// --- Sound Loading and Management ---
SITAPI SituationError SituationLoadSoundFromFile(const char* file_path, bool looping, SituationSound* out_sound); // Load a sound from a file.
SITAPI SituationError SituationLoadSoundFromStream(SituationStreamReadCallback on_read, SituationStreamSeekCallback on_seek, void* user_data, const SituationAudioFormat* format, bool looping, SituationSound* out_sound); // Load a sound from a custom stream.
SITAPI void SituationUnloadSound(SituationSound* sound);                                // Unload a sound and free its resources.
SITAPI SituationError SituationPlayLoadedSound(SituationSound* sound);                  // Play a loaded sound (restarts if already playing).
SITAPI SituationError SituationStopLoadedSound(SituationSound* sound);                  // Stop a specific sound from playing.
SITAPI SituationError SituationStopAllLoadedSounds(void);                               // Stop all currently playing sounds.

// --- Sound Data Manipulation (Wave Utilities) ---
SITAPI SituationError SituationSoundCopy(const SituationSound* source, SituationSound* out_destination);    // Create a new sound by copying the raw PCM data from a source.
SITAPI SituationError SituationSoundCrop(SituationSound* sound, uint64_t initFrame, uint64_t finalFrame);   // Crop a sound's PCM data in-place to a new range.
SITAPI bool SituationSoundExportAsWav(const SituationSound* sound, const char* fileName);                   // Export the sound's raw PCM data to a WAV file.

// --- Sound Parameters and Effects ---
SITAPI SituationError SituationSetSoundVolume(SituationSound* sound, float volume);     // Set the volume for a specific sound.
SITAPI float SituationGetSoundVolume(SituationSound* sound);                            // Get the volume of a specific sound.
SITAPI SituationError SituationSetSoundPan(SituationSound* sound, float pan);           // Set the stereo pan for a sound [-1.0 to 1.0].
SITAPI float SituationGetSoundPan(SituationSound* sound);                               // Get the stereo pan of a sound.
SITAPI SituationError SituationSetSoundPitch(SituationSound* sound, float pitch);       // Set the pitch for a sound (resamples).
SITAPI float SituationGetSoundPitch(SituationSound* sound);                             // Get the pitch of a sound.
SITAPI SituationError SituationSetSoundFilter(SituationSound* sound, SituationFilterType type, float cutoff_hz, float q_factor);                    // Apply a low-pass or high-pass filter to a sound.
SITAPI SituationError SituationSetSoundEcho(SituationSound* sound, bool enabled, float delay_sec, float feedback, float wet_mix);                   // Apply an echo effect to a sound.
SITAPI SituationError SituationSetSoundReverb(SituationSound* sound, bool enabled, float room_size, float damping, float wet_mix, float dry_mix);   // Apply a reverb effect to a sound.

// --- Custom Audio Processing ---
SITAPI SituationError SituationAttachAudioProcessor(SituationSound* sound, SituationAudioProcessorCallback processor, void* userData); // Attach a custom DSP processor to a sound's effect chain.
SITAPI SituationError SituationDetachAudioProcessor(SituationSound* sound, SituationAudioProcessorCallback processor, void* userData); // Detach a custom DSP processor from a sound.

//==================================================================================
// Filesystem Module
//==================================================================================
// --- Path Management & Special Directories ---
SITAPI char* SituationGetAppSavePath(const char* app_name);                             // Get a safe, persistent path for saving application data (caller must free).
SITAPI char* SituationGetBasePath(void);                                                // Get the path to the directory containing the executable (caller must free).
SITAPI char* SituationJoinPath(const char* base_path, const char* file_or_dir_name);    // Join two path components with the correct OS separator (caller must free).
SITAPI const char* SituationGetFileName(const char* full_path);                         // Extract the file name (including extension) from a full path.
SITAPI const char* SituationGetFileExtension(const char* file_path);                    // Extract the file extension from a path.

// --- File & Directory Queries ---
SITAPI bool SituationFileExists(const char* file_path);                                 // Check if a file exists at the given path.
SITAPI bool SituationDirectoryExists(const char* dir_path);                             // Check if a directory exists at the given path.
SITAPI long SituationGetFileModTime(const char* file_path);                             // Get the last modification time of a file (Unix timestamp).

// --- File Operations ---
SITAPI unsigned char* SituationLoadFileData(const char* file_path, unsigned int* out_bytes_read);           // Load an entire file into a memory buffer (caller must free).
SITAPI bool SituationSaveFileData(const char* file_path, const void* data, unsigned int bytes_to_write);    // Save a block of memory to a file.
SITAPI char* SituationLoadFileText(const char* file_path);                                                  // Load a text file into a null-terminated string (caller must free).
SITAPI bool SituationSaveFileText(const char* file_path, const char* text);                                 // Save a null-terminated string to a text file.
SITAPI bool SituationCopyFile(const char* source_path, const char* dest_path);                              // Copy a file.
SITAPI bool SituationDeleteFile(const char* file_path);                                                     // Delete a file.
SITAPI bool SituationMoveFile(const char* old_path, const char* new_path);                                  // Move/rename a file, even across drives on Windows.
SITAPI bool SituationRenameFile(const char* old_path, const char* new_path);                                // Alias for SituationMoveFile.

// --- Directory Operations ---
SITAPI bool SituationCreateDirectory(const char* dir_path, bool create_parents);        // Create a directory, optionally creating parent directories.
SITAPI bool SituationDeleteDirectory(const char* dir_path, bool recursive);             // Delete a directory, optionally deleting all its contents.
SITAPI char** SituationListDirectoryFiles(const char* dir_path, int* out_count);        // List files and subdirectories in a path (caller must free with SituationFreeDirectoryFileList).
SITAPI void SituationFreeDirectoryFileList(char** file_list, int count);                // Free the memory allocated by SituationListDirectoryFiles.

//==================================================================================
// Miscellaneous Module
//==================================================================================
// --- Temporal Oscillator System ---
SITAPI bool SituationTimerGetOscillatorState(int oscillator_id);                        // Get the current binary state (0 or 1) of an oscillator.
SITAPI bool SituationTimerGetPreviousOscillatorState(int oscillator_id);                // Get the previous frame's state of an oscillator.
SITAPI bool SituationTimerHasOscillatorUpdated(int oscillator_id);                      // Check if an oscillator's state has changed this frame.
SITAPI bool SituationTimerPingOscillator(int oscillator_id);                            // Check if an oscillator's period has elapsed since the last ping.
SITAPI uint64_t SituationTimerGetOscillatorTriggerCount(int oscillator_id);             // Get the total number of times an oscillator has triggered.
SITAPI double SituationTimerGetOscillatorPeriod(int oscillator_id);                     // Get the period of an oscillator in seconds.
SITAPI SituationError SituationSetTimerOscillatorPeriod(int oscillator_id, double period_seconds); // Set the period of an oscillator.
SITAPI double SituationTimerGetPingProgress(int oscillator_id);                         // Get progress [0.0 to 1.0+] of the interval since the last successful ping.
SITAPI double SituationTimerGetTime(void);                                              // Get the total time elapsed since initialization.

// --- Color Space Conversions ---
SITAPI void SituationConvertColorToVec4(ColorRGBA c, vec4 out_normalized_color);        // Convert an 8-bit ColorRGBA struct to a normalized vec4.
SITAPI ColorHSV SituationRgbToHsv(ColorRGBA rgb);                                       // Converts a standard RGBA color to the Hue, Saturation, Value color space.
SITAPI ColorRGBA SituationHsvToRgb(ColorHSV hsv);                                       // Converts a Hue, Saturation, Value color back to the standard RGBA color space.
SITAPI ColorYPQA SituationColorToYPQ(ColorRGBA color);                                  // Converts a standard RGBA color to the YPQA (Luma, Phase, Quadrature) color space.
SITAPI ColorRGBA SituationColorFromYPQ(ColorYPQA ypq_color);                            // Converts a YPQA color back to the standard RGBA color space.

SITAPI void SituationFreeString(char* str);
SITAPI void SituationFreeDisplays(SituationDisplayInfo* displays, int count);

//----------------------------------------------------------------------------------
// --- Implementation ---
//----------------------------------------------------------------------------------
#ifdef SITUATION_IMPLEMENTATION

#define MINIAUDIO_IMPLEMENTATION
#include <miniaudio.h>

#if defined(_WIN32)
    #pragma comment(lib, "xinput.lib") // Implementation-specific pragma
#endif

// This ensures GLAD is compiled only when SITUATION_IMPLEMENTATION is defined, preventing duplicate symbol errors.
#if defined(SITUATION_USE_OPENGL)
#include <glad.c>
#endif

#if defined(SITUATION_USE_VULKAN)
// It is highly recommended to use the Vulkan Memory Allocator for production code.
// Download the "vk_mem_alloc.h" file from the official repository and place it in your project.
#define VMA_IMPLEMENTATION
#include <vk_mem_alloc.h>
#endif

// Check if the user has included the stb_image_write implementation
#if defined(STB_IMAGE_WRITE_IMPLEMENTATION)
    // If so, we can use the stbi_write_... functions
#else
    // If not, we need to define the stb function prototypes ourselves so we can check for them.
    // This avoids a compile error if the user just includes the header without the implementation.
    #ifdef __cplusplus
    extern "C" {
    #endif
    extern int stbi_write_png(char const *filename, int w, int h, int comp, const void *data, int stride_in_bytes);
    #ifdef __cplusplus
    }
    #endif
#endif

// Check for stb_image and stb_image_resize implementations
#if defined(STB_IMAGE_IMPLEMENTATION)
    // The user has included stb_image.h correctly.
#else
    // Define dummy prototypes so we can check for their existence without compile errors.
    #ifdef __cplusplus
    extern "C" {
    #endif
    extern unsigned char *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp);
    extern unsigned char *stbi_load_from_memory(unsigned char const *buffer, int len, int *x, int *y, int *comp, int req_comp);
    extern void stbi_free(void *retval_from_stbi_load);
    #ifdef __cplusplus
    }
    #endif
#endif

#if defined(STB_IMAGE_RESIZE_IMPLEMENTATION)
    // The user has included stb_image_resize.h correctly.
#else
    #ifdef __cplusplus
    extern "C" {
    #endif
    // Define the pixel layout enum just enough for the prototype to work.
    typedef enum stbir_pixel_layout {
        STBIR_RGBA = 4
    } stbir_pixel_layout;

    extern unsigned char * stbir_resize_uint8_srgb( const unsigned char *input_pixels , int input_w , int input_h, int input_stride_in_bytes,
                                                    unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                                    stbir_pixel_layout pixel_type );
    #ifdef __cplusplus
    }
    #endif
#endif

// --- Internal Hash Map for OpenGL Uniform Caching ---
#define SIT_UNIFORM_MAP_INITIAL_CAPACITY 16

// A single entry in the hash map
typedef struct _SituationUniformMapEntry {
    char* key;          // Uniform name
    GLint value;        // Uniform location
    struct _SituationUniformMapEntry* next; // For handling hash collisions
} _SituationUniformMapEntry;

// The hash map itself
typedef struct _SituationUniformMap {
    _SituationUniformMapEntry** buckets;
    int capacity;
    int count;
} _SituationUniformMap;

typedef struct _SituationComputePipeline {
    uint32_t id; // Public facing ID
#if defined(SITUATION_USE_VULKAN)
    VkPipeline vk_pipeline;
    VkPipelineLayout vk_pipeline_layout;
    // --- NEW: Persistent Descriptor Set for this pipeline's layout ---
    // This is useful if the pipeline layout itself needs a descriptor set bound (e.g., for resources specific to the pipeline, not push constants).
    // If the pipeline layout is only for push constants, this might not be needed. Let's assume for now it's needed for general resource binding associated with the pipeline.
    // However, typically, resources like SSBOs/UBOs are bound per-draw/dispatch using their own sets.
    // Binding the pipeline's *layout* itself doesn't usually require a descriptor set.
    // Let's re-evaluate. The pipeline layout defines the interface. Descriptor sets are bound *to* that interface.
    // So, the pipeline layout itself doesn't need a descriptor set.
    // But, if the pipeline uses descriptor sets (which it does), and we want to pre-allocate sets for *those bindings* (like SSBOs/UBOs used by shaders in this pipeline),
    // those sets are owned by the *resources* (SituationBuffer), not the pipeline.
    // The pipeline just defines the layout that those resource sets must conform to.
    // Therefore, SituationComputePipeline likely does NOT need its own descriptor_set member for this fix.
    // The fix is for buffers/images that are *used by* the pipeline.
    // The pipeline layout is used in vkCmdBindDescriptorSets to specify *which* layout the bound sets conform to.
    // Conclusion: No change needed for SituationComputePipeline struct for this specific buffer binding performance fix.
    // The fix is in SituationBuffer and how it's used in binding calls.
#endif
    VkShaderModule shader_module; // Keep module handle for cleanup (baked into pipeline, but good practice to track)
    // Add fields for descriptor set layouts, reflection info if needed for more complex systems
} _SituationComputePipeline;

// --- Internal Resource Tracking Node Definitions ---
typedef struct _SituationMeshNode {
    SituationMesh mesh;
    struct _SituationMeshNode* next;
} _SituationMeshNode;

typedef struct _SituationShaderNode {
    SituationShader shader;
    struct _SituationShaderNode* next;
} _SituationShaderNode;

typedef struct _SituationComputePipelineNode {
    SituationComputePipeline pipeline;
    struct _SituationComputePipelineNode* next;
} _SituationComputePipelineNode;

typedef struct _SituationTextureNode {
    SituationTexture texture;
    struct _SituationTextureNode* next;
} _SituationTextureNode;

typedef struct _SituationBufferNode {
    SituationBuffer buffer;
    struct _SituationBufferNode* next;
} _SituationBufferNode;

// --- Internal Joystick State Structure ---
typedef struct {
    bool is_present;
    bool is_gamepad;
    char name[SITUATION_MAX_DEVICE_NAME_LEN];
    
    // Gamepad-specific state
    unsigned char current_button_state[SITUATION_MAX_JOYSTICK_BUTTONS]; // GLFW_PRESS or GLFW_RELEASE
    unsigned char last_button_state[SITUATION_MAX_JOYSTICK_BUTTONS];
    float axis_state[SITUATION_MAX_JOYSTICK_AXES];
    int axis_count;

} _SituationJoystickState;

typedef struct {
    int jid;
    int event; // GLFW_CONNECTED or GLFW_DISCONNECTED
} _SituationJoystickEvent;

#if defined(SITUATION_USE_VULKAN)
// --- VULKAN IMPLEMENTATION SECTION ---

// Internal Vulkan State Structures
typedef struct {
    VkInstance instance;
    VkDebugUtilsMessengerEXT debug_messenger;
    VkSurfaceKHR surface;

    VkPhysicalDevice physical_device;
    VkDevice device;
    VmaAllocator vma_allocator;

    VkQueue graphics_queue;
    VkQueue present_queue;
    uint32_t graphics_family_index;
    uint32_t present_family_index;

    VkSwapchainKHR swapchain;
    VkFormat swapchain_image_format;
    VkExtent2D swapchain_extent;
    VkImage* swapchain_images;
    VkImageView* swapchain_image_views;
    uint32_t swapchain_image_count;

    VkCommandPool command_pool;
    uint32_t max_frames_in_flight;
    VkCommandBuffer* command_buffers;
    VkSemaphore* image_available_semaphores;
    VkSemaphore* render_finished_semaphores;
    VkFence* in_flight_fences;
    uint32_t current_frame_index;
    uint32_t current_image_index;
    uint32_t last_presented_image_index; 
    bool framebuffer_resized;

    VkImage depth_image;
    VmaAllocation depth_image_memory;
    VkImageView depth_image_view;
    VkFormat depth_format;
    VkDescriptorPool persistent_descriptor_pool;    // Pool for long-lived sets
    VkDescriptorSetLayout ubo_layout;               // Layout for a single UBO
    VkDescriptorSetLayout ssbo_layout;              // Layout for a single SSBO
    VkDescriptorPool descriptor_pool;               // A main pool to allocate sets from
    VkDescriptorSetLayout view_data_ubo_layout;     // Layout for the UBO
    VkDescriptorSetLayout image_sampler_layout;     // Layout for a single image sampler
    VkDescriptorSetLayout storage_buffer_layout;    // For binding a single SSBO
    VkPipelineLayout current_pipeline_layout_for_push_constants; // Cache the layout of the currently bound pipeline
    VkPipelineLayout current_compute_pipeline_layout;
    VkPipelineLayout compute_layouts[5]; // Array to hold pre-created layouts, size matches enum

    // --- Quad Renderer Resources ---
    VkPipeline quad_pipeline;
    VkPipelineLayout quad_pipeline_layout;
    VkBuffer quad_vertex_buffer;
    VmaAllocation quad_vertex_buffer_memory;

    // --- VD Compositor Resources ---
    VkPipeline vd_compositing_pipeline;
    VkPipelineLayout vd_compositing_pipeline_layout;
    VkPipeline advanced_compositing_pipeline;
    VkPipelineLayout advanced_compositing_pipeline_layout;

    // UBO for projection matrix for 2D renderers
    VkBuffer* view_proj_ubo_buffer;
    VmaAllocation* view_proj_ubo_memory;
    VkDescriptorSet* view_proj_ubo_descriptor_set;

    VkRenderPass main_window_render_pass;
    VkFramebuffer* main_window_framebuffers;
    
} _SituationVulkanState;

#endif // SITUATION_USE_VULKAN

// --- Static Global State ---
typedef struct {
    char last_error_msg[SITUATION_MAX_ERROR_MSG_LEN];
    ma_mutex error_mutex; // MUTEX
    bool is_initialized;
    bool is_com_initialized; // For Windows-specific features
    
    bool current_window_focus_state;
    bool was_minimized_last_frame; // For minimize-based pause/resume
    bool is_app_internally_paused;
    bool was_window_resized_last_frame;
    int windowed_x, windowed_y, windowed_w, windowed_h;
    bool is_borderless_active;
    SituationFocusCallback focus_callback_fn;
    void* focus_callback_user_ptr;
    uint32_t active_profile_window_flags;
    uint32_t inactive_profile_window_flags;

    // --- File Drop Callback ---
    SituationFileDropCallback file_drop_callback;
    void* file_drop_user_data;
    
    SituationDisplayInfo* cached_physical_displays_array;
    int cached_physical_display_count;
    
    SituationVirtualDisplay virtual_display_slots[SITUATION_MAX_VIRTUAL_DISPLAYS];
    int active_virtual_display_count;
    bool virtual_display_slots_used[SITUATION_MAX_VIRTUAL_DISPLAYS];
    
    int main_window_width; // Store for viewport restoration, etc.
    int main_window_height;
    GLFWwindow* sit_glfw_window;

    SituationRendererType renderer_type;

    // Backend-specific state
#if defined(SITUATION_USE_VULKAN)
    _SituationVulkanState vk;
#elif defined(SITUATION_USE_OPENGL)
    // VD Rendering Shader and Quad
    GLuint vd_shader_program_id;
    GLuint vd_quad_vao;
    GLuint vd_quad_vbo;
    mat4 vd_ortho_projection; // Store precomputed ortho matrix for main window
    double last_vd_composite_time_ms; // Profiling info

    // ADVANCED COMPOSITING
    GLuint composite_shader_program_id;
    GLuint composite_copy_texture_id;

    GLuint view_data_ubo_id;
    
    // The "Public" VAO for all user-driven rendering commands.
    // This VAO is bound after initialization and remains bound during the user's render loop.
    GLuint global_vao_id;
    
    // Quad renderer state
    GLuint quad_shader_program;
    GLuint quad_vao;
    GLuint quad_vbo;
    GLuint current_gl_program_id; // Cache the currently bound program
#endif
    
    ma_context sit_miniaudio_context;
    ma_device sit_miniaudio_device;
    bool is_sit_miniaudio_context_initialized;
    bool is_sit_miniaudio_device_active;
    bool is_sit_miniaudio_device_internally_paused;
    int current_sit_miniaudio_device_sitaudioinfo_id;
    
    SituationSound* sit_queued_sounds[SITUATION_MAX_AUDIO_SOUNDS_QUEUED];
    int sit_queued_sound_count;
    ma_mutex sit_audio_queue_mutex;
    
    SituationTimerSystem timer_system_instance;
    
    float* sit_audio_callback_decoder_temp_buffer;
    float* sit_audio_callback_effects_temp_buffer;
    float* sit_audio_callback_converter_temp_buffer;
    uint32_t sit_audio_callback_temp_buffer_frames_capacity;
    
    struct {
        bool current_state[GLFW_KEY_LAST + 1];    // Current key state (pressed=true)
        bool last_state[GLFW_KEY_LAST + 1];       // Previous frame’s state
        bool down_this_frame[GLFW_KEY_LAST + 1];  // Pressed this frame
        bool up_this_frame[GLFW_KEY_LAST + 1];    // Released this frame
        int pressed_queue[SITUATION_KEY_QUEUE_MAX]; // Queue of keys pressed this frame
        int pressed_queue_count;
        unsigned int char_queue[SITUATION_CHAR_QUEUE_MAX]; // Queue of characters input
        int char_queue_count;
        int modifier_state;                       // Current modifier flags (GLFW_MOD_*)
        int lock_key_state;                       // Current lock key flags (Caps, Num)
        bool is_scroll_lock_on;                   // Track the toggle state of Scroll Lock
        SituationKeyCallback key_callback;        // Optional user callback
        void* key_callback_user_data;
    } keyboard;
    
    ma_mutex sit_keyboard_event_queue_mutex;
    
    struct {
        vec2 current_pos;
        vec2 last_pos;
        vec2 offset; // For SetMouseOffset
        vec2 scale;  // For SetMouseScale
        float wheel_move_y;
        float wheel_move_x; 
        
        bool current_button_state[GLFW_MOUSE_BUTTON_LAST + 1];
        bool last_button_state[GLFW_MOUSE_BUTTON_LAST + 1]; 
        bool button_down_this_frame[GLFW_MOUSE_BUTTON_LAST + 1]; 
        bool button_up_this_frame[GLFW_MOUSE_BUTTON_LAST + 1];
        int button_queue[SITUATION_KEY_QUEUE_MAX];
        int button_queue_count;
        
        SituationMouseButtonCallback button_callback;
        void* button_callback_user_data;
        SituationCursorPosCallback cursor_pos_callback;
        void* cursor_pos_callback_user_data;
        SituationScrollCallback scroll_callback;
        void* scroll_callback_user_data;
        ma_mutex mutex;
    } mouse;
    
    // --- Cursor Management ---
    GLFWcursor* cursors[16]; // Array to hold standard cursor handles
    int cursor_count;        // Number of cursors created
    
    // --- Joystick State ---
    struct {
        _SituationJoystickState state[SITUATION_MAX_JOYSTICKS];
        SituationJoystickCallback callback;
        void* callback_user_data; 
        // --- for thread-safe event queuing ---
        _SituationJoystickEvent event_queue[SITUATION_MAX_JOYSTICKS]; // Small queue
        int event_queue_count;
        int button_pressed_queue[SITUATION_KEY_QUEUE_MAX]; // Reuse key queue size for this
        int button_pressed_queue_count;
        ma_mutex event_queue_mutex;

    } joysticks;

    // --- Frame Timing & FPS Management State ---
    double current_time;            // Time at the beginning of the current frame
    double previous_time;           // Time at the beginning of the previous frame
    double frame_time;              // Time difference between current and previous frame (deltaTime)
    double target_frame_time;       // The desired time per frame (1.0 / target_fps)
    int    fps_frame_counter;       // Counts frames for FPS calculation
    double fps_last_update_time;    // Last time the FPS was calculated
    int    current_fps;             // The calculated FPS value

    // --- Application Callbacks ---
    void (*exit_callback)(void*);
    void* exit_callback_user_data;
    void (*resize_callback)(int, int, void*);
    void* resize_callback_user_data;

    // --- Command-Line Arguments ---
    int    argc;
    char** argv;
    
    // --- File Drop State ---
    char** dropped_file_paths;
    int    dropped_file_count;
    bool   file_was_dropped_this_frame;

    // --- Internal Resource Tracking Heads ---
    _SituationMeshNode* all_meshes;
    _SituationShaderNode* all_shaders;
    _SituationComputePipelineNode* all_compute_pipelines;
    _SituationTextureNode* all_textures;
    _SituationBufferNode* all_buffers;
    
} _SituationGlobalStateContainer;

static _SituationGlobalStateContainer sit_gs;


//----------------------------------------------------------------------------------
// --- Forward Declarations for Static Helper Functions ---
//----------------------------------------------------------------------------------

//==================================================================================
// Core Lifecycle & Error Handling Helpers
//==================================================================================
static void _SituationSetError(const char* msg);                                                // [CORE] Sets the global last error message string.
static void _SituationSetErrorFromCode(SituationError err, const char* detail);                 // [CORE] Sets the global error message from an error code and detail string.
static SituationError _SituationInitPlatform(void);                                             // [INIT] Initializes platform-specific dependencies (GLFW, COM).
static SituationError _SituationInitWindow(const SituationInitInfo* init_info);                 // [INIT] Creates the main application window using GLFW.
static SituationError _SituationInitRenderer(const SituationInitInfo* init_info);               // [INIT] Dispatches to the backend-specific graphics initializer (GL/VK).
static SituationError _SituationInitSubsystems(void);                                           // [INIT] Initializes all non-rendering subsystems (Audio, Input, Timers).
static void _SituationCleanupDanglingResources(void);                                           // [CLEANUP] Finds and frees any user-leaked resources at shutdown.
static void _SituationCleanupPlatform(void);                                                    // [CLEANUP] Shuts down the platform layer (GLFW, COM).
static void _SituationCleanupRenderer(void);                                                    // [CLEANUP] Dispatches to the backend-specific graphics cleanup.
static void _SituationCleanupSubsystems(void);                                                  // [CLEANUP] Shuts down all non-rendering subsystems.
static void _SituationFullCleanupOnError(void);                                                 // [CLEANUP] Performs a full, robust cleanup after an initialization failure.

//==================================================================================
// GLFW Callback Helpers
//==================================================================================
static void _SituationGLFWErrorCallback(int error, const char* description);                    // [CALLBACK] Handles internal errors reported by GLFW.
static void _SituationGLFWFileDropCallback(GLFWwindow* window, int count, const char** paths);  // [CALLBACK] Handles files being dropped onto the window.
static void _SituationGLFWWindowFocusCallback(GLFWwindow* window, int focused);                 // [CALLBACK] Handles the window gaining or losing input focus.
static void _SituationGLFWWindowIconifyCallback(GLFWwindow* window, int iconified);             // [CALLBACK] Handles the window being minimized or restored.
static void _SituationGLFWFramebufferSizeCallback(GLFWwindow* window, int width, int height);   // [CALLBACK] Handles changes to the framebuffer's pixel dimensions.
static void _SituationGLFWKeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods); // [CALLBACK] Handles all raw keyboard key events.
static void _SituationGLFWCharCallback(GLFWwindow* window, unsigned int codepoint);             // [CALLBACK] Handles Unicode character input for text entry.
static void _SituationGLFWMouseButtonCallback(GLFWwindow* window, int button, int action, int mods); // [CALLBACK] Handles mouse button press and release events.
static void _SituationGLFWCursorPosCallback(GLFWwindow* window, double xpos, double ypos);      // [CALLBACK] Handles mouse cursor movement events.
static void _SituationGLFWScrollCallback(GLFWwindow* window, double xoffset, double yoffset);   // [CALLBACK] Handles mouse scroll wheel events.
static void _SituationGLFWJoystickCallback(int jid, int event);                                 // [CALLBACK] Handles joystick connection and disconnection events.

//==================================================================================
// Shader Contract
//==================================================================================
#define SIT_STRINGIFY(x) #x
/**
 * @section Shader Contract
 * @brief Defines the standard resource binding locations for all shaders used with this library.
 * @details To ensure that the engine can correctly and consistently bind resources (vertex data, uniforms, textures) to any shader, all GLSL shaders must adhere to this predefined contract.
 *          The contract uses a unified set of constants that map to the appropriate backend-specific syntax (`layout(location=...)` for OpenGL attributes, `layout(set=..., binding=...)` for Vulkan resources, etc.).
 *
 * @par Vulkan Descriptor Set Layout
 *   In Vulkan, resources are organized into Descriptor Sets. This contract defines a standard layout:
 *   - **Set 0: Per-View/Frame Resources:** Contains UBOs with data that is updated once per frame or per camera (e.g., projection matrix, time).
 *   - **Set 1: Per-Material Resources:** Contains samplers for material-specific textures (e.g., albedo, normal maps).
 *   - **Set 2+: Per-Object/Dynamic Resources:** Reserved for more dynamic, per-draw-call resources if needed.
 *   - **Push Constants:** Used for small, extremely high-frequency data (e.g., model matrix, object color), passed without a descriptor set.
 */
// --- Category 1: Vertex Attributes ---
// Mapped to `layout(location = N) in ...;` in both OpenGL and Vulkan.
#define SIT_ATTR_POSITION                   0 // vec3: Vertex position (xyz)
#define SIT_ATTR_NORMAL                     1 // vec3: Vertex normal (xyz)
#define SIT_ATTR_TEXCOORD_0                 2 // Vector2: Primary texture coordinates (uv)
#define SIT_ATTR_COLOR                      3 // vec4: Vertex color (rgba)
#define SIT_ATTR_TANGENT                    4 // vec4: Vertex tangent for normal mapping (xyz + handedness w)
#define SIT_ATTR_TEXCOORD_1                 5 // Vector2: Secondary texture coordinates (e.g., for lightmaps)

// --- Category 2: Per-View/Frame Resources (Vulkan Descriptor Set 0) ---
// Mapped to `layout(std140, set = 0, binding = N) uniform ...` in Vulkan.
// Mapped to `layout(std140, binding = N) uniform ...` in OpenGL.
#define SIT_UBO_BINDING_FRAME_DATA          0 // Contains per-frame data (Time, Screen Resolution, etc.)
#define SIT_UBO_BINDING_VIEW_DATA           1 // Contains per-camera data (View/Projection matrices)
#define SIT_UBO_BINDING_LIGHTING            2 // Contains scene lighting information
#define SIT_UBO_BINDING_SKINNING            3 // Contains bone matrices for skeletal animation

// --- Category 3: Per-Material Resources (Vulkan Descriptor Set 1) ---
// Mapped to `layout(set = 1, binding = N) uniform sampler...` in Vulkan.
// Mapped to `layout(binding = N) uniform sampler...` in OpenGL.
#define SIT_SAMPLER_BINDING_ALBEDO          0 // sampler2D: Base ColorRGBA / Diffuse Map (sRGB)
#define SIT_SAMPLER_BINDING_NORMAL          1 // sampler2D: Normal Map (Linear)
#define SIT_SAMPLER_BINDING_PBR_MAP         2 // sampler2D: Packed PBR Map (e.g., R=Metallic, G=Roughness, B=AO) (Linear)
#define SIT_SAMPLER_BINDING_EMISSIVE        3 // sampler2D: Emissive/Glow Map (sRGB)
#define SIT_SAMPLER_BINDING_SOURCE_0        4 // sampler2D: Primary generic source texture (e.g., a Virtual Display)
#define SIT_SAMPLER_BINDING_SOURCE_1        5 // sampler2D: Secondary generic source texture (e.g., framebuffer copy)
#define SIT_SAMPLER_BINDING_DEPTH           6 // sampler2D: Depth buffer texture for post-processing effects.
#define SIT_SAMPLER_BINDING_SHADOWMAP       7 // sampler2DShadow: Shadow map from a light source.

// Aliases for Virtual Display compositing shaders for clarity
#define SIT_SAMPLER_BINDING_VD_SOURCE       SIT_SAMPLER_BINDING_SOURCE_0
#define SIT_SAMPLER_BINDING_VD_DEST         SIT_SAMPLER_BINDING_SOURCE_1

// --- Category 4: OpenGL-Specific Standalone Uniforms ---
// These are primarily for the OpenGL backend, where they are more common and efficient
// than creating single-purpose UBOs. In Vulkan, this data is passed via Push Constants.
// Mapped to `layout(location = N) uniform ...;` in OpenGL.
#define SIT_UNIFORM_LOC_MODEL_MATRIX        0 // mat4: The object-to-world transformation matrix.
#define SIT_UNIFORM_LOC_OBJECT_COLOR        1 // vec4: A general-purpose color tint for the object.
#define SIT_UNIFORM_LOC_OPACITY             2 // float: A general-purpose opacity/alpha multiplier.
#define SIT_UNIFORM_LOC_BLEND_MODE          3 // int: An integer representing a blend mode for shader-based blending.
#define SIT_UNIFORM_LOC_PROJECTION_MATRIX   4 // mat4: A projection matrix, for simple shaders not using the View UBO.

// =================================================================================
// --- Agnostic Internal Shader Sources ---
// =================================================================================
// The following GLSL shaders are embedded directly into the library. They use C preprocessor directives to compile into different, highly optimized versions for the OpenGL and Vulkan
// backends, allowing the core logic to be shared while respecting the unique data-passing conventions of each API. All resource locations are defined by the library's Shader Contract.

/**
 * @internal
 * @shader SIT_VD_SHADER
 * @brief The standard shader for compositing Virtual Displays.
 * @details This is the primary, high-performance shader used for drawing virtual displays with simple blend modes (Alpha, Additive, Multiply, etc.). It draws a simple textured quad.
 *
 * @var aPos (in) The 2D vertex position of the quad's corners.
 * @var aTexCoords (in) The UV coordinates for sampling the virtual display's texture.
 * @var v_texCoord (out) The interpolated texture coordinates passed to the fragment shader.
 *
 * @var ubo (uniform, Vulkan) The per-frame Uniform Buffer Object containing projection and view matrices.
 * @var pc (uniform, Vulkan) The Push Constant block containing the per-draw model matrix and opacity.
 * @var u_projection (uniform, OpenGL) The orthographic projection matrix.
 * @var u_model (uniform, OpenGL) The per-draw model matrix.
 * @var u_screenTexture (uniform) The sampler for the virtual display's texture content.
 * @var u_opacity (uniform, OpenGL) The per-draw opacity value.
 */
// --- Shader for simple Virtual Display compositing (Alpha, Add, Multiply, etc.) ---
static const char* SIT_VD_VERTEX_SHADER_SRC =
    "#version 450 core\n"
    "layout(location = " SIT_STRINGIFY(SIT_ATTR_POSITION) ") in vec2 aPos;\n"
    "layout(location = " SIT_STRINGIFY(SIT_ATTR_TEXCOORD_0) ") in vec2 aTexCoords;\n"
    "layout(location = 0) out vec2 v_texCoord;\n"
    "\n"
#if defined(SITUATION_USE_VULKAN)
    "layout(set = 0, binding = " SIT_STRINGIFY(SIT_UBO_BINDING_VIEW_DATA) ") uniform UboView { mat4 view; mat4 projection; } ubo;\n"
    "layout(push_constant) uniform VDPushConstants { mat4 model; float opacity; } pc;\n"
    "void main() {\n"
    "    gl_Position = ubo.projection * pc.model * vec4(aPos, 0.0, 1.0);\n"
    "    v_texCoord = aTexCoords;\n"
    "}\n"
#elif defined(SITUATION_USE_OPENGL)
    "layout(location = " SIT_STRINGIFY(SIT_UNIFORM_LOC_PROJECTION_MATRIX) ") uniform mat4 u_projection;\n"
    "layout(location = " SIT_STRINGIFY(SIT_UNIFORM_LOC_MODEL_MATRIX) ") uniform mat4 u_model;\n"
    "void main() {\n"
    "    gl_Position = u_projection * u_model * vec4(aPos, 0.0, 1.0);\n"
    "    v_texCoord = aTexCoords;\n"
    "}\n"
#endif
;

static const char* SIT_VD_FRAGMENT_SHADER_SRC =
    "#version 450 core\n"
    "layout(location = 0) in vec2 v_texCoord;\n"
    "layout(location = 0) out vec4 outColor;\n"
    "\n"
    "layout(binding = " SIT_STRINGIFY(SIT_SAMPLER_BINDING_VD_SOURCE) ") uniform sampler2D u_screenTexture;\n"
    "\n"
#if defined(SITUATION_USE_VULKAN)
    "layout(push_constant) uniform VDPushConstants { mat4 model; float opacity; } pc;\n"
    "void main() {\n"
    "    vec4 texColor = texture(u_screenTexture, v_texCoord);\n"
    "    outColor = vec4(texColor.rgb, texColor.a * pc.opacity);\n"
    "}\n"
#elif defined(SITUATION_USE_OPENGL)
    "layout(location = " SIT_STRINGIFY(SIT_UNIFORM_LOC_OPACITY) ") uniform float u_opacity;\n"
    "void main() {\n"
    "    vec4 texColor = texture(u_screenTexture, v_texCoord);\n"
    "    outColor = vec4(texColor.rgb, texColor.a * u_opacity);\n"
    "}\n"
#endif
;

/**
 * @internal
 * @shader SIT_COMPOSITE_SHADER
 * @brief An advanced shader for compositing with Photoshop-style blend modes.
 * @details This shader is used when a Virtual Display is configured with a blend mode that requires knowledge of the destination color (e.g., Overlay, Soft Light).
 *          It reads from both the source texture (the VD) and the destination framebuffer (copied to a texture) to calculate the final blended color.
 *
 * @var u_sourceTexture (uniform) The sampler for the source Virtual Display's texture.
 * @var u_destinationTexture (uniform) A sampler containing a copy of the framebuffer content that is *behind* the current virtual display.
 * @var pc.blendMode (uniform, Vulkan) An integer representing the blend mode to apply.
 * @var u_blendMode (uniform, OpenGL) An integer representing the blend mode to apply.
 */
// --- Shader for Advanced Photoshop-style compositing ---
static const char* SIT_COMPOSITE_VERTEX_SHADER_SRC =
    "#version 450 core\n"
    "layout(location = " SIT_STRINGIFY(SIT_ATTR_POSITION) ") in vec2 aPos;\n"
    "layout(location = " SIT_STRINGIFY(SIT_ATTR_TEXCOORD_0) ") in vec2 aTexCoords;\n"
    "layout(location = 0) out vec2 v_texCoord;\n"
    "\n"
#if defined(SITUATION_USE_VULKAN)
    "layout(set = 0, binding = " SIT_STRINGIFY(SIT_UBO_BINDING_VIEW_DATA) ") uniform UboView { mat4 view; mat4 projection; } ubo;\n"
    "layout(push_constant) uniform CompositePushConstants { mat4 model; int blendMode; float opacity; } pc;\n"
    "void main() {\n"
    "    gl_Position = ubo.projection * pc.model * vec4(aPos, 0.0, 1.0);\n"
    "    v_texCoord = aTexCoords;\n"
    "}\n"
#elif defined(SITUATION_USE_OPENGL)
    "layout(location = " SIT_STRINGIFY(SIT_UNIFORM_LOC_PROJECTION_MATRIX) ") uniform mat4 u_projection;\n"
    "layout(location = " SIT_STRINGIFY(SIT_UNIFORM_LOC_MODEL_MATRIX) ") uniform mat4 u_model;\n"
    "void main() {\n"
    "    gl_Position = u_projection * u_model * vec4(aPos, 0.0, 1.0);\n"
    "    v_texCoord = aTexCoords;\n"
    "}\n"
#endif
;

static const char* SIT_COMPOSITE_FRAGMENT_SHADER_SRC =
    "#version 450 core\n"
    "layout(location = 0) in vec2 v_texCoord;\n"
    "layout(location = 0) out vec4 outColor;\n"
    "\n"
    // Sampler bindings are consistent across backends\n"
    "layout(binding = " SIT_STRINGIFY(SIT_SAMPLER_BINDING_VD_SOURCE) ") uniform sampler2D u_sourceTexture;\n"
    "layout(binding = " SIT_STRINGIFY(SIT_SAMPLER_BINDING_VD_DEST) ") uniform sampler2D u_destinationTexture;\n"
    "\n"
    // --- Blend Mode Helpers ---\n"
    "float overlay(float b, float l) { return (b < 0.5) ? (2.0*b*l) : (1.0 - 2.0*(1.0-b)*(1.0-l)); }\n"
    "float softlight(float b, float l) { return (l < 0.5) ? (b - (1.0 - 2.0 * l) * b * (1.0 - b)) : (b + (2.0 * l - 1.0) * (((b <= 0.25) ? (((16.0 * b - 12.0) * b + 4.0) * b) : sqrt(b)) - b)); }\n"
    "\n"
    // --- Backend-Specific Uniform/Push Constant Declarations ---\n"
#if defined(SITUATION_USE_VULKAN)
    "layout(push_constant) uniform CompositePushConstants { mat4 model; int blendMode; float opacity; } pc;\n"
#elif defined(SITUATION_USE_OPENGL)
    "layout(location = " SIT_STRINGIFY(SIT_UNIFORM_LOC_BLEND_MODE) ") uniform int u_blendMode;\n"
    "layout(location = " SIT_STRINGIFY(SIT_UNIFORM_LOC_OPACITY) ") uniform float u_opacity;\n"
#endif
    "\n"
    "void main() {\n"
    "    // --- Select correct uniform source based on backend ---\n"
    "    int blendMode;\n"
    "    float opacity;\n"
#if defined(SITUATION_USE_VULKAN)
    "    blendMode = pc.blendMode;\n"
    "    opacity = pc.opacity;\n"
#else // OpenGL
    "    blendMode = u_blendMode;\n"
    "    opacity = u_opacity;\n"
#endif
    "\n"
    "    // Fetch source (VD) and destination (framebuffer) colors\n"
    "    vec4 src = texture(u_sourceTexture, v_texCoord);\n"
    "    vec3 dst = texture(u_destinationTexture, gl_FragCoord.xy / textureSize(u_destinationTexture, 0)).rgb;\n"
    "    vec3 res;\n"
    "\n"
    "    // --- FULL BLEND MODE IMPLEMENTATION ---\n"
    "    switch (blendMode) {\n"
    "        // These modes are handled by the simple shader, but included as fallbacks.\n"
    "        case 0:  /* ALPHA */ res = src.rgb; break;\n"
    "        case 1:  /* ADDITIVE */ res = src.rgb + dst; break;\n"
    "        case 2:  /* MULTIPLY */ res = src.rgb * dst; break;\n"
    "        // --- Advanced Photoshop-style modes ---\n"
    "        case 3:  /* SCREEN */ res = 1.0 - (1.0 - src.rgb) * (1.0 - dst); break;\n"
    "        case 5:  /* OVERLAY */ res = vec3(overlay(dst.r, src.r), overlay(dst.g, src.g), overlay(dst.b, src.b)); break;\n"
    "        case 6:  /* SOFT_LIGHT */ res = vec3(softlight(dst.r, src.r), softlight(dst.g, src.g), softlight(dst.b, src.b)); break;\n"
    "        case 7:  /* HARD_LIGHT */ res = vec3(overlay(src.r, dst.r), overlay(src.g, dst.g), overlay(src.b, dst.b)); break;\n"
    "        case 8:  /* COLOR_DODGE */ res = dst / (1.0 - min(vec3(0.9999), src.rgb)); break;\n"
    "        case 9:  /* COLOR_BURN */ res = 1.0 - (1.0 - dst) / max(vec3(0.0001), src.rgb); break;\n"
    "        case 10: /* DARKEN */ res = min(dst, src.rgb); break;\n"
    "        case 11: /* LIGHTEN */ res = max(dst, src.rgb); break;\n"
    "        case 12: /* DIFFERENCE */ res = abs(dst - src.rgb); break;\n"
    "        case 13: /* EXCLUSION */ res = dst + src.rgb - 2.0 * dst * src.rgb; break;\n"
    "        default: res = src.rgb; break;\n"
    "    }\n"
    "\n"
    "    // --- Final Composition ---\n"
    "    // Linearly interpolate (mix) between the original destination color (dst)\n"
    "    // and the blended result (res) based on the source's alpha and overall opacity.\n"
    "    float finalAlpha = src.a * opacity;\n"
    "    outColor = vec4(mix(dst.rgb, res, finalAlpha), 1.0);\n"
    "}\n";

// Draws a simple, colored, transformed quad. Adheres to the Shader Contract.
static const char* SIT_QUAD_VERTEX_SHADER =
    "#version 450 core\n"
    // Shader Contract: Vertex Position Attribute
    "layout(location = " SIT_STRINGIFY(SIT_ATTR_POSITION) ") in vec2 aPos;\n"
    "\n"
    // --- Backend-Agnostic Uniform Block --- \n"
#if defined(SITUATION_USE_VULKAN)
    // For Vulkan, UBO is in Set 0, Binding 1. Push constants hold per-draw data.
    "layout(set = 0, binding = " SIT_STRINGIFY(SIT_UBO_BINDING_VIEW_DATA) ") uniform UboView {\n"
    "    mat4 view;\n"
    "    mat4 projection;\n"
    "} ubo;\n"
    "\n"
    "layout(push_constant) uniform QuadPushConstants {\n"
    "    mat4 model;\n"
    "    vec4 color;\n"
    "} pc;\n"
    "\n"
    "void main() {\n"
    "    gl_Position = ubo.projection * pc.model * vec4(aPos, 0.0, 1.0);\n"
    "}\n"
#elif defined(SITUATION_USE_OPENGL)
    // For OpenGL, all uniforms are standalone with explicit locations from the contract.
    "layout(location = " SIT_STRINGIFY(SIT_UNIFORM_LOC_PROJECTION_MATRIX) ") uniform mat4 u_projection;\n"
    "layout(location = " SIT_STRINGIFY(SIT_UNIFORM_LOC_MODEL_MATRIX) ") uniform mat4 u_model;\n"
    "\n"
    "void main() {\n"
    "    gl_Position = u_projection * u_model * vec4(aPos, 0.0, 1.0);\n"
    "}\n"
#endif
;

static const char* SIT_QUAD_FRAGMENT_SHADER =
    "#version 450 core\n"
    "layout(location = 0) out vec4 outColor;\n"
    "\n"
    // --- Backend-Agnostic Uniform Block --- \n"
#if defined(SITUATION_USE_VULKAN)
    // Vulkan gets the color from the same push constant block as the vertex shader.
    "layout(push_constant) uniform QuadPushConstants {\n"
    "    mat4 model;\n"
    "    vec4 color;\n"
    "} pc;\n"
    "\n"
    "void main() {\n"
    "    outColor = pc.color;\n"
    "}\n"
#elif defined(SITUATION_USE_OPENGL)
    // OpenGL gets the color from a separate standalone uniform.
    "layout(location = " SIT_STRINGIFY(SIT_UNIFORM_LOC_OBJECT_COLOR) ") uniform vec4 u_objectColor;\n"
    "\n"
    "void main() {\n"
    "    outColor = u_objectColor;\n"
    "}\n"
#endif
;

//==================================================================================
// OpenGL Backend Helpers & Shader Contract
//==================================================================================
#if defined(SITUATION_USE_OPENGL)
// --- OpenGL Helper Functions ---
static SituationError _SituationInitOpenGL(const SituationInitInfo* init_info);
static void _SituationCleanupOpenGL(void);
static void _SituationLogGLError(const char* file, int line);
static GLuint _SituationCreateGLShaderProgramFromSource(const char* cs_src, SituationError* error_code);
static GLuint _SituationCompileGLShader(const char* source, GLenum type, SituationError* error_code);
static GLuint _SituationCreateGLShaderProgram(const char* vs_src, const char* fs_src, SituationError* error_code);
static GLuint _SituationCreateGLComputeProgram(const void* source_data, SituationGLShaderSourceType source_type, SituationError* error_code);
static void _SituationCheckGLError(const char* location);
#if defined(SITUATION_ENABLE_SHADER_COMPILER)
// Forward declare the SPIR-V blob struct as it's used here
struct _SituationSpirvBlob;
// Creates a two-stage (graphics) program from two SPIR-V blobs.
static GLuint _SituationCreateGLShaderProgramFromSpirv(const struct _SituationSpirvBlob* vs_blob, const struct _SituationSpirvBlob* fs_blob, SituationError* error_code);
// Creates a single-stage (compute) program from one SPIR-V blob.
static GLuint _SituationCreateGLComputeProgramFromSpirv(const struct _SituationSpirvBlob* cs_blob, SituationError* error_code);
#endif
#endif

//==================================================================================
// Vulkan Backend Helpers
//==================================================================================
#if defined(SITUATION_USE_VULKAN)

#define SITUATION_VULKAN_MAX_INSTANCE_EXTENSIONS      16
#define SITUATION_VULKAN_UNIFORM_BUFFER_SIZE          256
#define SITUATION_VULKAN_STORAGE_BUFFER_SIZE          256
#define SITUATION_VULKAN_COMBINED_IMAGE_SAMPLER_SIZE  512
#define SITUATION_VULKAN_DEFAULT_USER_STORAGE_IMAGES  128
    
// --- Internal Vulkan Helper Data Structures ---
typedef struct {
    uint32_t graphics_family;
    uint32_t present_family;
    bool graphics_family_has_value;
    bool present_family_has_value;
} _SituationQueueFamilyIndices;

typedef struct {
    VkSurfaceCapabilitiesKHR capabilities;
    VkSurfaceFormatKHR* formats;
    uint32_t format_count;
    VkPresentModeKHR* present_modes;
    uint32_t present_mode_count;
} _SituationVulkanSwapchainSupportDetails;

typedef struct _SituationSpirvBlob {
    const uint8_t* data;
    size_t size;
    shaderc_compilation_result_t internal_result;
} _SituationSpirvBlob;

// --- Vulkan Initialization & Cleanup Sequence ---
static SituationError _SituationInitVulkan(const SituationInitInfo* init_info);
static void _SituationCleanupVulkan(void);
static const char** _SituationVulkanGetRequiredExtensions(uint32_t* out_extension_count, bool enable_validation);
static SituationError _SituationVulkanCreateInstance(const SituationInitInfo* init_info);
static SituationError _SituationVulkanSetupDebugMessenger(const SituationInitInfo* init_info);
static SituationError _SituationVulkanCreateSurface(void);
static SituationError _SituationVulkanPickPhysicalDevice(void);
static SituationError _SituationVulkanCreateLogicalDevice(const SituationInitInfo* init_info);
static SituationError _SituationVulkanCreateAllocator(void);
static SituationError _SituationVulkanCreateSwapchain(void);
static SituationError _SituationVulkanCreateImageViews(void);
static SituationError _SituationVulkanCreateRenderPass(void);
static SituationError _SituationVulkanCreateDepthResources(void);
static SituationError _SituationVulkanCreateFramebuffers(void);
static SituationError _SituationVulkanCreateCommandPool(void);
static SituationError _SituationVulkanCreateCommandBuffers(void);
static SituationError _SituationVulkanCreateSyncObjects(void);
static SituationError _SituationVulkanInitInternalRenderers(void);
static SituationShader _SituationCreateVulkanPipeline(const char* vs_path, const char* fs_path);

// --- Vulkan State Management & Utility Helpers ---
static void _SituationVulkanCleanupSwapchain(void);
static void _SituationVulkanRecreateSwapchain(void);
static int _SituationIsDeviceSuitable(VkPhysicalDevice device);
static VkFormat _SituationVulkanFindSupportedFormat(const VkFormat* candidates, uint32_t candidate_count, VkImageTiling tiling, VkFormatFeatureFlags features);
static _SituationQueueFamilyIndices _SituationVulkanFindQueueFamilies(VkPhysicalDevice device, VkSurfaceKHR surface);
static void _SituationVulkanQuerySwapchainSupport(VkPhysicalDevice device, _SituationVulkanSwapchainSupportDetails* out_details);
static void _SituationVulkanFreeSwapchainSupportDetails(_SituationVulkanSwapchainSupportDetails* details);
static void _SituationVulkanGenerateMipmaps(VkCommandBuffer cmd, VkImage image, int32_t width, int32_t height, uint32_t mip_levels);


// --- Vulkan Resource Management Helpers ---
static SituationError _SituationVulkanCreateImage(uint32_t width, uint32_t height, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VmaMemoryUsage memory_usage, VkImage* out_image, VmaAllocation* out_allocation);
static VkImageView _SituationVulkanCreateImageView(VkImage image, VkFormat format, VkImageAspectFlags aspect_flags);
static SituationError _SituationVulkanCreateAndUploadBuffer(const void* data, VkDeviceSize size, VkBufferUsageFlags usage, VkBuffer* out_buffer, VmaAllocation* out_allocation);
static VkCommandBuffer _SituationVulkanBeginSingleTimeCommands(void);
static void _SituationVulkanEndSingleTimeCommands(VkCommandBuffer command_buffer);
static VkShaderModule _SituationVulkanCreateShaderModule(const void* code, size_t code_size);
static VkPipeline _SituationVulkanCreateGraphicsPipeline(
    const void* vs_data, size_t vs_size,
    const void* fs_data, size_t fs_size,
    VkPipelineLayout pipelineLayout,
    VkPrimitiveTopology topology,
    uint32_t vertexBindingCount,
    const VkVertexInputBindingDescription* pVertexBindingDescriptions,
    uint32_t vertexAttributeCount,
    const VkVertexInputAttributeDescription* pVertexAttributeDescriptions);
static SituationError _SituationVulkanInitComputeLayouts(void);
static SituationComputePipeline _SituationVulkanCreateComputePipeline(const uint8_t* cs_spirv_data, size_t cs_spirv_size);
static void _SituationVulkanDestroyComputePipeline(_SituationComputePipeline* pipeline);
#if defined(SITUATION_ENABLE_SHADER_COMPILER)
static _SituationSpirvBlob _SituationVulkanCompileGLSLtoSPIRV(const char* glsl_source, const char* source_name, shaderc_shader_kind shader_kind);
static void _SituationFreeSpirvBlob(_SituationSpirvBlob* blob);
#endif
static void _SituationVulkanTransitionImageLayout(VkCommandBuffer cmd, VkImage image, VkImageLayout old_layout, VkImageLayout new_layout);
static void _SituationVulkanCopyBufferToImage(VkCommandBuffer cmd, VkBuffer buffer, VkImage image, uint32_t width, uint32_t height);
static void* _SituationVulkanBlitImageToHostVisibleBuffer(VkImage srcImage, VkImageLayout srcImageLayout, uint32_t width, uint32_t height);

// --- Vulkan Callback Functions ---
static VKAPI_ATTR VkBool32 VKAPI_CALL _SituationVulkanDebugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData);

#endif // SITUATION_USE_VULKAN

//==================================================================================
// Miscellaneous Module Helpers
//==================================================================================

static void _SituationSetFilesystemError(const char* base_message, const char* path);

// --- Audio Helpers ---
static void sit_miniaudio_data_callback(ma_device* pDevice, void* pOutput, const void* pInput, uint32_t frameCount);

// --- Display Helpers ---
static void _SituationCachePhysicalDisplays(void);
static int _SituationSortVirtualDisplaysCallback(const void* a, const void* b);
SITAPI int _SituationGetCurrentDisplayIdentifier(void); // Returns situation_monitor_id of current monitor, or -1

// --- Internal Quad Renderer Helpers ---
static bool _SituationInitQuadRenderer(int width, int height);
static void _SituationCleanupQuadRenderer(void);

// --- Image Helpers ---
static bool _SituationSaveImageBMP(const char* fileName, const SituationImage* image);
static inline ColorRGBA _SituationColorAlphaBlend(ColorRGBA dst, ColorRGBA src, float alpha);
static unsigned char _SituationBilinearSample(const unsigned char *bitmap, int width, int height, float u, float v);

// --- Math Helpers ---
static inline float _SituationClampf(float value, float min, float max) { const float t = value < min ? min : value; return t > max ? max : t; }
static inline float _SituationLerpf(float a, float b, float t) { return a + t * (b - a); }
static inline float _SituationFMin3(float a, float b, float c) { return fminf(a, fminf(b, c)); } // Find the minimum of three floats
static inline float _SituationFMax3(float a, float b, float c) { return fmaxf(a, fmaxf(b, c)); } // Find the maximum of three floats



// --- Simple string hashing function (djb2) ---
static unsigned long _sit_hash_string(const char* str) {
    unsigned long hash = 5381;
    int c;
    while ((c = *str++)) {
        hash = ((hash << 5) + hash) + c; // hash * 33 + c
    }
    return hash;
}

/**
 * @brief [INTERNAL] Creates and initializes a new uniform map.
 *
 * @details This helper function allocates memory for a new `_SituationUniformMap` struct and its internal hash table buckets. The map is initialized to be empty, ready to store key-value pairs (uniform name strings mapped to GLint locations).
 *          This map is used as a cache to avoid repeated, costly calls to `glGetUniformLocation` for the same uniform name within a shader program.
 *
 * @return A pointer to the newly created `_SituationUniformMap` struct on success.
 * @return NULL if memory allocation fails for the map struct itself or its bucket array.
 *
 * @note The caller is responsible for destroying the returned map using `_sit_uniform_map_destroy` when it is no longer needed to prevent memory leaks.
 * @warning This function is for internal library use only and is not part of the public API.
 *
 * @see _sit_uniform_map_destroy(), _sit_uniform_map_set(), _sit_uniform_map_get()
 */
static _SituationUniformMap* _sit_uniform_map_create() {
    // --- 1. Allocate Memory for the Map Struct ---
    _SituationUniformMap* map = (_SituationUniformMap*)calloc(1, sizeof(_SituationUniformMap));
    // Using calloc initializes map->count and map->capacity to 0, and map->buckets to NULL.

    // Check if allocation for the map struct itself was successful.
    if (!map) {
        // Allocation failed for the main struct.
        // _SituationSetErrorFromCode might be overkill for internal alloc failures,
        // but could be considered if the library does this for internal helpers.
        // _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "_sit_uniform_map_create: Failed to allocate map struct.");
        return NULL;
    }

    // --- 2. Initialize Map Properties ---
    map->capacity = SIT_UNIFORM_MAP_INITIAL_CAPACITY; // Set initial bucket count
    map->count = 0; // Start with an empty map

    // --- 3. Allocate Memory for the Bucket Array ---
    // Allocate an array of pointers to `_SituationUniformMapEntry`.
    // The size is `capacity * sizeof(_SituationUniformMapEntry*)`.
    map->buckets = (_SituationUniformMapEntry**)calloc(map->capacity, sizeof(_SituationUniformMapEntry*));
    // Using calloc initializes all bucket pointers to NULL.

    // Check if allocation for the bucket array was successful.
    if (!map->buckets) {
        // Allocation failed for the bucket array.
        // Free the previously allocated map struct to prevent a memory leak.
        free(map);
        // _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "_sit_uniform_map_create: Failed to allocate bucket array.");
        return NULL;
    }

    // --- 4. Success ---
    // Both allocations were successful. The map is initialized and ready for use.
    return map;
}

// --- Updated/Added Documentation Block for _sit_uniform_map_destroy ---
/**
 * @brief [INTERNAL] Destroys a uniform map and frees all associated memory.
 *
 * @details This helper function recursively frees all memory associated with a `_SituationUniformMap`, including:
 * 1.  All individual key strings (`entry->key`) stored within the map entries.
 * 2.  All `_SituationUniformMapEntry` structs themselves.
 * 3.  The internal bucket array (`map->buckets`).
 * 4.  The main `_SituationUniformMap` struct (`map`).
 *
 * It safely handles being called on a NULL pointer or an already destroyed map.
 *
 * @param map A pointer to the `_SituationUniformMap` struct to be destroyed. This pointer can be NULL.
 *
 * @note This function must be called exactly once for each map created by `_sit_uniform_map_create` to prevent memory leaks.
 * @warning This function is for internal library use only and is not part of the public API.
 * @warning After calling this function, the `map` pointer becomes invalid and must not be used again.
 *
 * @see _sit_uniform_map_create()
 */
static void _sit_uniform_map_destroy(_SituationUniformMap* map) {
    // --- 1. Input Validation ---
    // Check if the map pointer is NULL. If so, there's nothing to destroy.
    // This is a safe and common pattern for destroy/free functions.
    if (!map) {
        return;
    }

    // --- 2. Destroy All Entries in All Buckets ---
    // Iterate through each bucket in the hash table.
    for (int i = 0; i < map->capacity; ++i) {
        // Get the head of the linked list for the current bucket.
        _SituationUniformMapEntry* entry = map->buckets[i];

        // Traverse the linked list for this bucket.
        while (entry != NULL) {
            // Save the pointer to the next entry *before* freeing the current one.
            _SituationUniformMapEntry* next_entry = entry->next;

            // Free the key string. strdup/strndup requires free().
            // It's safe to call free(NULL).
            free(entry->key);
            entry->key = NULL; // Defensive nulling (optional)

            // Free the entry struct itself.
            free(entry);
            entry = NULL; // Defensive nulling (optional)

            // Move to the next entry in the list.
            entry = next_entry;
        }
        // After the loop, the entire linked list for bucket `i` is freed.
        map->buckets[i] = NULL; // Defensive nulling (optional)
    }
    // All entries in all buckets have been destroyed.

    // --- 3. Free the Bucket Array ---
    // Free the memory allocated for the array of bucket pointers.
    free(map->buckets);
    map->buckets = NULL; // Defensive nulling
    map->capacity = 0;   // Reset capacity
    map->count = 0;      // Reset count

    // --- 4. Free the Map Struct Itself ---
    // Finally, free the memory allocated for the main map struct.
    free(map);
    // Note: The `map` pointer itself is not set to NULL here because
    // the caller's copy of the pointer is not passed by reference.
    // It is the caller's responsibility to not use the pointer after this call.
}

// --- Updated/Added Documentation Block for _sit_uniform_map_set ---
/**
 * @brief [INTERNAL] Adds or updates a key-value pair in the uniform map.
 *
 * @details This helper function inserts a new key-value pair (`key` -> `value`) into the hash map, or updates the value if the key already exists. It uses a simple chaining hash table structure.
 * 1.  Calculates the hash of the `key`.
 * 2.  Determines the bucket index using `hash % capacity`.
 * 3.  Searches the linked list at that bucket for the key.
 * 4.  If found, updates the existing entry's value.
 * 5.  If not found, allocates a new entry, duplicates the key string, sets the value, and prepends the new entry to the bucket's linked list.
 *
 * @param map A pointer to the `_SituationUniformMap` struct to modify.
 * @param key A null-terminated C string representing the uniform name (the key).
 * @param value The GLint value (typically the uniform location) to associate with the key.
 *
 * @note This function performs memory allocation for new keys and map entries.
 *       If allocation fails, the function returns silently without adding the entry.
 *       This is generally acceptable for a cache mechanism.
 * @note The function currently does not implement dynamic resizing of the hash table.
 *       If the number of entries (`map->count`) grows significantly larger than the `map->capacity`, performance may degrade due to longer linked list chains.
 *       A TODO exists in the original code for this.
 * @warning This function is for internal library use only and is not part of the public API.
 *
 * @see _sit_uniform_map_get(), _sit_hash_string()
 */
static void _sit_uniform_map_set(_SituationUniformMap* map, const char* key, GLint value) {
    // --- 1. Input Validation ---
    // Check if the map or key pointer is NULL.
    if (!map || !key) {
        // Cannot operate on a NULL map or NULL key.
        // Silently return, consistent with other void internal functions.
        // Could consider logging/asserting in debug builds.
        return;
    }

    // --- 2. Calculate Hash and Bucket Index ---
    // Compute the hash value of the key string.
    unsigned long hash = _sit_hash_string(key);
    // Determine the index of the bucket where this key/value pair should reside.
    // Use the modulo operator to fit the hash within the bucket array size.
    int index = hash % map->capacity;
    // Ensure index is within valid bounds (should be guaranteed by modulo, but good practice).
    // if (index < 0 || index >= map->capacity) { /* Handle error */ return; } // Redundant with modulo

    // --- 3. Search for Existing Key ---
    // Get the head of the linked list for the determined bucket.
    _SituationUniformMapEntry* entry = map->buckets[index];

    // Traverse the linked list in this bucket to check if the key already exists.
    while (entry != NULL) {
        // Compare the current entry's key with the provided key.
        if (strcmp(entry->key, key) == 0) {
            // Key found. Update the existing entry's value.
            entry->value = value;
            // No need to modify the list structure or count.
            return; // Exit early, operation complete.
        }
        // Key not found in this entry, move to the next one in the chain.
        entry = entry->next;
    }

    // --- 4. Key Not Found: Create New Entry ---
    // If the loop completes, the key was not found in the bucket's list.
    // We need to create a new entry for this key/value pair.

    // Allocate memory for the new entry struct.
    _SituationUniformMapEntry* new_entry = (_SituationUniformMapEntry*)malloc(sizeof(_SituationUniformMapEntry));
    // Check if allocation for the new entry was successful.
    if (!new_entry) {
        // Allocation failed for the new entry struct.
        // This is a memory-constrained situation. Silently failing to add the entry is often acceptable for a cache, as glGetUniformLocation can be called again.
        // _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "_sit_uniform_map_set: Failed to allocate new entry struct.");
        return;
    }

    // --- 5. Initialize New Entry ---
    // Duplicate the key string. This allocates memory and copies the string.
    // The caller retains ownership of the original `key` string.
    new_entry->key = strdup(key);
    // Check if strdup was successful.
    if (!new_entry->key) {
        // Allocation failed for duplicating the key string.
        // Free the previously allocated entry struct to prevent a leak.
        free(new_entry);
        // _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "_sit_uniform_map_set: Failed to duplicate key string.");
        return;
    }

    // Set the value for the new entry.
    new_entry->value = value;

    // --- 6. Insert New Entry into the Hash Table ---
    // Link the new entry into the linked list for the bucket.
    // Set the new entry's `next` pointer to the current head of the list.
    new_entry->next = map->buckets[index];
    // Update the bucket's head pointer to point to the new entry.
    map->buckets[index] = new_entry;

    // Increment the total count of entries in the map.
    map->count++;

    // --- 7. (Future Work) Consider Resizing ---
    // TODO: Add logic to check if the load factor (count/capacity) is too high.
    // if (map->count > map->capacity * 0.75) {
    //     _sit_uniform_map_resize(map); // Hypothetical resize function
    // }
}

// --- Updated/Added Documentation Block for _sit_uniform_map_get ---
/**
 * @brief [INTERNAL] Retrieves a value associated with a key from the uniform map.
 *
 * @details This helper function looks up a `key` (uniform name) in the hash map and returns the associated `GLint` value (uniform location) if found.
 * 1.  Calculates the hash of the `key`.
 * 2.  Determines the bucket index using `hash % capacity`.
 * 3.  Searches the linked list at that bucket for the key.
 * 4.  If found, returns the value.
 * 5.  If not found after traversing the list, returns -1.
 *
 * @param map A pointer to the `_SituationUniformMap` struct to search.
 * @param key A null-terminated C string representing the uniform name (the key) to find.
 *
 * @return The GLint value associated with the `key` if it is found in the map.
 * @return -1 if the `key` is not found, if `map` is NULL, or if `key` is NULL. Returning -1 is safe because valid uniform locations are non-negative.
 *
 * @warning This function is for internal library use only and is not part of the
 *          public API.
 *
 * @see _sit_uniform_map_set(), _sit_hash_string()
 */
static GLint _sit_uniform_map_get(_SituationUniformMap* map, const char* key) {
    // --- 1. Input Validation ---
    // Check if the map or key pointer is NULL.
    if (!map || !key) {
        // Cannot search a NULL map or for a NULL key.
        // Return -1 to indicate "not found" or invalid input.
        return -1;
    }

    // --- 2. Calculate Hash and Bucket Index ---
    // Compute the hash value of the key string.
    unsigned long hash = _sit_hash_string(key);
    // Determine the index of the bucket where this key might reside.
    int index = hash % map->capacity;
    // Ensure index is within valid bounds.
    // if (index < 0 || index >= map->capacity) { return -1; } // Redundant with modulo

    // --- 3. Search the Bucket's Linked List ---
    // Get the head of the linked list for the determined bucket.
    _SituationUniformMapEntry* entry = map->buckets[index];

    // Traverse the linked list in this bucket.
    while (entry != NULL) {
        // Compare the current entry's key with the provided key.
        if (strcmp(entry->key, key) == 0) {
            // Key found. Return the associated value.
            return entry->value;
        }
        // Key not found in this entry, move to the next one in the chain.
        entry = entry->next;
    }

    // --- 4. Key Not Found ---
    // If the loop completes, the key was not present in the map.
    // Return -1 to indicate "not found".
    return -1;
}

// --- Error Handling Implementation ---
/**
 * @brief [INTERNAL] Atomically sets the library's last error message.
 * @details This is the core internal function for setting the global error string. It is designed to be robust and thread-safe. It uses `strncpy` to prevent buffer overflows and correctly handles `NULL` input by providing a default message.
 *
 * @par Thread Safety
 *   All write access to the global `sit_gs.last_error_msg` buffer is protected by a dedicated mutex (`sit_gs.error_mutex`). This ensures that if two different threads encounter errors simultaneously,
 *   the error messages will not be interleaved or corrupted. This is a critical feature for preparing the library for future multi-threading.
 *
 * @note This function is designed to be callable at any point, even before the library is fully initialized, making it suitable for reporting errors during the startup sequence.
 *
 * @param msg The null-terminated error message string to be set. If NULL, a default "Unknown error" message will be used.
 */
static void _SituationSetError(const char* msg) {
    // A single, consistent string to use for NULL input.
    const char* default_error_msg = "Unknown error";
    const char* message_to_copy = msg ? msg : default_error_msg;

    // Lock the mutex to ensure exclusive access to the shared error message buffer.
    ma_mutex_lock(&sit_gs.error_mutex);
    {
        // Use strncpy to safely copy the message, preventing buffer overflows if the source string is longer than the destination buffer. It will copy at most (SITUATION_MAX_ERROR_MSG_LEN - 1) characters.
        strncpy(sit_gs.last_error_msg, message_to_copy, SITUATION_MAX_ERROR_MSG_LEN - 1);

        // CRITICAL: strncpy does not guarantee null-termination if the source string is exactly as long as or longer than the destination buffer size. We must manually ensure the string is always null-terminated for safety.
        sit_gs.last_error_msg[SITUATION_MAX_ERROR_MSG_LEN - 1] = '\0';
    }
    // Unlock the mutex as soon as the critical section is finished.
    ma_mutex_unlock(&sit_gs.error_mutex);
}

/**
 * @brief [INTERNAL] Sets the library's last error message from an error code and an optional detail string.
 * @details This internal helper translates a `SituationError` enum into a human-readable base message, appends a specific detail string if provided, and stores the final, formatted result in the global error message buffer via `_SituationSetError`.
 *
 * This function serves as the central switchboard for all error reporting in the library, ensuring consistent and descriptive messages.
 *
 * @param err The `SituationError` code to translate.
 * @param detail An optional, more specific string describing the context of the error (can be `NULL`).
 *
 * @note This function is for internal use only.
 * @see _SituationSetError(), SituationGetLastErrorMsg(), SituationError
 */
static void _SituationSetErrorFromCode(SituationError err, const char* detail) {
    char buffer[SITUATION_MAX_ERROR_MSG_LEN];
    const char* base_msg = "Unknown Error";

    switch (err) {
        // --- Core & System Errors (0-99) ---
        case SITUATION_SUCCESS:                           base_msg = "No error"; break;
        case SITUATION_ERROR_GENERAL:                     base_msg = "A general error occurred"; break;
        case SITUATION_ERROR_NOT_IMPLEMENTED:             base_msg = "A feature is declared but not implemented for the current backend"; break;
        case SITUATION_ERROR_NOT_INITIALIZED:             base_msg = "Function called before library was successfully initialized"; break;
        case SITUATION_ERROR_ALREADY_INITIALIZED:         base_msg = "SituationInit() was called more than once"; break;
        case SITUATION_ERROR_INIT_FAILED:                 base_msg = "Core library initialization failed"; break;
        case SITUATION_ERROR_SHUTDOWN_FAILED:             base_msg = "Library shutdown failed"; break;
        case SITUATION_ERROR_INVALID_PARAM:               base_msg = "A function was called with an invalid parameter"; break;
        case SITUATION_ERROR_MEMORY_ALLOCATION:           base_msg = "A memory allocation (malloc, calloc, realloc) failed"; break;

        // --- Platform & Window Errors (100-199) ---
        case SITUATION_ERROR_GLFW_FAILED:                 base_msg = "An underlying GLFW library operation failed"; break;
        case SITUATION_ERROR_WINDOW_FOCUS:                base_msg = "An operation related to window focus failed"; break;
        case SITUATION_ERROR_DEVICE_QUERY:                base_msg = "Failed to query system hardware or device information"; break;
        case SITUATION_ERROR_TIMER_SYSTEM:                base_msg = "An error occurred within the internal timer/oscillator system"; break;
        case SITUATION_ERROR_COM_FAILED:                  base_msg = "[Win32] Failed to initialize the COM library"; break;
        case SITUATION_ERROR_DXGI_FAILED:                 base_msg = "[Win32] A call to the DXGI library failed"; break;

        // --- Display & Virtual Display Errors (200-299) ---
        case SITUATION_ERROR_DISPLAY_QUERY:               base_msg = "Failed to query physical monitor information"; break;
        case SITUATION_ERROR_DISPLAY_SET:                 base_msg = "Failed to set a display mode on a physical monitor"; break;
        case SITUATION_ERROR_VIRTUAL_DISPLAY_LIMIT:       base_msg = "The maximum number of virtual displays has been reached"; break;
        case SITUATION_ERROR_VIRTUAL_DISPLAY_INVALID_ID:  base_msg = "An invalid virtual display ID was provided"; break;

        // --- Filesystem Errors (300-399) ---
        case SITUATION_ERROR_FILE_ACCESS:                 base_msg = "A generic file or directory access error occurred"; break;
        case SITUATION_ERROR_PATH_NOT_FOUND:              base_msg = "The specified file or directory was not found"; break;
        case SITUATION_ERROR_PATH_INVALID:                base_msg = "The specified path is invalid or contains illegal characters"; break;
        case SITUATION_ERROR_PERMISSION_DENIED:           base_msg = "Permission was denied for the requested file operation"; break;
        case SITUATION_ERROR_DISK_FULL:                   base_msg = "The disk is full; cannot complete a write operation"; break;
        case SITUATION_ERROR_FILE_LOCKED:                 base_msg = "The file is locked or currently in use by another process"; break;
        case SITUATION_ERROR_DIR_NOT_EMPTY:               base_msg = "A directory is not empty and cannot be deleted non-recursively"; break;
        case SITUATION_ERROR_FILE_ALREADY_EXISTS:         base_msg = "The specified file already exists where it shouldn't"; break;
        case SITUATION_ERROR_PATH_IS_DIRECTORY:           base_msg = "A file operation was attempted on a path that is a directory"; break;
        case SITUATION_ERROR_PATH_IS_FILE:                base_msg = "A directory operation was attempted on a path that is a file"; break;
        
        // --- Audio Errors (400-499) ---
        case SITUATION_ERROR_AUDIO_CONTEXT:               base_msg = "Audio: Failed to initialize the audio context (MiniAudio)"; break;
        case SITUATION_ERROR_AUDIO_DEVICE:                base_msg = "Audio: Failed to initialize, start, or stop an audio device"; break;
        case SITUATION_ERROR_AUDIO_SOUND_LIMIT:           base_msg = "Audio: The sound playback queue limit was reached"; break;
        case SITUATION_ERROR_AUDIO_CONVERTER:             base_msg = "Audio: Failed to configure a data format/rate converter for a sound"; break;
        case SITUATION_ERROR_AUDIO_DECODING:              base_msg = "Audio: Failed to decode an audio file"; break;
        case SITUATION_ERROR_AUDIO_INVALID_OPERATION:     base_msg = "Audio: An invalid operation was attempted on a sound (e.g., cropping a stream)"; break;

        // --- Resource & Rendering Errors (500-599) ---
        case SITUATION_ERROR_RESOURCE_INVALID:            base_msg = "An invalid resource handle (shader, mesh, texture, etc.) was used"; break;
        case SITUATION_ERROR_BUFFER_MAP_FAILED:           base_msg = "Failed to map a GPU buffer to CPU memory"; break;
        case SITUATION_ERROR_BUFFER_INVALID_SIZE:         base_msg = "A buffer operation was attempted with an out-of-bounds offset or size"; break;
        case SITUATION_ERROR_RENDER_COMMAND_FAILED:       base_msg = "A command failed to be recorded to a command buffer"; break;
        case SITUATION_ERROR_RENDER_PASS_ACTIVE:          base_msg = "An operation was attempted that is illegal during an active render pass"; break;
        case SITUATION_ERROR_NO_RENDER_PASS_ACTIVE:       base_msg = "A drawing operation was attempted outside of a render pass"; break;

        // --- OpenGL Specific Errors (600-699) ---
        case SITUATION_ERROR_OPENGL_GENERAL:              base_msg = "OpenGL: A general error occurred (glGetError)"; break;
        case SITUATION_ERROR_OPENGL_LOADER_FAILED:        base_msg = "OpenGL: Failed to load OpenGL functions (GLAD)"; break;
        case SITUATION_ERROR_OPENGL_UNSUPPORTED:          base_msg = "OpenGL: A required version or extension is not supported by the driver"; break;
        case SITUATION_ERROR_OPENGL_SHADER_COMPILE:       base_msg = "OpenGL: GLSL shader compilation failed"; break;
        case SITUATION_ERROR_OPENGL_SHADER_LINK:          base_msg = "OpenGL: GLSL shader program linking failed"; break;
        case SITUATION_ERROR_OPENGL_FBO_INCOMPLETE:       base_msg = "OpenGL: A Framebuffer Object is not complete and cannot be used"; break;

        // --- Vulkan Specific Errors (700-799) ---
        case SITUATION_ERROR_VULKAN_INIT_FAILED:          base_msg = "Vulkan: General initialization failed"; break;
        case SITUATION_ERROR_VULKAN_INSTANCE_FAILED:      base_msg = "Vulkan: Failed to create a VkInstance"; break;
        case SITUATION_ERROR_VULKAN_DEVICE_FAILED:        base_msg = "Vulkan: Failed to select a physical or create a logical device"; break;
        case SITUATION_ERROR_VULKAN_UNSUPPORTED:          base_msg = "Vulkan: A required layer, extension, or feature is unsupported"; break;
        case SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED:     base_msg = "Vulkan: A swapchain operation failed (creation, acquire, present)"; break;
        case SITUATION_ERROR_VULKAN_COMMAND_FAILED:       base_msg = "Vulkan: A command pool or buffer operation failed"; break;
        case SITUATION_ERROR_VULKAN_RENDERPASS_FAILED:    base_msg = "Vulkan: Failed to create a VkRenderPass"; break;
        case SITUATION_ERROR_VULKAN_FRAMEBUFFER_FAILED:   base_msg = "Vulkan: Failed to create a VkFramebuffer"; break;
        case SITUATION_ERROR_VULKAN_PIPELINE_FAILED:      base_msg = "Vulkan: Failed to create a graphics or compute pipeline"; break;
        case SITUATION_ERROR_VULKAN_SYNC_OBJECT_FAILED:   base_msg = "Vulkan: Failed to create a fence or semaphore"; break;
        case SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED:  base_msg = "Vulkan: A GPU memory allocation failed (VMA)"; break;
        case SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED:    base_msg = "Vulkan: A descriptor set or pool operation failed"; break;
    }

    if (detail) {
        snprintf(buffer, sizeof(buffer), "%s: %s", base_msg, detail);
    } else {
        strncpy(buffer, base_msg, sizeof(buffer) - 1);
    }
    buffer[sizeof(buffer) - 1] = '\0';
    _SituationSetError(buffer);
}

/**
 * @brief Retrieves a copy of the last error message generated by the library.
 * @details This function provides a way for the user application to obtain a detailed, human-readable description of the most recent error that occurred within the Situation library. This is essential for diagnosing problems and providing feedback to the user.
 *
 * @par Memory Management
 *   This function returns a *copy* of the internal error message string, allocating new memory for it.
 *   The caller takes ownership of this memory and **must** release it by calling `SituationFreeString()` when it is no longer needed. Failure to do so will result in a memory leak.
 *
 * @warning Do NOT use `free()` on the returned pointer. Always use `SituationFreeString()`.
 *
 * @return A null-terminated C string containing the last error message.
 * @return NULL if the library is not initialized, if no error has occurred, or if memory allocation for the copy fails.
 *
 * @see SituationFreeString(), _SituationSetError()
 */
SITAPI char* SituationGetLastErrorMsg(void) {
    // --- 1. Input/State Validation ---
    // Check if the library is initialized. Accessing sit_gs before init is unsafe.
    if (!sit_gs.is_initialized) {
        // No meaningful error state exists before initialization.
        return NULL;
    }

    // A mutex lock/unlock could be added here for perfect thread-safety if another thread could be setting an error while this one is reading.
    // For now, we assume this is called on the main thread shortly after an error.
    ma_mutex_lock(&sit_gs.error_mutex);

    // Check if the internal error message is empty.
    if (sit_gs.last_error_msg[0] == '\0') {
        ma_mutex_unlock(&sit_gs.error_mutex);
        return NULL; // No error message has been set.
    }

    // --- 2. Allocate Memory for the Copy ---
    // Determine the length of the internal error message.
    size_t msg_len = strlen(sit_gs.last_error_msg);
    
    // Allocate memory for the copy, including space for the null terminator.
    char* msg_copy = (char*)malloc(msg_len + 1);

    // --- 3. Handle Allocation Failure ---
    if (!msg_copy) {
        ma_mutex_unlock(&sit_gs.error_mutex);
        // Unable to allocate memory for the error string copy.
        // We can't return the error, but we also can't do much else.
        // Returning NULL is the only option.
        return NULL;
    }

    // --- 4. Copy the Error Message ---
    // Copy the string while the mutex is still held to prevent a data race.
    strcpy(msg_copy, sit_gs.last_error_msg);
    
    ma_mutex_unlock(&sit_gs.error_mutex);

    // --- 5. Return the Copy ---
    // The caller now owns this memory and is responsible for calling SituationFreeString().
    return msg_copy;
}

// --- Updated/Added Documentation Block for _SituationGLFWErrorCallback ---
/**
 * @brief [INTERNAL] GLFW error callback function.
 *
 * @details This function is registered with GLFW using `glfwSetErrorCallback`. It is called by GLFW whenever an internal error occurs within the GLFW library.
 *          This allows the Situation library to capture these errors, record them in its own error state, and potentially log them for debugging purposes.
 *
 * @param error An integer error code defined by GLFW (e.g., GLFW_NOT_INITIALIZED, GLFW_INVALID_VALUE, GLFW_PLATFORM_ERROR).
 * @param description A null-terminated string providing a human-readable description of the error.
 *
 * @note This function is for internal use by the Situation library and should not be called directly by user code.
 * @note This function modifies the global state `sit_gs.last_error_msg`.
 * @warning This function might be called asynchronously from within other GLFW functions (e.g., during `glfwPollEvents`). Therefore, it should be thread-safe. Using `_SituationSetError` (which likely just writes to `sit_gs.last_error_msg`) and `fprintf` to `stderr` is generally acceptable for this.
 *
 * @see SituationInit(), glfwSetErrorCallback(), _SituationSetError()
 */
static void _SituationGLFWErrorCallback(int error, const char* description) {
    // --- 1. Input Validation ---
    // While GLFW should provide valid inputs, checking is good practice.
    if (!description) {
        // Description is NULL. This is unusual but possible.
        // Use a default string to prevent crashes.
        description = "<no description provided by GLFW>";
    }

    // --- 2. Format the Error Message ---
    // Create a formatted message string that combines the GLFW error code
    // and its description for clarity and consistency with the library's error format.
    char err_buf[SITUATION_MAX_ERROR_MSG_LEN]; // Use the library's defined max length

    // Use snprintf for safer string formatting, preventing potential buffer overflows.
    // Cast `error` to unsigned int for consistent formatting across platforms.
    int written = snprintf(
        err_buf,
        sizeof(err_buf),
        "_SituationGLFWErrorCallback: GLFW Error (%d): %s",
        error,
        description
    );

    // --- 3. Handle Formatting Errors ---
    // Check if snprintf truncated the output or failed.
    if (written < 0 || (size_t)written >= sizeof(err_buf)) {
        // If snprintf failed or truncated, provide a fallback message.
        // This ensures *some* error is recorded, even if details are lost.
        snprintf(
            err_buf,
            sizeof(err_buf),
            "_SituationGLFWErrorCallback: GLFW Error (%d) - Error formatting failed or message too long. Original description started with: %.50s...",
            error,
            description // Use first 50 chars of description as a hint
        );
    }

    // --- 4. Store the Error in Global State ---
    // Update the library's global error state with the formatted message.
    // This makes the error retrievable via `SituationGetLastErrorMsg()`.
    // _SituationSetError simply copies the string into sit_gs.last_error_msg.
    _SituationSetError(err_buf);

    // --- 5. Debug Output ---
    // Print the error message immediately to stderr for visibility during
    // development and debugging. This provides instant feedback.
    // It's generally acceptable for an error callback to log to stderr.
    fprintf(stderr, "[SITUATION] [GLFW ERROR] %s\n", err_buf);
    // fflush(stderr); // Optional: Force immediate output if stderr is buffered.
}

/**
 * @brief [INTERNAL] GLFW callback function invoked when files are dropped onto the window.
 * @details This function is the primary handler for file drop events. It is registered with GLFW and called automatically when the user drags one or more files from their operating system and releases them over the application window.
 *
 * @par Dual-Mode Handling
 *   This callback serves two purposes, supporting both event-driven and polling-based APIs:
 *   1.  **Event-Driven:** If a user callback has been registered via `SituationSetFileDropCallback`, this function immediately invokes it, passing along the file count, paths, and user data.
 *   2.  **Polling-Based:** It then creates a deep copy of the file path list and stores it in the global state (`sit_gs.dropped_file_paths`). It also sets the `sit_gs.file_was_dropped_this_frame` flag. This allows the polling functions `SituationIsFileDropped()` and `SituationLoadDroppedFiles()` to work correctly.
 *
 * @param window The GLFW window that received the event (unused).
 * @param count The number of files that were dropped.
 * @param paths An array of null-terminated, UTF-8 encoded strings, where each string is the absolute path to a dropped file. The memory for this array is managed by GLFW and is only valid for the duration of the callback.
 *
 * @note This function is for internal use only and is registered during library initialization.
 *
 * @see SituationSetFileDropCallback(), SituationIsFileDropped(), SituationLoadDroppedFiles()
 */
static void _SituationGLFWFileDropCallback(GLFWwindow* window, int count, const char** paths) {
    (void)window;

    // --- First, handle the user-defined callback, if it exists ---
    if (sit_gs.file_drop_callback != NULL) {
        sit_gs.file_drop_callback(count, paths, sit_gs.file_drop_user_data);
    }

    // --- Now, handle the internal state for the polling API ---

    // Clear any previous list of dropped files
    if (sit_gs.dropped_file_paths != NULL) {
        for (int i = 0; i < sit_gs.dropped_file_count; i++) {
            free(sit_gs.dropped_file_paths[i]);
        }
        free(sit_gs.dropped_file_paths);
        sit_gs.dropped_file_paths = NULL;
        sit_gs.dropped_file_count = 0;
    }

    if (count > 0) {
        sit_gs.dropped_file_paths = (char**)malloc(count * sizeof(char*));
        if (sit_gs.dropped_file_paths == NULL) {
            sit_gs.dropped_file_count = 0;
            return; // Allocation failed
        }

        for (int i = 0; i < count; i++) {
            sit_gs.dropped_file_paths[i] = strdup(paths[i]);
            if (sit_gs.dropped_file_paths[i] == NULL) {
                // Allocation failed for one string, clean up what we have
                for (int j = 0; j < i; j++) free(sit_gs.dropped_file_paths[j]);
                free(sit_gs.dropped_file_paths);
                sit_gs.dropped_file_paths = NULL;
                sit_gs.dropped_file_count = 0;
                return;
            }
        }
        sit_gs.dropped_file_count = count;
        sit_gs.file_was_dropped_this_frame = true;
    }
}

/**
 * @brief [INTERNAL] GLFW callback function invoked for all keyboard key events.
 * @details This is the central processing point for all raw keyboard input. It is registered with GLFW and is called whenever a key is pressed, released, or repeats.
 *
 * @par State Management
 *   Upon invocation, this function updates several aspects of the internal keyboard state:
 *   - **Current State:** Updates the `sit_gs.keyboard.current_state` array, which is used by `SituationIsKeyDown()`.
 *   - **Event Flags:** Sets the `down_this_frame` or `up_this_frame` flags for the specific key, which are used by `SituationIsKeyPressed()` and `SituationIsKeyReleased()`.
 *   - **Event Queue:** On a key press, it pushes the key code onto a mutex-protected queue for consumption by `SituationGetKeyPressed()`.
 *   - **Modifier State:** It updates the global modifier flags (`sit_gs.keyboard.modifier_state`) for Shift, Ctrl, Alt, etc.
 *   - **Lock Key State:** It specifically tracks the state of lock keys like Caps Lock and Num Lock.
 *   - **Scroll Lock:** It manually toggles the internal `is_scroll_lock_on` flag, as this state is not provided as a standard modifier.
 *
 * It also dispatches the event to the optional user-registered key callback.
 *
 * @param window The GLFW window that received the event (unused).
 * @param key The keyboard key that was pressed or released (e.g., `GLFW_KEY_A`).
 * @param scancode The system-specific scancode of the key (unused).
 * @param action The key action (`GLFW_PRESS`, `GLFW_RELEASE`, `GLFW_REPEAT`).
 * @param mods A bitfield describing which modifier keys were held down.
 *
 * @note This function is for internal use only.
 * @warning Although GLFW may invoke this callback from a different thread in some theoretical configurations, this library's design assumes it is called synchronously during `SituationPollInputEvents()`.
 * The mutex is included as a robust safeguard for thread safety, preparing the library for future evolution.
 *
 * @see SituationPollInputEvents(), SituationSetKeyCallback()
 */
static void _SituationGLFWKeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods) {
    (void)window; (void)scancode; 
    if (key >= 0 && key <= GLFW_KEY_LAST) {
        if (action == GLFW_PRESS) {
            sit_gs.keyboard.current_state[key] = true;
            sit_gs.keyboard.down_this_frame[key] = true; // This happens before queue lock, generally fine as it's main thread context

            ma_mutex_lock(&sit_gs.sit_keyboard_event_queue_mutex); // Lock for queue
            if (sit_gs.keyboard.pressed_queue_count < SITUATION_KEY_QUEUE_MAX) {
                sit_gs.keyboard.pressed_queue[sit_gs.keyboard.pressed_queue_count++] = key;
            }
            if (key == SIT_KEY_SCROLL_LOCK) {
                sit_gs.keyboard.is_scroll_lock_on = !sit_gs.keyboard.is_scroll_lock_on;
            }
            ma_mutex_unlock(&sit_gs.sit_keyboard_event_queue_mutex); // Unlock queue

        } else if (action == GLFW_RELEASE) {
            sit_gs.keyboard.current_state[key] = false;
            sit_gs.keyboard.up_this_frame[key] = true;
        }
    }
    sit_gs.keyboard.modifier_state = mods;

    // Store the state of Caps Lock and Num Lock
    sit_gs.keyboard.lock_key_state = mods & (SIT_MOD_CAPS_LOCK | SIT_MOD_NUM_LOCK);
    
    if (sit_gs.keyboard.key_callback) { // User callback can be called outside the queue lock
        sit_gs.keyboard.key_callback(key, scancode, action, mods, sit_gs.keyboard.key_callback_user_data);
    }
}

/**
 * @brief [INTERNAL] GLFW callback function invoked for text input events.
 * @details This callback is specifically for handling character input, as opposed to raw key presses. GLFW calls this function with the Unicode codepoint of a character as it is typed, correctly handling keyboard layouts and modifier keys.
 *
 * Its sole responsibility is to push the received codepoint onto a thread-safe queue (`sit_gs.keyboard.char_queue`). This queue is then consumed by the public `SituationGetCharPressed()` function, providing a reliable way for applications to implement text entry fields.
 *
 * @param window The GLFW window that received the event (unused).
 * @param codepoint The Unicode codepoint of the character.
 *
 * @note This function is for internal use only.
 *
 * @see SituationGetCharPressed()
 */
static void _SituationGLFWCharCallback(GLFWwindow* window, unsigned int codepoint) {
    (void)window; // Unused parameter

    ma_mutex_lock(&sit_gs.sit_keyboard_event_queue_mutex);
    if (sit_gs.keyboard.char_queue_count < SITUATION_CHAR_QUEUE_MAX) {
        sit_gs.keyboard.char_queue[sit_gs.keyboard.char_queue_count++] = codepoint;
    }
    ma_mutex_unlock(&sit_gs.sit_keyboard_event_queue_mutex);
}

/**
 * @brief [INTERNAL] GLFW callback function invoked when the window gains or loses input focus.
 * @details This function is called by GLFW whenever the application window's focus state changes. It updates the internal focus state tracker (`sit_gs.current_window_focus_state`) and serves two main purposes:
 *          1.  It invokes the optional user-defined callback set via `SituationSetFocusCallback`.
 *          2.  It calls `SituationApplyCurrentProfileWindowState()` to automatically switch between the "active" and "inactive" window state profiles, allowing for behavior changes like pausing the game or reducing frame rate when the window is not focused.
 *
 * @param window The GLFW window that received the event (unused).
 * @param focused `GLFW_TRUE` if the window gained focus, `GLFW_FALSE` if it lost focus.
 *
 * @note This function is for internal use only.
 *
 * @see SituationSetFocusCallback(), SituationApplyCurrentProfileWindowState()
 */
static void _SituationGLFWWindowFocusCallback(GLFWwindow* window, int focused) {
    (void)window; // Unused
    bool has_focus = (focused == GLFW_TRUE);
    if (has_focus != sit_gs.current_window_focus_state) {
        sit_gs.current_window_focus_state = has_focus;
        if (sit_gs.focus_callback_fn) {
            sit_gs.focus_callback_fn(has_focus, sit_gs.focus_callback_user_ptr);
        }
        SituationApplyCurrentProfileWindowState();
    }
}

/**
 * @brief [INTERNAL] GLFW callback function invoked when the window is iconified (minimized) or restored.
 * @details This function is called by GLFW when the user minimizes or restores the application window. Its primary role is to automatically pause and resume the application to conserve system resources while it is not visible.
 *
 * It checks for a state change (e.g., from not-minimized to minimized) and calls `SituationPauseApp()` or `SituationResumeApp()` accordingly. It also calls `SituationApplyCurrentProfileWindowState()` to apply any state changes defined in the window profiles for the minimized state.
 *
 * @param window The GLFW window that received the event (unused).
 * @param iconified `GLFW_TRUE` if the window was minimized, `GLFW_FALSE` if it was restored.
 *
 * @note This function is for internal use only.
 *
 * @see SituationPauseApp(), SituationResumeApp()
 */
static void _SituationGLFWWindowIconifyCallback(GLFWwindow* window, int iconified) {
    (void)window; // Unused
    bool is_minimized_now = (iconified == GLFW_TRUE);
    if (is_minimized_now && !sit_gs.is_app_internally_paused && !sit_gs.was_minimized_last_frame) {
        SituationPauseApp();
    } else if (!is_minimized_now && sit_gs.is_app_internally_paused && sit_gs.was_minimized_last_frame) {
        SituationResumeApp();
    }
    sit_gs.was_minimized_last_frame = is_minimized_now;
    // Also apply window profile as minimization state might be part of it
    SituationApplyCurrentProfileWindowState();
}

/**
 * @brief [INTERNAL] GLFW callback function invoked when the window's framebuffer size changes.
 * @details This is the core handler for all resolution and DPI scaling changes. It is called by GLFW whenever the pixel dimensions of the window's rendering area are modified.
 *
 * @par Responsibilities & Backend Differences
 *   The function's primary responsibility is to update the library's internal state and trigger necessary backend-specific actions:
 *   1.  **State Update:** It updates the library's cached render dimensions (`sit_gs.main_window_width`/`height`) and sets the `was_window_resized_last_frame` flag for the polling API.
 *   2.  **OpenGL Backend:** It immediately updates the OpenGL state by calling `glViewport` and recalculating internal orthographic projection matrices. This is safe because OpenGL is an immediate-mode API.
 *   3.  **Vulkan Backend:** It **does not** perform any immediate resource recreation. Instead, it simply sets the `sit_gs.vk.framebuffer_resized` flag. This is a critical design choice, as recreating the Vulkan swapchain is a complex, blocking operation that cannot be safely performed inside an asynchronous callback. The main render loop will detect this flag and handle the recreation gracefully.
 *   4.  **User Callback:** Finally, it invokes the optional user-defined callback set via `SituationSetResizeCallback`, allowing the application to respond to the size change.
 *
 * @param window The GLFW window that received the event (unused).
 * @param width The new width of the framebuffer in pixels.
 * @param height The new height of the framebuffer in pixels.
 *
 * @note This function is for internal use only.
 *
 * @see SituationSetResizeCallback(), _SituationVulkanRecreateSwapchain()
 */
static void _SituationGLFWFramebufferSizeCallback(GLFWwindow* window, int width, int height) {
    (void)window;
    if (width == 0 || height == 0) return; // Window is minimized, do nothing for now

    // Update the library's internal window size tracking
    sit_gs.main_window_width = width;
    sit_gs.main_window_height = height;
    sit_gs.was_window_resized_last_frame = true;

#if defined(SITUATION_USE_OPENGL)
    // For OpenGL, we can immediately update the viewport and projection matrices.
    glViewport(0, 0, width, height);

    // Update orthographic projection matrix for Virtual Display compositing
    glm_ortho(0.0f, (float)width, (float)height, 0.0f, -1.0f, 1.0f, sit_gs.vd_ortho_projection);

    // Resize the texture used for advanced compositing
    if (sit_gs.composite_copy_texture_id != 0) {
        glBindTexture(GL_TEXTURE_2D, sit_gs.composite_copy_texture_id);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
        glBindTexture(GL_TEXTURE_2D, 0);
    }

    // Update the projection matrix for the internal quad renderer.
    if (sit_gs.quad_shader_program) {
        mat4 proj_quad;
        glm_ortho(0.0f, (float)width, (float)height, 0.0f, -1.0f, 1.0f, proj_quad);
        glProgramUniformMatrix4fv(sit_gs.quad_shader_program, SIT_UNIFORM_LOC_PROJECTION_MATRIX, 1, GL_FALSE, (const GLfloat*)proj_quad);
    }

#elif defined(SITUATION_USE_VULKAN)
    // For Vulkan, we CANNOT recreate the swapchain here because this callback can be called from within other functions (like glfwPollEvents) and
    // we must not interrupt the main loop.
    // Instead, we just set a flag to be handled at the start of the next frame.
    sit_gs.vk.framebuffer_resized = true;
#endif

    // --- Call user-defined resize callback ---
    if (sit_gs.resize_callback != NULL) {
        sit_gs.resize_callback(width, height, sit_gs.resize_callback_user_data);
    }
    
}


// Mouse GLFW Callback Implementations
/**
 * @brief [INTERNAL] GLFW callback for mouse button events.
 * @details This function is called by GLFW's event processing thread whenever a mouse button is pressed or released. It is responsible for updating the library's internal mouse state in a thread-safe manner.
 *
 * @par Thread Safety
 *   All modifications to the shared `sit_gs.mouse` state are protected by a mutex. This prevents race conditions where the main application thread might read incomplete or inconsistent state while this callback is executing.
 *   The user-defined callback is intentionally called *after* the mutex is unlocked to prevent potential deadlocks if the user's code also performs locking.
 *
 * @param window The GLFW window that received the event (unused).
 * @param button The mouse button that was pressed or released (e.g., GLFW_MOUSE_BUTTON_LEFT).
 * @param action The button action (GLFW_PRESS or GLFW_RELEASE).
 * @param mods Bit field describing which modifier keys were held down.
 */
static void _SituationGLFWMouseButtonCallback(GLFWwindow* window, int button, int action, int mods) {
    (void)window; // Unused parameter

    // --- State Update (Thread-Safe) ---
    ma_mutex_lock(&sit_gs.mouse.mutex);
    {
        // Validate the button code to prevent out-of-bounds array access.
        if (button >= 0 && button <= GLFW_MOUSE_BUTTON_LAST) {
            if (action == GLFW_PRESS) {
                sit_gs.mouse.current_button_state[button] = true;
                sit_gs.mouse.button_down_this_frame[button] = true;

                // Add to the button press event queue if there is space.
                if (sit_gs.mouse.button_queue_count < SITUATION_KEY_QUEUE_MAX) {
                    sit_gs.mouse.button_queue[sit_gs.mouse.button_queue_count++] = button;
                }
            } else if (action == GLFW_RELEASE) {
                sit_gs.mouse.current_button_state[button] = false;
                sit_gs.mouse.button_up_this_frame[button] = true;
            }
        }
    }
    ma_mutex_unlock(&sit_gs.mouse.mutex);

    // --- User Callback (Outside of Lock) ---
    // Call the user's registered callback, if any. This is done outside the critical section to avoid potential deadlocks in the user's application.
    if (sit_gs.mouse.button_callback) {
        sit_gs.mouse.button_callback(button, action, mods, sit_gs.mouse.button_callback_user_data);
    }
}

/**
 * @brief [INTERNAL] GLFW callback for mouse cursor movement events.
 * @details This function is called by GLFW whenever the cursor moves over the window. It updates the internal `current_pos` state in a thread-safe manner.
 *
 * @par Thread Safety
 *   The update to `sit_gs.mouse.current_pos` is protected by a mutex to prevent data tearing if another thread reads the position while it is being updated. The user-defined callback is called after the lock is released.
 *
 * @param window The GLFW window that received the event (unused).
 * @param xpos The new cursor x-coordinate, relative to the left edge of the content area.
 * @param ypos The new cursor y-coordinate, relative to the top edge of the content area.
 */
static void _SituationGLFWCursorPosCallback(GLFWwindow* window, double xpos, double ypos) {
    (void)window; // Unused parameter

    // --- State Update (Thread-Safe) ---
    ma_mutex_lock(&sit_gs.mouse.mutex);
    {
        sit_gs.mouse.current_pos[0] = (float)xpos;
        sit_gs.mouse.current_pos[1] = (float)ypos;
    }
    ma_mutex_unlock(&sit_gs.mouse.mutex);

    // --- User Callback (Outside of Lock) ---
    if (sit_gs.mouse.cursor_pos_callback) {
        vec2 pos = {(float)xpos, (float)ypos};
        sit_gs.mouse.cursor_pos_callback(pos, sit_gs.mouse.cursor_pos_callback_user_data);
    }
}

/**
 * @brief [INTERNAL] GLFW callback for mouse wheel scroll events.
 * @details This function is called by GLFW when a scrolling device is used. It accumulates scroll offsets in a thread-safe manner, as multiple scroll events can fire within a single frame.
 *
 * @par Thread Safety
 *   The accumulation of scroll offsets into `sit_gs.mouse.wheel_move_x/y` is protected by a mutex to ensure atomic updates. The user-defined callback is called after the lock is released.
 *
 * @param window The GLFW window that received the event (unused).
 * @param xoffset The scroll offset along the x-axis.
 * @param yoffset The scroll offset along the y-axis.
 */
static void _SituationGLFWScrollCallback(GLFWwindow* window, double xoffset, double yoffset) {
    (void)window; // Unused parameter

    // --- State Update (Thread-Safe) ---
    ma_mutex_lock(&sit_gs.mouse.mutex);
    {
        // Accumulate scroll offsets, as multiple events can occur per frame.
        sit_gs.mouse.wheel_move_x += (float)xoffset;
        sit_gs.mouse.wheel_move_y += (float)yoffset;
    }
    ma_mutex_unlock(&sit_gs.mouse.mutex);

    // --- User Callback (Outside of Lock) ---
    if (sit_gs.mouse.scroll_callback) {
        // Pass the per-event offset directly to the user callback.
        vec2 offset = {(float)xoffset, (float)yoffset};
        sit_gs.mouse.scroll_callback(offset, sit_gs.mouse.scroll_callback_user_data);
    }
}

#if defined(SITUATION_USE_OPENGL)
/**
 * @brief [INTERNAL] Checks for and logs any pending OpenGL errors.
 *
 * @details This helper function polls the OpenGL error state using `glGetError()` in a loop, processing each error individually until no more errors are reported (`GL_NO_ERROR` is returned).
 *          For each error found, it formats a message including the provided `location` string and the `GLenum` error code, then stores this message in the library's global error state using `_SituationSetErrorFromCode`.
 *          Unlike `_SituationLogGLError`, this function does *not* automatically print errors to `stderr`. It is designed for cases where you want to check for errors and record them silently, without immediate console output.
 *          It's also typically used with a fixed location string rather than dynamic file/line information.
 *
 * @param location A descriptive string indicating *where* this error check is being performed (e.g., "Post-BindBuffer", "After Shader Compilation"). This helps identify the context of the error when retrieving the message later.
 *
 * @note This function should generally not be called directly by user code.
 *       It's an internal utility, often used in specific scenarios or potentially by a different error-checking macro.
 * @note Calling `glGetError()` clears the error flag. Therefore, if multiple OpenGL errors occur in sequence, this function (via the loop) ensures that *all* pending errors are retrieved and logged (to the global state), not just the first one.
 * @warning This function overwrites the library's last error message with the *most recently processed* OpenGL error from the sequence of errors.
 *          If multiple errors are pending, only the details of the last one checked in the loop will remain in `sit_gs.last_error_msg` after the function completes.
 * @warning Unlike `_SituationLogGLError`, this function does *not* print to `stderr`, even in debug builds.
 *
 * @see _SituationLogGLError(), _SituationSetErrorFromCode(), SituationGetLastErrorMsg()
 */
static void _SituationCheckGLError(const char* location) {
    // --- 1. Input Validation ---
    // While internal, checking for NULL location prevents potential crashes or garbage data if called incorrectly.
    if (!location) {
        location = "<unknown_location>"; // Provide a default if location is missing
    }

    // --- 2. Poll and Process OpenGL Errors ---
    GLenum err;
    // Loop as long as glGetError reports an error (not GL_NO_ERROR).
    // This handles cases where multiple errors might be queued.
    while ((err = glGetError()) != GL_NO_ERROR) {
        // --- 3. Format Error Message ---
        // Create a message including the location context and the raw error code.
        // Use a sufficiently large buffer to hold the formatted string.
        char detail[SITUATION_MAX_ERROR_MSG_LEN]; // Use the library's defined max length
        // Use snprintf for safer string formatting, preventing buffer overflows.
        int written = snprintf(
            detail,
            sizeof(detail),
            "_SituationCheckGLError: OpenGL Error at '%s': 0x%X",
            location,
            (unsigned int)err // Cast to unsigned int for consistent formatting
        );

        // --- 4. Handle Formatting Errors ---
        // Check if snprintf truncated the output or failed.
        if (written < 0 || (size_t)written >= sizeof(detail)) {
            // If snprintf failed or truncated, provide a fallback message.
            snprintf(
                detail,
                sizeof(detail),
                "_SituationCheckGLError: Error formatting failed for check at '%s', original code was 0x%X",
                location,
                (unsigned int)err
            );
        }

        // --- 5. Store Error in Global State ---
        // Update the library's global error state with the detailed message.
        // This makes the error retrievable via SituationGetLastErrorMsg().
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_GENERAL, detail);

        // Note: Unlike _SituationLogGLError, there is no fprintf to stderr here.
        // The error is only stored in the global state.
    }
    // --- 6. Loop Exit ---
    // The loop exits when glGetError() returns GL_NO_ERROR, indicating the OpenGL error queue is now empty (or was empty to begin with).
}

/**
 * @brief [INTERNAL] Logs OpenGL errors detected by `glGetError`.
 *
 * @details This helper function is the core implementation used by the `SIT_CHECK_GL_ERROR` macro. It polls the OpenGL error state using `glGetError()` in a loop, processing each error individually until no more errors are reported (`GL_NO_ERROR` is returned).
 *          For each error found, it translates the `GLenum` error code into a human-readable string, formats a detailed message including the source file and line number where the check occurred, and stores this message in the library's global error state using `_SituationSetErrorFromCode`.
 *          This ensures that `SituationGetLastErrorMsg()` will return the most recent OpenGL error details.
 *          In debug builds (when `NDEBUG` is not defined), it also prints the error message to `stderr`. This immediate feedback is invaluable during development and debugging.
 *
 * @param file The source code file name where the error check was triggered.
 *             This is typically provided by the `__FILE__` macro.
 * @param line The line number within the source code file where the error check was triggered. This is typically provided by the `__LINE__` macro.
 *
 * @note This function should generally not be called directly by user code.
 *       Instead, use the `SIT_CHECK_GL_ERROR()` macro, which automatically provides the `file` and `line` parameters.
 * @note Calling `glGetError()` clears the error flag. Therefore, if multiple OpenGL errors occur in sequence, this function (via the loop) ensures that *all* pending errors are retrieved and logged, not just the first one.
 * @warning This function overwrites the library's last error message with the *most recently processed* OpenGL error from the sequence of errors.
 *          If multiple errors are pending, only the details of the last one checked in the loop will remain in `sit_gs.last_error_msg` after the function completes. However, all errors will have been logged to `stderr` in debug builds.
 *
 * @see SIT_CHECK_GL_ERROR(), _SituationSetErrorFromCode(), SituationGetLastErrorMsg()
 */
static void _SituationLogGLError(const char* file, int line) {
    // --- 1. Input Validation ---
    // While internal, checking for NULL file prevents potential crashes
    // or garbage data if called incorrectly.
    if (!file) {
        file = "<unknown_file>"; // Provide a default if file name is missing
    }

    // --- 2. Poll and Process OpenGL Errors ---
    GLenum err;
    // Loop as long as glGetError reports an error (not GL_NO_ERROR).
    // This handles cases where multiple errors might be queued.
    while ((err = glGetError()) != GL_NO_ERROR) {
        // --- 3. Translate Error Code to String ---
        const char* err_str = "UNKNOWN_ERROR";
        // Map the GLenum error code to a descriptive string.
        switch (err) {
            case GL_INVALID_ENUM:                  err_str = "GL_INVALID_ENUM"; break;
            case GL_INVALID_VALUE:                 err_str = "GL_INVALID_VALUE"; break;
            case GL_INVALID_OPERATION:             err_str = "GL_INVALID_OPERATION"; break;
            case GL_STACK_OVERFLOW:                err_str = "GL_STACK_OVERFLOW"; break;
            case GL_STACK_UNDERFLOW:               err_str = "GL_STACK_UNDERFLOW"; break;
            case GL_OUT_OF_MEMORY:                 err_str = "GL_OUT_OF_MEMORY"; break;
            case GL_INVALID_FRAMEBUFFER_OPERATION: err_str = "GL_INVALID_FRAMEBUFFER_OPERATION"; break;
            // Note: Other error codes like GL_CONTEXT_LOST are part of newer
            // OpenGL versions/profiles and could be added if needed.
        }

        // --- 4. Format Detailed Error Message ---
        // Create a comprehensive message including the error, location, and code.
        // Use a sufficiently large buffer to hold the formatted string.
        char detail[SITUATION_MAX_ERROR_MSG_LEN]; // Use the library's defined max length Use snprintf for safer string formatting, preventing buffer overflows.
        int written = snprintf(
            detail,
            sizeof(detail),
            "OpenGL Error (%s:%d): %s (0x%X)",
            file,
            line,
            err_str,
            (unsigned int)err // Cast to unsigned int for consistent formatting
        );

        // --- 5. Handle Formatting Errors ---
        // Check if snprintf truncated the output or failed.
        if (written < 0 || (size_t)written >= sizeof(detail)) {
            // If snprintf failed or truncated, provide a fallback message.
            snprintf(
                detail,
                sizeof(detail),
                "OpenGL Error (%s:%d): Error formatting failed, original code was 0x%X",
                file,
                line,
                (unsigned int)err
            );
        }

        // --- 6. Store Error in Global State ---
        // Update the library's global error state with the detailed message.
        // This makes the error retrievable via SituationGetLastErrorMsg().
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_GENERAL, detail);

        // --- 7. Debug Output ---
        // In debug builds, print the error immediately to stderr for visibility.
#ifndef NDEBUG
        fprintf(stderr, "[DEBUG] %s\n", sit_gs.last_error_msg);
#endif
        // Note: In release builds, the error is still stored in sit_gs.last_error_msg but not printed to stderr automatically by this function.
    }
    // --- 8. Loop Exit ---
    // The loop exits when glGetError() returns GL_NO_ERROR, indicating the OpenGL error queue is now empty (or was empty to begin with).
}
#endif

/**
 * @brief [INTERNAL] Performs a comprehensive cleanup of all partially initialized library components.
 *
 * @details This helper function is a critical part of the library's robust initialization and error handling strategy. It is designed to be called safely from *any* point during the `SituationInit` process if a critical error occurs.
 *
 * Its primary role is to prevent resource leaks and ensure a clean state in the event of a failed startup. It achieves this by:
 * 1.  Attempting to flush any pending GPU operations to ensure resources are no longer in use.
 * 2.  Calling the main cleanup functions for subsystems, the renderer, and the platform layer, *in reverse order* of their initialization.
 * 3.  Relying on the robustness of these individual cleanup functions to handle being called when only parts of their corresponding initialization were completed.
 *
 * @note This function is intended solely for internal use during the `SituationInit` failure path and should not be called directly by user code under normal circumstances.
 * @note The cleanup proceeds in reverse order of initialization:
 *       Platform -> Renderer -> Subsystems. This order is crucial to avoid dependencies (e.g., destroying GLFW window before Vulkan surface).
 * @note Each `_SituationCleanup*` function called is designed to check if its corresponding component was initialized before attempting to destroy it, making this "best-effort" cleanup safe.
 * @warning This function modifies the global state `sit_gs`. After it runs, the library is considered uninitialized.
 *
 * @see SituationInit(), _SituationCleanupSubsystems(), _SituationCleanupRenderer(), _SituationCleanupPlatform()
 */
static void _SituationFullCleanupOnError(void) {
    // --- 1. Synchronize GPU ---
    // Before attempting to destroy any graphics resources, it's prudent to wait for the GPU to finish any operations that might be using them.
    // This helps prevent validation errors or crashes during cleanup, especially if the error occurred partway through renderer initialization.
#if defined(SITUATION_USE_VULKAN)
    {
        // For Vulkan, wait for the logical device to be idle.
        // This ensures all submitted work on all queues is finished.
        // It's safe to call this even if the device creation failed, as sit_gs.vk.device would be VK_NULL_HANDLE.
        if (sit_gs.vk.device != VK_NULL_HANDLE) {
            VkResult result = vkDeviceWaitIdle(sit_gs.vk.device);
            // Ignore the result. If it fails, proceeding with cleanup is still the best option.
            // Potential failures (VK_ERROR_DEVICE_LOST) indicate a serious problem, but cleanup should still be attempted to free other resources (GLFW, audio context).
            if (result != VK_SUCCESS) {
                // Optional: Log in debug builds if a logger is available.
                // fprintf(stderr, "WARNING: vkDeviceWaitIdle failed (0x%x) during error cleanup.\n", result);
            }
        }
    }
#elif defined(SITUATION_USE_OPENGL)
    {
        // For OpenGL, if a context was made current (indicated by a valid window and the context being current on this thread), force the GPU to finish.
        // This is a coarse synchronization but can help ensure buffer/object deletion is safe. It stalls the GPU pipeline.
        // Note: glfwGetCurrentContext() could also be used for a more precise check.
        if (sit_gs.sit_glfw_window != NULL) {
            // Ensure the context is current before calling glFinish.
            // This is generally safe as SituationInit sets up the context.
            glfwMakeContextCurrent(sit_gs.sit_glfw_window);
            glFinish(); // This is a blocking call. Consider glFlush() for less blocking?
            // glFinish ensures all previously issued GL commands are complete.
            // Note: Errors during init might mean the context is in a bad state, but calling glFinish is still generally safe.
        }
    }
#endif // SITUATION_USE_OPENGL

    // --- 2. Cleanup in Reverse Order of Initialization ---
    // It's crucial to destroy components in the reverse order they were initialized to respect dependencies (e.g., don't destroy the window before the Vulkan surface).

    // --- 2a. Cleanup Subsystems ---
    // This cleans up audio, input, timer systems, etc.
    // It should be safe to call even if subsystem init failed partway through.
    _SituationCleanupSubsystems();

    // --- 2b. Cleanup Renderer ---
    // This cleans up all graphics API specific resources (Vulkan instance/device/swapchain, OpenGL context/states, internal pipelines, etc.).
    // It must be robust enough to handle partial initialization (e.g., if Vulkan device creation failed but instance was created).
    _SituationCleanupRenderer();

    // --- 2c. Cleanup Platform ---
    // This cleans up the lowest level components: GLFW window, GLFW itself, any platform-specific initializations (like COM on Windows).
    // This should be the final step.
    _SituationCleanupPlatform();

    // --- 3. Post-Cleanup State (Implicit) ---
    // The individual cleanup functions (_SituationCleanupPlatform in particular) should set `sit_gs.is_initialized = false;` and potentially clear the error state.
    // This function itself doesn't need to modify `sit_gs` further.
    // The library is now in an uninitialized state, ready (hopefully) for a fresh `SituationInit` attempt or safe shutdown.
}

//----------------------------------------------------------------------------------------------------------
// --- Core Lifecycle Implementation ---
//----------------------------------------------------------------------------------------------------------

/**
 * @brief Initializes the entire Situation library.
 *
 * @details This is the main entry point and the first function a user of the library must call. It orchestrates the complete initialization process by setting up all necessary subsystems in a specific, dependency-respecting order:
 * 1.  **Platform:** Initializes low-level libraries like GLFW.
 * 2.  **Window:** Creates the main application window.
 * 3.  **Renderer:** Initializes the selected graphics backend (OpenGL or Vulkan), including contexts/devices, swapchains, internal pipelines, etc.
 * 4.  **Subsystems:** Initializes audio, input handling, timer system, filesystem utilities, and other core functionalities.
 *
 * If any step in this sequence fails, the function triggers a comprehensive cleanup process (`_SituationFullCleanupOnError`) to ensure that no resources
 * are leaked and the library is left in a clean, uninitialized state.
 *
 * @param argc The number of command-line arguments, including the program name.
 *             This is typically the `argc` parameter from the `main` function.
 * @param argv An array of strings representing the command-line arguments.
 *             This is typically the `argv` parameter from the `main` function.
 *             The library stores these for later querying via argument functions.
 * @param init_info A pointer to a `SituationInitInfo` struct containing all necessary configuration options for the library's initialization (e.g., window title, dimensions, initial flags).
 *                  This pointer must not be NULL.
 *
 * @return SITUATION_SUCCESS on successful initialization of all subsystems.
 * @return SITUATION_ERROR_INVALID_PARAM if `init_info` is NULL.
 * @return SITUATION_ERROR_ALREADY_INITIALIZED if `SituationInit` is called more than once without an intervening `SituationShutdown`.
 * @return SITUATION_ERROR_INIT_FAILED if any part of the initialization sequence fails (e.g., GLFW failure, graphics context creation failure,
 *         audio device failure). A specific error code and message will be set by the failing subsystem's initialization function. Cleanup is attempted.
 * @return SITUATION_ERROR_SHUTDOWN_FAILED if a previous call to `SituationShutdown` failed and left the library in an inconsistent state, preventing re-initialization.
 *         This is a safeguard to avoid attempting initialization from a bad state.
 *
 * @note This function must be called before any other `SITAPI` functions (except potentially other init/shutdown functions).
 * @note The library is designed to be initialized and shut down once per application run. While re-initialization after a successful shutdown
 *       is intended to work, it's generally recommended to structure the application's main lifecycle around a single init/shutdown pair.
 * @warning This function is not thread-safe. It must be called from the main thread of the application.
 *
 * @see SituationShutdown(), SituationInitInfo, SituationGetLastErrorMsg()
 */
SITAPI SituationError SituationInit(int argc, char** argv, const SituationInitInfo* init_info) {
    // --- 1. PRE-INITIALIZATION CHECKS ---
    // Ensure the library isn't already initialized to prevent conflicts.
    if (sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_ALREADY_INITIALIZED, "SituationInit: Library is already initialized.");
        return SITUATION_ERROR_ALREADY_INITIALIZED;
    }

    // Ensure the required initialization configuration struct is provided.
    if (!init_info) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "SituationInit: init_info cannot be NULL.");
        return SITUATION_ERROR_INVALID_PARAM;
    }

    // Guard against re-initialization if a previous shutdown failed.
    // If the global state indicates a shutdown failure, re-init is risky.
    // The SITUATION_ERROR_SHUTDOWN_FAILED code is used here to signal this.
    // This requires sit_gs.last_error_code to be checked, assuming it retains the error code from the last operation.
    // A more robust way might be a dedicated flag, but using the error code is common.
    // Let's assume a clean state means last_error_code is SITUATION_SUCCESS or the state is fully zeroed. If shutdown failed, the error code might be left.
    // However, the memset below will clear it. Let's reconsider.
    //
    // A simpler and more direct check: if the struct was not fully cleaned up after a failed shutdown, it might have flags set or pointers.
    // The safest approach is to always zero the state at the start of init.
    //
    // Zero out the *entire* global state container to ensure a clean slate.
    // This is crucial for preventing issues from previous runs or failed shutdowns.
    memset(&sit_gs, 0, sizeof(_SituationGlobalStateContainer));
    // After memset, sit_gs.is_initialized is false, and all pointers are NULL.
    // sit_gs.last_error_code is also 0 (SITUATION_SUCCESS).

    // --- 2. INITIALIZE CORE PLATFORM & WINDOW ---
    // These steps are prerequisites for renderer and subsystem initialization.
    // They are common to both OpenGL and Vulkan backends.

    // 2a. Initialize platform-specific components (GLFW, COM on Windows, etc.).
    SituationError err = _SituationInitPlatform();
    if (err != SITUATION_SUCCESS) {
        // Platform initialization failed. No major resources have been allocated yet
        // by the library itself (GLFW might have allocated some internal stuff, but _SituationInitPlatform should clean that up on failure).
        // Therefore, a full cleanup is not strictly necessary here, but calling it for consistency and to ensure any partial platform setup is undone is good.
        // However, the previous version comment said "No need to call FullCleanup...", which is also a valid viewpoint for this very early failure.
        // Let's stick to the original logic for this specific early failure point, but document it clearly.
        // _SituationFullCleanupOnError(); // Not needed for platform-only failure
        return err; // Return the specific error from platform init.
    }

    // 2b. Create the main application window using GLFW.
    err = _SituationInitWindow(init_info);
    if (err != SITUATION_SUCCESS) {
        // Window creation failed. Platform was initialized, so cleanup is needed.
        _SituationFullCleanupOnError(); // Clean up platform (GLFW)
        return err; // Return the specific error from window init.
    }

    // --- 3. INITIALIZE THE CHOSEN RENDERER ---
    // Dispatch to the backend-specific initialization (OpenGL or Vulkan).
    // This is a major step involving context/device creation, swapchains, etc.
    err = _SituationInitRenderer(init_info);
    if (err != SITUATION_SUCCESS) {
        // Renderer initialization failed. Platform and Window were initialized.
        _SituationFullCleanupOnError(); // Clean up platform, window, and any partial renderer state
        return err; // Return the specific error from renderer init.
    }

    // --- 4. INITIALIZE OTHER LIBRARY SUBSYSTEMS ---
    // Initialize audio, input, timers, filesystem utils, etc.
    // These often depend on the window and renderer being available.
    err = _SituationInitSubsystems();
    if (err != SITUATION_SUCCESS) {
        // Subsystem initialization failed. Platform, Window, and Renderer were initialized.
        _SituationFullCleanupOnError(); // Clean up everything initialized so far
        return err; // Return the specific error from subsystems init.
    }

    // --- 5. FINAL STATE SETUP ---
    // Perform any final configuration steps that require all subsystems to be ready.
    // This happens only after all preceding steps have succeeded.

    // Cache information about physical displays connected to the system.
    _SituationCachePhysicalDisplays(); // Result checked internally/during queries

    // Determine the initial focus and minimization state of the created window.
    // This sets up the initial window state profiles.
    if (sit_gs.sit_glfw_window) { // Defensive check, should be valid here
        sit_gs.current_window_focus_state = (glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_FOCUSED) == GLFW_TRUE);
        sit_gs.was_minimized_last_frame = (glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_ICONIFIED) == GLFW_TRUE);
        // Apply the initial window state profile based on focus.
        SituationApplyCurrentProfileWindowState();
    } // else? This would be an unexpected state if window init succeeded.

    // --- Store Command-Line Arguments ---
    // Save the argc/argv for later access via SituationGetArgument* functions.
    sit_gs.argc = argc;
    sit_gs.argv = argv; // Store the pointer. The application must keep argv alive.

    // --- 6. Mark as Successfully Initialized ---
    // All steps completed successfully. Set the global initialized flag.
    sit_gs.is_initialized = true;

    // Clear any lingering error message and set a success indicator.
    _SituationSetError("SituationInit: No error. Initialization successful.");

    // --- 7. Return Success ---
    return SITUATION_SUCCESS;
}

/**
 * @brief [INTERNAL] Initializes platform-specific libraries and components.
 *
 * This helper function is the very first step in the `SituationInit` process.
 * It is responsible for setting up the foundational, low-level libraries that the rest of the library depends on, primarily GLFW for windowing and input.
 * It also handles any platform-specific initializations required.
 *
 * On Windows, this includes initializing the Component Object Model (COM) library, which is necessary for certain APIs (like file system operations
 * using `SHGetKnownFolderPath`).
 *
 * The function also sets up the GLFW error callback (`_SituationGLFWErrorCallback`) to capture and report any errors originating
 * from GLFW during the initialization process or later library operations.
 *
 * @return SITUATION_SUCCESS on successful initialization of all required platform components.
 * @return SITUATION_ERROR_COM_FAILED if COM initialization fails on Windows (and the error is not `RPC_E_CHANGED_MODE`, which is tolerated).
 * @return SITUATION_ERROR_GLFW_FAILED if `glfwInit` fails to initialize the GLFW library. A specific error message is set by the GLFW error
 *         callback or this function.
 *
 * @note This function must be called before any other platform-dependent operations (like window creation or Vulkan instance creation).
 * @note If this function fails, it attempts to undo any partial initializations it performed (e.g., calling `CoUninitialize` on Windows if COM was initialized).
 * @warning This function is for internal use by `SituationInit` and should not be called directly by user code.
 *
 * @see SituationInit(), _SituationGLFWErrorCallback(), _SituationCleanupPlatform(), glfwInit(), glfwSetErrorCallback()
 */
static SituationError _SituationInitPlatform(void) {
    // --- 1. Platform-Specific Initializations ---

#if defined(_WIN32)
    {
        // --- 1a. Initialize COM (Windows only) ---
        // COM is needed for various Windows APIs, particularly for filesystem operations like getting user directories (SHGetKnownFolderPath).
        // We initialize it in Apartment-Threaded mode, which is suitable for most single-threaded applications like this library.
        // COINIT_DISABLE_OLE1DDE disables legacy OLE1 DDE, which is recommended.
        HRESULT com_hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);

        if (SUCCEEDED(com_hr)) {
            // COM was successfully initialized for this thread.
            sit_gs.is_com_initialized = true;
        } else if (com_hr == RPC_E_CHANGED_MODE) {
            // COM was already initialized for this thread, but in a different mode (e.g., Multi-Threaded). This is not ideal but often workable.
            // We do not set sit_gs.is_com_initialized to true in this case, as we didn't perform the initialization ourselves.
            // The library will proceed, but the user should be aware of potential threading model conflicts if they also use COM directly.
            // Log a warning in debug builds if a logger is available.
            // fprintf(stderr, "WARNING: COM already initialized in a different mode (RPC_E_CHANGED_MODE).\n");
            // It's generally safer not to call CoUninitialize() if we didn't CoInitializeEx().
            sit_gs.is_com_initialized = false;
        } else {
            // COM initialization failed with an unexpected error code.
            // This is a critical failure for Windows platform setup.
            _SituationSetErrorFromCode(
                SITUATION_ERROR_COM_FAILED,
                "_SituationInitPlatform: CoInitializeEx failed unexpectedly."
            );
            // No cleanup needed for COM itself, as it failed to initialize.
            // Proceed to return the error.
            return SITUATION_ERROR_COM_FAILED;
        }
    }
#endif // defined(_WIN32)

    // --- 2. Initialize GLFW ---
    // Set the error callback *before* calling glfwInit.
    // This ensures that any errors occurring during glfwInit (or later GLFW calls) are captured and reported via our custom callback function.
    glfwSetErrorCallback(_SituationGLFWErrorCallback);

    // Attempt to initialize the GLFW library.
    if (!glfwInit()) {
        // glfwInit failed. This is a critical failure for window and input management.
        // A more detailed error message should have been captured by _SituationGLFWErrorCallback and stored in sit_gs.last_error_msg.
        _SituationSetErrorFromCode(
            SITUATION_ERROR_GLFW_FAILED,
            "_SituationInitPlatform: glfwInit failed. Check previous GLFW error message or system configuration."
        );

        // --- 3. Cleanup Partial Initializations ---
        // Since glfwInit failed, we need to undo any platform-specific initializations that were successfully performed *before* this point.
#if defined(_WIN32)
        // If COM was successfully initialized by us in step 1, uninitialize it.
        if (sit_gs.is_com_initialized) {
            CoUninitialize();
            sit_gs.is_com_initialized = false; // Reset the flag
        }
#endif // defined(_WIN32)
        // Note: There are no other initializations before glfwInit in this function that require cleanup on its failure.

        // --- 4. Return Error ---
        return SITUATION_ERROR_GLFW_FAILED;
    }

    // --- 5. Success ---
    // If we reach here, both platform-specific initializations (COM on Windows) and GLFW initialization were successful.
    // The next step in the SituationInit sequence is typically _SituationInitWindow.
    return SITUATION_SUCCESS;
}

/**
 * @brief [INTERNAL] Creates the main application window using GLFW.
 *
 * @details This helper function is responsible for the final step of the platform initialization phase. It configures GLFW window hints based on the selected graphics backend (OpenGL or Vulkan) and the user-provided `SituationInitInfo`, then attempts to create the GLFW window.
 *
 * @param init_info A pointer to the `SituationInitInfo` struct provided during `SituationInit`. This contains the desired initial window dimensions, title, and state flags.
 *                  This pointer must not be NULL.
 *
 * @return SITUATION_SUCCESS on successful creation of the GLFW window.
 * @return SITUATION_ERROR_INVALID_PARAM if `init_info` is NULL.
 * @return SITUATION_ERROR_GLFW_FAILED if `glfwCreateWindow` fails to create the window. This can happen due to invalid dimensions, inability
 *         to find a suitable framebuffer configuration, or OS-level window creation failures. A specific error message is set.
 *
 * @note This function must be called after `_SituationInitPlatform` (which initializes GLFW) but before renderer-specific initialization.
 * @note The created `GLFWwindow` handle is stored in `sit_gs.sit_glfw_window`.
 * @note Window state flags from `init_info` are stored in `sit_gs.active_profile_window_flags` and
 *       `sit_gs.inactive_profile_window_flags` for later use by the window state management system.
 * @warning This function relies on GLFW being successfully initialized.
 *          It also assumes that the graphics backend has been chosen (via `SITUATION_USE_OPENGL` or `SITUATION_USE_VULKAN`) so that the correct window hints can be set.
 *
 * @see _SituationInitPlatform(), _SituationInitRenderer(), SituationInitInfo, SituationInit()
 */
static SituationError _SituationInitWindow(const SituationInitInfo* init_info) {
    // --- 1. Input Validation ---
    // Check if the required initialization info struct is provided.
    if (!init_info) {
        _SituationSetErrorFromCode(
            SITUATION_ERROR_INVALID_PARAM,
            "_SituationInitWindow: init_info cannot be NULL."
        );
        return SITUATION_ERROR_INVALID_PARAM;
    }

    // --- 2. Determine Initial Window Dimensions ---
    // Set default window dimensions if invalid values are provided in init_info.
    // This prevents glfwCreateWindow from failing due to zero or negative sizes.
    sit_gs.main_window_width = (init_info->window_width > 0) ? init_info->window_width : 1280;
    sit_gs.main_window_height = (init_info->window_height > 0) ? init_info->window_height : 720;

    // --- 3. Configure GLFW Window Hints ---
    // Window hints must be set *before* calling glfwCreateWindow.

#if defined(SITUATION_USE_VULKAN)
    {
        // --- Vulkan-Specific Hints ---
        // For Vulkan, we explicitly tell GLFW *not* to create an OpenGL context.
        // The Vulkan application will create its own VkSurface and handle presentation.
        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
        // Note: Other OpenGL-specific hints (version, profile, MSAA) are irrelevant here.
    }
#elif defined(SITUATION_USE_OPENGL)
    {
        // --- OpenGL-Specific Hints ---
        // Request a specific OpenGL version and profile.
        // Ensure this version is supported by the target hardware/drivers.
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
        // Enable forward compatibility (important for macOS and core profile).
        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE);

        // Configure Multi-Sample Anti-Aliasing (MSAA) if requested.
        // This hint asks GLFW to create a framebuffer with 4x MSAA support.
        // The actual effectiveness depends on driver/hardware support.
        if (init_info->initial_active_window_flags & SITUATION_FLAG_MSAA_4X_HINT) {
            glfwWindowHint(GLFW_SAMPLES, 4);
        }
        // Note: Other OpenGL context flags (debug, robustness) could be set here if needed.
    }
#endif // SITUATION_USE_OPENGL

    // --- 4. Configure Common Window Hints ---
    // These hints apply regardless of the chosen graphics backend.
    // They control the initial appearance and behavior of the window.

    // Resizable: Can the user resize the window?
    glfwWindowHint( GLFW_RESIZABLE, (init_info->initial_active_window_flags & SITUATION_FLAG_WINDOW_RESIZABLE) ? GLFW_TRUE : GLFW_FALSE );

    // Decorated: Does the window have a title bar and borders?
    glfwWindowHint( GLFW_DECORATED, (init_info->initial_active_window_flags & SITUATION_FLAG_WINDOW_UNDECORATED) ? GLFW_FALSE : GLFW_TRUE );

    // Floating/Topmost: Should the window stay on top of others?
    glfwWindowHint( GLFW_FLOATING, (init_info->initial_active_window_flags & SITUATION_FLAG_WINDOW_TOPMOST) ? GLFW_TRUE : GLFW_FALSE );

    // Visible: Should the window be initially visible? (Default is GLFW_TRUE)
    // Hidden: Should the window be initially hidden? (Default is GLFW_FALSE)
    // These are not directly set from SituationInitInfo flags in the snippet, but could be if such flags existed.
    // glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE); // Example of hiding initially

    // Focused: Should the window be given input focus? (Default is GLFW_TRUE)
    // glfwWindowHint(GLFW_FOCUSED, GLFW_FALSE); // Example of not focusing initially

    // --- 5. Create the GLFW Window ---
    // This is the actual call to GLFW to create the native window and, potentially, the OpenGL context (if not using GLFW_NO_API).
    sit_gs.sit_glfw_window = glfwCreateWindow(
        sit_gs.main_window_width,     // Initial width
        sit_gs.main_window_height,    // Initial height
        init_info->window_title,      // Window title (can be NULL)
        NULL,                         // Monitor (NULL for windowed mode)
        NULL                          // Share (NULL for no context sharing)
    );

    // --- 6. Handle Window Creation Result ---
    if (!sit_gs.sit_glfw_window) {
        // glfwCreateWindow failed. This is a critical error.
        // Common reasons include invalid dimensions, unsupported pixel formats,
        // or OS-level failures (e.g., too many windows, permission denied).
        // GLFW's error callback (_SituationGLFWErrorCallback) should have captured a more detailed error message from GLFW itself.
        _SituationSetErrorFromCode(
            SITUATION_ERROR_GLFW_FAILED,
            "_SituationInitWindow: glfwCreateWindow failed. Check previous GLFW error message or window parameters (size, title)."
        );
        // Ensure the global window handle is explicitly NULL on failure.
        sit_gs.sit_glfw_window = NULL;
        return SITUATION_ERROR_GLFW_FAILED;
    }

    // --- 7. Store Window State Profiles ---
    // Save the initial window state flags provided in init_info.
    // These are used later by the window state management functions (e.g., SituationApplyCurrentProfileWindowState) to define the behavior when the window is active or inactive.
    sit_gs.active_profile_window_flags = init_info->initial_active_window_flags;
    sit_gs.inactive_profile_window_flags = init_info->initial_inactive_window_flags;
    // Note: The actual GLFW window state (resizable, decorated, etc.) is set by the hints above and the creation process. These flags are for the library's higher-level state management system.

    // --- 8. Success ---
    // If we reach here, the GLFW window was created successfully.
    // The handle is stored in sit_gs.sit_glfw_window.
    // The next step in initialization will typically be renderer setup (_SituationInitRenderer) followed by subsystem initialization (_SituationInitSubsystems).
    return SITUATION_SUCCESS;
}

/**
 * @brief [INTERNAL] Dispatches renderer initialization to the selected backend.
 *
 * @details This helper function acts as a simple dispatcher or gateway. Based on the compile-time definitions (`SITUATION_USE_VULKAN` or `SITUATION_USE_OPENGL`), it calls the corresponding backend-specific initialization function:
 *          `_SituationInitVulkan` or `_SituationInitOpenGL`.
 *
 * This abstraction allows the main `SituationInit` function to remain clean and unaware of the specific steps required for each graphics API.
 *
 * @param init_info A pointer to the `SituationInitInfo` struct provided during `SituationInit`. This contains configuration options that might be relevant to the renderer initialization.
 *                  This pointer must not be NULL (though the backend functions should also validate this).
 *
 * @return The `SituationError` code returned by the chosen backend's initialization function (e.g., `_SituationInitVulkan`, `_SituationInitOpenGL`).
 *         - SITUATION_SUCCESS indicates successful renderer setup.
 *         - Any other error code indicates a failure within the backend-specific initialization process.
 *
 * @note This function should only be called from `SituationInit` after the platform and window have been successfully initialized.
 * @note The choice of backend is determined at compile time by defining either `SITUATION_USE_VULKAN` or `SITUATION_USE_OPENGL`.
 * @warning This function is for internal use by `SituationInit` and should not be called directly by user code.
 *
 * @see SituationInit(), _SituationInitVulkan(), _SituationInitOpenGL()
 */
static SituationError _SituationInitRenderer(const SituationInitInfo* init_info) {
    // Dispatch to the appropriate backend initialization function based on the compile-time flag.
#if defined(SITUATION_USE_VULKAN)
    {
        // Vulkan backend is selected. Initialize it.
        return _SituationInitVulkan(init_info);
    }
#elif defined(SITUATION_USE_OPENGL)
    {
        // OpenGL backend is selected. Initialize it.
        return _SituationInitOpenGL(init_info);
    }
#else
    {
        // This branch should ideally be unreachable due to the #error directives in the header file that force the user to define a backend.
        // However, as a safeguard, handle the case where no backend is defined.
        _SituationSetErrorFromCode(
            SITUATION_ERROR_GENERAL,
            "_SituationInitRenderer: No graphics renderer backend defined (SITUATION_USE_VULKAN or SITUATION_USE_OPENGL). This should be caught at compile time."
        );
        return SITUATION_ERROR_GENERAL;
    }
#endif
}


/**
 * @brief [INTERNAL] Initializes all non-rendering library subsystems.
 * @details This function is called once during `SituationInit` after the platform and graphics backend have been successfully set up. It is responsible for bringing all other core library modules to life.
 *
 * @par Initialization Process
 *   - **Audio System:** Initializes the `miniaudio` context, creates the mutex for the sound queue, and pre-allocates the temporary memory buffers used by the real-time audio callback. This pre-allocation is a critical optimization to prevent `malloc` calls on the audio thread.
 *   - **Timer System:** Initializes the Temporal Oscillator system, calculating the default, musically-timed periods for the oscillator bank and setting the initial system time.
 *   - **Input Systems:**
 *     - Initializes mutexes for thread-safe keyboard and joystick event queuing.
 *     - Registers all of the library's internal GLFW callbacks (`_SituationGLFWKeyCallback`, `_SituationGLFWMouseButtonCallback`, etc.) to capture OS events.
 *     - Initializes the internal state-tracking structures for the keyboard, mouse, and gamepads.
 *     - Pre-creates the standard system cursor shapes for fast runtime switching.
 *     - Performs an initial poll for already-connected joysticks.
 *   - **Frame Timing:** Initializes all variables used for per-frame delta time and FPS calculation.
 *
 * @return `SITUATION_SUCCESS` on successful initialization of all subsystems.
 * @return An appropriate `SituationError` code if a critical step fails (e.g., a mutex or memory allocation fails).
 *
 * @note This function is for internal use by `SituationInit` only.
 *
 * @see SituationInit(), _SituationCleanupSubsystems()
 */
static SituationError _SituationInitSubsystems(void) {
    // --- 1. Audio System Initialization ---
    ma_context_config ctx_config = ma_context_config_init();
    if (ma_context_init(NULL, 0, &ctx_config, &sit_gs.sit_miniaudio_context) != MA_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_AUDIO_CONTEXT, "ma_context_init failed");
        return SITUATION_ERROR_AUDIO_CONTEXT;
    }
    sit_gs.is_sit_miniaudio_context_initialized = true;

    // Initialize the mutex that protects the sound playback queue.
    if (ma_mutex_init(&sit_gs.sit_audio_queue_mutex) != MA_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_GENERAL, "Failed to initialize audio queue mutex");
        return SITUATION_ERROR_GENERAL;
    }

    // Allocate temporary buffers used by the audio data callback for decoding, effects, and format conversion.
    // This pre-allocation prevents needing to malloc in the real-time audio thread.
    size_t decoder_buf_size = SITUATION_AUDIO_CALLBACK_TEMP_BUFFER_FRAMES * 8 * sizeof(float); // 8 is a safe max for channels
    size_t effects_buf_size = SITUATION_AUDIO_CALLBACK_TEMP_BUFFER_FRAMES * 8 * sizeof(float);
    size_t converter_buf_size = SITUATION_AUDIO_CALLBACK_TEMP_BUFFER_FRAMES * MA_MAX_CHANNELS * sizeof(float);
    sit_gs.sit_audio_callback_decoder_temp_buffer = (float*)malloc(decoder_buf_size);
    sit_gs.sit_audio_callback_effects_temp_buffer = (float*)malloc(effects_buf_size);
    sit_gs.sit_audio_callback_converter_temp_buffer = (float*)malloc(converter_buf_size);
    if (!sit_gs.sit_audio_callback_decoder_temp_buffer || !sit_gs.sit_audio_callback_effects_temp_buffer || !sit_gs.sit_audio_callback_converter_temp_buffer) {
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Audio callback temp buffers");
        return SITUATION_ERROR_MEMORY_ALLOCATION;
    }
    sit_gs.sit_audio_callback_temp_buffer_frames_capacity = SITUATION_AUDIO_CALLBACK_TEMP_BUFFER_FRAMES;


    // --- 2. Timer System Initialization ---
    SituationTimerSystem* ts = &sit_gs.timer_system_instance;
    ts->current_system_time_seconds = glfwGetTime();

    // Initialize the oscillator periods with a logarithmic-like distribution.
    double range_high = SITUATION_TIMER_GRID_PERIOD_EDGES;
    double range_low = 1.0 / SITUATION_TIMER_GRID_PERIOD_EDGES;
    double current_period_val = range_low;
    double increment_ratio = range_low;

    for (int i = 0; i < SITUATION_MAX_OSCILLATORS; i++) {
        // The first 64 oscillators use the calculated grid.
        if (i < 64) {
            ts->period_seconds[i] = current_period_val;
            // Clamp values to the defined range to prevent extreme periods.
            if (ts->period_seconds[i] > range_high) ts->period_seconds[i] = range_high;
            if (ts->period_seconds[i] < range_low && i > 0) ts->period_seconds[i] = range_low > 0.000001 ? range_low : 0.000001;

            current_period_val += (range_low * increment_ratio);
            increment_ratio *= SITUATION_TIMER_GRIDILON;
        } else {
            // The remaining oscillators default to a 1-second period.
            ts->period_seconds[i] = 1.0;
        }
        // Schedule the first trigger event for each oscillator.
        ts->next_trigger_time_seconds[i] = ts->current_system_time_seconds + ts->period_seconds[i];
        ts->last_ping_time_seconds[i] = ts->current_system_time_seconds;
        ts->trigger_count[i] = 0;
    }
    memset(ts->state_current, 0, sizeof(ts->state_current));
    memset(ts->state_previous, 0, sizeof(ts->state_previous));
    ts->is_initialized = true;


    // --- 3. Input Systems Initialization ---

    // Initialize mutexes for thread-safe input event queuing.
    if (ma_mutex_init(&sit_gs.sit_keyboard_event_queue_mutex) != MA_SUCCESS || ma_mutex_init(&sit_gs.joysticks.event_queue_mutex) != MA_SUCCESS || ma_mutex_init(&sit_gs.mouse.mutex) != MA_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_GENERAL, "Failed to initialize input mutexes");
        return SITUATION_ERROR_GENERAL;
    }

    // Register all necessary GLFW callbacks. These will populate our internal state.
    glfwSetDropCallback(sit_gs.sit_glfw_window, _SituationGLFWFileDropCallback);
    glfwSetWindowFocusCallback(sit_gs.sit_glfw_window, _SituationGLFWWindowFocusCallback);
    glfwSetWindowIconifyCallback(sit_gs.sit_glfw_window, _SituationGLFWWindowIconifyCallback);
    glfwSetFramebufferSizeCallback(sit_gs.sit_glfw_window, _SituationGLFWFramebufferSizeCallback);
    glfwSetKeyCallback(sit_gs.sit_glfw_window, _SituationGLFWKeyCallback);
    glfwSetCharCallback(sit_gs.sit_glfw_window, _SituationGLFWCharCallback);
    glfwSetMouseButtonCallback(sit_gs.sit_glfw_window, _SituationGLFWMouseButtonCallback);
    glfwSetCursorPosCallback(sit_gs.sit_glfw_window, _SituationGLFWCursorPosCallback);
    glfwSetScrollCallback(sit_gs.sit_glfw_window, _SituationGLFWScrollCallback);
    glfwSetJoystickCallback(sit_gs.sit_glfw_window, _SituationGLFWJoystickCallback);

    // Initialize internal state structures for input devices.
    memset(&sit_gs.keyboard, 0, sizeof(sit_gs.keyboard));
    memset(&sit_gs.mouse, 0, sizeof(sit_gs.mouse));
    glm_vec2_one(sit_gs.mouse.scale); // Default mouse scale is (1, 1).

    // Get the initial mouse position to prevent a large delta on the first frame.
    double initial_mx, initial_my;
    glfwGetCursorPos(sit_gs.sit_glfw_window, &initial_mx, &initial_my);
    sit_gs.mouse.current_pos[0] = (float)initial_mx;
    sit_gs.mouse.current_pos[1] = (float)initial_my;
    glm_vec2_copy(sit_gs.mouse.current_pos, sit_gs.mouse.last_pos);

    // Pre-create the standard system cursors for fast switching later.
    sit_gs.cursors[SIT_CURSOR_DEFAULT]   = NULL; // GLFW uses NULL for the system default.
    sit_gs.cursors[SIT_CURSOR_ARROW]     = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
    sit_gs.cursors[SIT_CURSOR_IBEAM]     = glfwCreateStandardCursor(GLFW_IBEAM_CURSOR);
    sit_gs.cursors[SIT_CURSOR_CROSSHAIR] = glfwCreateStandardCursor(GLFW_CROSSHAIR_CURSOR);
    sit_gs.cursors[SIT_CURSOR_HAND]      = glfwCreateStandardCursor(GLFW_HAND_CURSOR);
    sit_gs.cursors[SIT_CURSOR_HRESIZE]   = glfwCreateStandardCursor(GLFW_HRESIZE_CURSOR);
    sit_gs.cursors[SIT_CURSOR_VRESIZE]   = glfwCreateStandardCursor(GLFW_VRESIZE_CURSOR);
    sit_gs.cursor_count = 7; // The total number of cursor types defined.

    // Poll for any joysticks/gamepads that are already connected at startup.
    memset(&sit_gs.joysticks, 0, sizeof(sit_gs.joysticks));
    for (int jid = 0; jid < SITUATION_MAX_JOYSTICKS; jid++) {
        if (glfwJoystickPresent(jid)) {
            // The callback will handle updating the internal state.
            _SituationGLFWJoystickCallback(jid, GLFW_CONNECTED);
        }
    }

    // Manually trigger the first framebuffer size callback. This is crucial to ensure
    // the initial viewport and any projection matrices are set correctly before the
    // first frame is ever rendered.
    int fb_w, fb_h;
    glfwGetFramebufferSize(sit_gs.sit_glfw_window, &fb_w, &fb_h);
    _SituationGLFWFramebufferSizeCallback(sit_gs.sit_glfw_window, fb_w, fb_h);

    // --- Initialize Frame Timing State ---
    sit_gs.previous_time = glfwGetTime();
    sit_gs.current_time = sit_gs.previous_time;
    sit_gs.frame_time = 0.0;
    sit_gs.target_frame_time = 0.0; // Capping disabled by default
    sit_gs.fps_frame_counter = 0;
    sit_gs.fps_last_update_time = sit_gs.previous_time;
    sit_gs.current_fps = 0;
    
    // --- Initialize Callback Pointers ---
    sit_gs.exit_callback = NULL;
    sit_gs.exit_callback_user_data = NULL;
    sit_gs.resize_callback = NULL;
    sit_gs.resize_callback_user_data = NULL;
    
    // All subsystems initialized successfully.
    return SITUATION_SUCCESS;
}

#if defined(SITUATION_USE_OPENGL)
/**
 * @brief [INTERNAL] Initializes the OpenGL rendering backend and all internal OpenGL resources.
 * @details This is the master function for setting up the OpenGL environment. It is called once during `SituationInit` after the GLFW window and an OpenGL context have been successfully created.
 *
 * @par Initialization Sequence
 *   1.  **Context & Function Loading:** It makes the GLFW window's OpenGL context current for the calling thread and then uses GLAD to load all necessary modern OpenGL function pointers.
 *   2.  **Version & Extension Validation:** It verifies that the available OpenGL version meets the library's minimum requirement (e.g., OpenGL 4.6) and that critical extensions (like `GL_ARB_direct_state_access`) are supported.
 *   3.  **Global VAO Abstraction:** It creates and binds a single, global Vertex Array Object (`sit_gs.gl.global_vao_id`).
 *           This VAO remains active for all user rendering commands, providing a crucial abstraction layer that simplifies vertex attribute management and is essential for the `SituationCreateMesh` and `SituationCmd*` API to function correctly.
 *   4.  **Internal Renderers:** It initializes the library's private rendering modules, such as the 2D quad renderer and the virtual display compositors. These modules create their own private VAOs and shaders to ensure their state does not interfere with the user's global VAO.
 *   5.  **Global UBO:** It creates and binds the global Uniform Buffer Object for per-view data (e.g., camera matrices) to its standard binding point (`SIT_UBO_BINDING_VIEW_DATA`).
 *   6.  **Initial State:** It sets the initial VSync state (`glfwSwapInterval`) and default clear color based on the user's `init_info`.
 *
 * @param init_info A pointer to the `SituationInitInfo` struct, containing user-defined configuration like the VSync hint.
 *
 * @return `SITUATION_SUCCESS` on successful initialization of all OpenGL components.
 * @return An appropriate `SituationError` code if any phase fails (e.g., GLAD fails to load, version is too old, an internal renderer fails to initialize).
 *
 * @note This function is for internal use by `_SituationInitRenderer` only.
 * @warning The creation and binding of the `global_vao_id` is a cornerstone of the OpenGL backend's design. All user-facing mesh and drawing functions rely on this VAO being active.
 *
 * @see _SituationInitRenderer(), _SituationInitQuadRenderer(), _SituationCleanupOpenGL()
 */
static SituationError _SituationInitOpenGL(const SituationInitInfo* init_info) {
    // --- 1. Context and Function Loading ---
    glfwMakeContextCurrent(sit_gs.sit_glfw_window); // Ensure context is current for GLAD

    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_LOADER_FAILED, "_SituationInitOpenGL: GLAD failed to load function pointers.");
        return SITUATION_ERROR_OPENGL_LOADER_FAILED;
    }

    // --- 2. OpenGL Version and Extension Checks ---
    if (GLVersion.major < 4 || (GLVersion.major == 4 && GLVersion.minor < 6)) {
        char detail[128];
        snprintf(detail, sizeof(detail), "_SituationInitOpenGL: OpenGL 4.6 not supported by the driver. Found version %d.%d", GLVersion.major, GLVersion.minor);
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_UNSUPPORTED, detail);
        return SITUATION_ERROR_OPENGL_UNSUPPORTED;
    }

    // Validate required core features/extensions for our abstraction.
    if (!GLAD_GL_ARB_direct_state_access) {
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_UNSUPPORTED, "_SituationInitOpenGL: Required extension GL_ARB_direct_state_access is not available.");
        return SITUATION_ERROR_OPENGL_UNSUPPORTED;
    }

    // Check optional extension for SPIR-V if compiler is enabled.
#if defined(SITUATION_ENABLE_SHADER_COMPILER)
    // Note: Absence of ARB_gl_spirv is NOT a fatal error. It just means we must fallback to GLSL.
    // The refactored _SituationCreateGLComputeProgram handles this logic.
    sit_gs.gl.arb_gl_spirv_available = GLAD_GL_ARB_gl_spirv;
    // Optional debug log:
    // if (!sit_gs.gl.arb_gl_spirv_available) {
    //     fprintf(stdout, "INFO: GL_ARB_gl_spirv not available. OpenGL compute shaders will use standard GLSL path.\n");
    // }
#endif // SITUATION_ENABLE_SHADER_COMPILER

    // --- 3. VAO Abstraction Initialization ---
    // Create and bind the SINGLE, GLOBAL VAO for all USER rendering.
    // This VAO will remain bound for the entire duration of the user's render loop.
    // All subsequent user calls (like SituationCreateMesh, SituationCmdBindVertexBuffer) will implicitly modify THIS VAO's state because it's the currently bound one.
    glCreateVertexArrays(1, &sit_gs.gl.global_vao_id);
    if (sit_gs.gl.global_vao_id == 0) {
         _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_GENERAL, "_SituationInitOpenGL: Failed to create global VAO for user rendering.");
         return SITUATION_ERROR_OPENGL_GENERAL;
    }
    glBindVertexArray(sit_gs.gl.global_vao_id);
    SIT_CHECK_GL_ERROR(); // Check for errors after binding

    // --- 4. Internal Renderer Initialization ---
    // Initialize internal renderers (Quad Renderer, Virtual Display Renderer).
    // These functions MUST create, configure, and then unbind their own PRIVATE VAOs/VBOs.
    // They MUST leave sit_gs.gl.global_vao_id bound upon successful return.
    if (!_SituationInitQuadRenderer(sit_gs.main_window_width, sit_gs.main_window_height)) {
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_GENERAL, "_SituationInitOpenGL: Failed to initialize internal quad renderer.");
        // Cleanup global VAO on failure of dependent subsystem
        glDeleteVertexArrays(1, &sit_gs.gl.global_vao_id);
        sit_gs.gl.global_vao_id = 0;
        return SITUATION_ERROR_OPENGL_GENERAL;
    }

    // --- Initialize Virtual Display System ---
    // This involves creating shaders, setting up the VD quad renderer (with its own VAO/VBO), and initializing UBOs used for compositing.
    SituationError shader_err_code = SITUATION_SUCCESS;

    // a. Create Shaders for Virtual Display Compositing
    sit_gs.vd_shader_program_id = _SituationCreateGLShaderProgram(SIT_VD_VERTEX_SHADER_SRC, SIT_VD_FRAGMENT_SHADER_SRC, &shader_err_code);
    if (shader_err_code != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(shader_err_code, "_SituationInitOpenGL: Failed to create standard virtual display shader.");
        // Cleanup global VAO
        glDeleteVertexArrays(1, &sit_gs.gl.global_vao_id);
        sit_gs.gl.global_vao_id = 0;
        // Assume _SituationInitQuadRenderer cleaned up after itself on failure
        return shader_err_code;
    }

    sit_gs.composite_shader_program_id = _SituationCreateGLShaderProgram(SIT_COMPOSITE_VERTEX_SHADER_SRC, SIT_COMPOSITE_FRAGMENT_SHADER_SRC, &shader_err_code);
    if (shader_err_code != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(shader_err_code, "_SituationInitOpenGL: Failed to create advanced compositing shader.");
        // Cleanup global VAO and first shader
        glDeleteVertexArrays(1, &sit_gs.gl.global_vao_id);
        sit_gs.gl.global_vao_id = 0;
        glDeleteProgram(sit_gs.vd_shader_program_id);
        sit_gs.vd_shader_program_id = 0;
        // Assume _SituationInitQuadRenderer cleaned up after itself on failure
        return shader_err_code;
    }

    // b. Initialize the Virtual Display Quad Renderer
    // This function is responsible for creating sit_gs.vd_quad_vao/vbo, configuring them for a simple textured quad, and unbinding them, ensuring sit_gs.gl.global_vao_id is bound again at the end.
    // You need to implement this function, similar to _SituationInitQuadRenderer.
    if (!_SituationInitVirtualDisplayRenderer()) { // <-- You need this function
         _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_GENERAL, "_SituationInitOpenGL: Failed to initialize internal virtual display renderer.");
         // Cleanup global VAO and shaders
        glDeleteVertexArrays(1, &sit_gs.gl.global_vao_id);
        sit_gs.gl.global_vao_id = 0;
        glDeleteProgram(sit_gs.vd_shader_program_id);
        sit_gs.vd_shader_program_id = 0;
        glDeleteProgram(sit_gs.composite_shader_program_id);
        sit_gs.composite_shader_program_id = 0;
        // Assume _SituationInitQuadRenderer cleaned up after itself on failure
        return SITUATION_ERROR_OPENGL_GENERAL;
    }

    // c. Create UBO for View/Projection data (used by user shaders, potentially internal ones too)
    glCreateBuffers(1, &sit_gs.gl.view_data_ubo_id);
    if (sit_gs.gl.view_data_ubo_id == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_GENERAL, "_SituationInitOpenGL: Failed to create View UBO.");
        // Cleanup global VAO, shaders, and VD renderer resources
        glDeleteVertexArrays(1, &sit_gs.gl.global_vao_id);
        sit_gs.gl.global_vao_id = 0;
        glDeleteProgram(sit_gs.vd_shader_program_id);
        sit_gs.vd_shader_program_id = 0;
        glDeleteProgram(sit_gs.composite_shader_program_id);
        sit_gs.composite_shader_program_id = 0;
        // Assume _SituationInitVirtualDisplayRenderer cleaned up after itself on failure
        // Assume _SituationInitQuadRenderer cleaned up after itself on failure
        return SITUATION_ERROR_OPENGL_GENERAL;
    }
    // Allocate storage. Initial data can be set later or here if needed.
    glNamedBufferStorage(sit_gs.gl.view_data_ubo_id, sizeof(ViewDataUBO), NULL, GL_DYNAMIC_STORAGE_BIT);
    // Bind it to the standard binding point. This binding is persistent.
    glBindBufferBase(GL_UNIFORM_BUFFER, SIT_UBO_BINDING_VIEW_DATA, sit_gs.gl.view_data_ubo_id);
    SIT_CHECK_GL_ERROR();


    // d. Initialize Virtual Display Slots (Data structures)
    for (int i = 0; i < SITUATION_MAX_VIRTUAL_DISPLAYS; ++i) {
        sit_gs.virtual_display_slots_used[i] = false;
        // Ensure other members of sit_gs.virtual_display_slots[i] are initialized if needed
    }
    sit_gs.active_virtual_display_count = 0;
    // Note: Virtual Display *textures/framebuffers* are created on-demand when VDs are created by the user.

    // --- 5. Initial GL State Configuration ---
    if (init_info->initial_active_window_flags & SITUATION_FLAG_VSYNC_HINT) {
        glfwSwapInterval(1);
    } else {
        glfwSwapInterval(0);
    }
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Default clear color

    // --- 6. Finalize ---
    // CRITICAL: Ensure the global_vao_id is the active VAO at the end of initialization.
    // While it should already be bound from step 3, re-binding explicitly after potentially complex internal renderer setups is a good defensive practice.
    glBindVertexArray(sit_gs.gl.global_vao_id);
    SIT_CHECK_GL_ERROR();

    // Set the renderer type
    sit_gs.renderer_type = SIT_RENDERER_OPENGL;
    return SITUATION_SUCCESS;
}


#if defined(SITUATION_ENABLE_SHADER_COMPILER)
/**
 * @brief Creates a complete, linked OpenGL shader program from SPIR-V binary blobs.
 * @details This is the second stage of the unified shader pipeline for the OpenGL backend.
 *          It leverages the `GL_ARB_gl_spirv` extension to load the pre-compiled SPIR-V bytecode directly, bypassing the driver's GLSL compiler. This offers two key advantages:
 *          1) It ensures that shaders behave identically to the Vulkan backend.
 *          2) It can significantly speed up shader loading, as the driver only needs to ingest the binary, not perform a full compilation.
 *
 * @param vs_blob A pointer to the compiled SPIR-V blob for the vertex shader.
 * @param fs_blob A pointer to the compiled SPIR-V blob for the fragment shader.
 * @param error_code A pointer to a SituationError that will be filled on failure.
 * @return A valid OpenGL program ID on success, or 0 on failure.
 */
static GLuint _SituationCreateGLShaderProgramFromSpirv(const _SituationSpirvBlob* vs_blob, const _SituationSpirvBlob* fs_blob, SituationError* error_code) {
    if (!vs_blob || !fs_blob || !vs_blob->data || !fs_blob->data) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "SPIR-V blob data cannot be null.");
        if (error_code) *error_code = SITUATION_ERROR_INVALID_PARAM;
        return 0;
    }

    if (!GLAD_GL_ARB_gl_spirv) {
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_UNSUPPORTED, "Driver does not support GL_ARB_gl_spirv. Cannot load SPIR-V shaders.");
        if (error_code) *error_code = SITUATION_ERROR_OPENGL_UNSUPPORTED;
        return 0;
    }

    GLint success = 0;
    char infoLog[SITUATION_MAX_SHADER_LOG_LEN];

    // --- Create and load the Vertex Shader ---
    GLuint vs = glCreateShader(GL_VERTEX_SHADER);
    // 1. Load the binary SPIR-V data into the shader object.
    glShaderBinary(1, &vs, GL_SHADER_BINARY_FORMAT_SPIR_V, vs_blob->data, (GLsizei)vs_blob->size);
    // 2. Specialize the shader. This is the SPIR-V equivalent of "compiling" the binary for the driver.
    //    It specifies the entry point ("main") and any specialization constants (none in this case).
    glSpecializeShader(vs, "main", 0, NULL, NULL);
    SIT_CHECK_GL_ERROR(); 

    // 3. Verify that the specialization was successful.
    glGetShaderiv(vs, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(vs, sizeof(infoLog), NULL, infoLog);
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_SHADER_COMPILE, infoLog);
        if (error_code) *error_code = SITUATION_ERROR_OPENGL_SHADER_COMPILE;
        glDeleteShader(vs);
        return 0;
    }

    // --- Create and load the Fragment Shader (identical process) ---
    GLuint fs = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderBinary(1, &fs, GL_SHADER_BINARY_FORMAT_SPIR_V, fs_blob->data, (GLsizei)fs_blob->size);
    glSpecializeShader(fs, "main", 0, NULL, NULL);
    SIT_CHECK_GL_ERROR();

    glGetShaderiv(fs, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(fs, sizeof(infoLog), NULL, infoLog);
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_SHADER_COMPILE, infoLog);
        if (error_code) *error_code = SITUATION_ERROR_OPENGL_SHADER_COMPILE;
        glDeleteShader(vs);
        glDeleteShader(fs);
        return 0;
    }

    // --- Link the shaders into a program ---
    GLuint program = glCreateProgram();
    glAttachShader(program, vs);
    glAttachShader(program, fs);
    glLinkProgram(program);

    // The individual shader objects are no longer needed after linking.
    glDeleteShader(vs);
    glDeleteShader(fs);
    SIT_CHECK_GL_ERROR();

    // Verify the linking was successful.
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (!success) {
        glGetProgramInfoLog(program, sizeof(infoLog), NULL, infoLog);
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_SHADER_LINK, infoLog);
        if (error_code) *error_code = SITUATION_ERROR_OPENGL_SHADER_LINK;
        glDeleteProgram(program);
        return 0;
    }

    if (error_code) *error_code = SITUATION_SUCCESS;
    return program;
}

/**
 * @brief [INTERNAL] Creates a single-stage (compute) OpenGL shader program from a single SPIR-V blob.
 * @details This is the modern, preferred creation path for compute shaders on the OpenGL backend when `GL_ARB_gl_spirv` is available. It uses `glShaderBinary` to load the pre-compiled SPIR-V bytecode directly, bypassing the driver's GLSL compiler.
 *
 * @par Creation Process
 *   1.  Creates a new shader object of type `GL_COMPUTE_SHADER`.
 *   2.  Loads the binary SPIR-V data into the shader object using `glShaderBinary`.
 *   3.  "Specializes" the shader using `glSpecializeShader`, which is the SPIR-V equivalent of compiling the binary for the driver.
 *   4.  Checks the `GL_COMPILE_STATUS` to verify that specialization was successful.
 *   5.  Creates a program object, attaches the specialized shader, and links the program.
 *   6.  The intermediate shader object is deleted after a successful link.
 *
 * @param cs_blob A pointer to the `_SituationSpirvBlob` containing the compiled compute shader bytecode.
 * @param[out] error_code A pointer to a `SituationError` variable that will be filled with a specific error code on failure. Can be `NULL`.
 *
 * @return The OpenGL program ID (`GLuint`) on successful creation.
 * @return `0` on failure. A detailed error message is set internally.
 *
 * @note This function is for internal use by `_SituationCreateGLComputeProgram` only.
 * @warning The caller is responsible for deleting the returned program ID using `glDeleteProgram`.
 *
 * @see _SituationCreateGLComputeProgram(), glShaderBinary(), glSpecializeShader()
 */
static GLuint _SituationCreateGLComputeProgramFromSpirv(const struct _SituationSpirvBlob* cs_blob, SituationError* error_code) {
    if (error_code) *error_code = SITUATION_SUCCESS;

    // 1. --- Validation ---
    if (!cs_blob || !cs_blob->data || cs_blob->size == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "SPIR-V blob for compute shader cannot be null or empty.");
        if (error_code) *error_code = SITUATION_ERROR_INVALID_PARAM;
        return 0;
    }
    if (!GLAD_GL_ARB_gl_spirv) {
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_UNSUPPORTED, "Driver does not support GL_ARB_gl_spirv. Cannot load SPIR-V shaders.");
        if (error_code) *error_code = SITUATION_ERROR_OPENGL_UNSUPPORTED;
        return 0;
    }

    GLint success = 0;
    char infoLog[SITUATION_MAX_SHADER_LOG_LEN];

    // 2. --- Create and Specialize the Compute Shader Object ---
    GLuint cs = glCreateShader(GL_COMPUTE_SHADER);
    glShaderBinary(1, &cs, GL_SHADER_BINARY_FORMAT_SPIR_V, cs_blob->data, (GLsizei)cs_blob->size);
    glSpecializeShader(cs, "main", 0, NULL, NULL);
    SIT_CHECK_GL_ERROR();

    // Verify that the specialization was successful.
    glGetShaderiv(cs, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(cs, sizeof(infoLog), NULL, infoLog);
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_SHADER_COMPILE, infoLog);
        if (error_code) *error_code = SITUATION_ERROR_OPENGL_SHADER_COMPILE;
        glDeleteShader(cs);
        return 0;
    }

    // 3. --- Link the Shader into a Program ---
    GLuint program = glCreateProgram();
    glAttachShader(program, cs);
    glLinkProgram(program);

    // The individual shader object is no longer needed after linking.
    glDeleteShader(cs);
    SIT_CHECK_GL_ERROR();

    // Verify that the linking was successful.
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (!success) {
        glGetProgramInfoLog(program, sizeof(infoLog), NULL, infoLog);
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_SHADER_LINK, infoLog);
        if (error_code) *error_code = SITUATION_ERROR_OPENGL_SHADER_LINK;
        glDeleteProgram(program);
        return 0;
    }

    return program;
}
#endif // Shader Compiler

#endif // SITUATION_USE_OPENGL

#if defined(SITUATION_USE_VULKAN)
/**
 * @brief [INTERNAL] Initializes all internal Vulkan rendering pipelines required by the library's high-level drawing commands.
 * @details This is a master setup function called once during Vulkan initialization. It is responsible for creating all the private, pre-packaged rendering modules that the library uses to execute commands like `SituationCmdDrawQuad` and `SituationRenderVirtualDisplays`.
 *          These internal renderers are self-contained, with their own dedicated pipelines, layouts, and static buffers. This design ensures that their state does not interfere with any user-created
 *          pipelines or rendering states, providing a robust abstraction layer.
 *
 * @par Initialization Sequence
 *   The function systematically creates the resources for each internal renderer:
 *
 *   **1. Quad Renderer (for `SituationCmdDrawQuad`):**
 *      - **Shaders:** Compiles the embedded `SIT_QUAD_VERTEX_SHADER` and `SIT_QUAD_FRAGMENT_SHADER` sources into SPIR-V.
 *      - **Pipeline Layout:** Creates a `VkPipelineLayout` that defines the interface for the quad shader:
 *          - A descriptor set for the global projection UBO (at Set 0).
 *          - A push constant range to pass the per-quad model matrix and color.
 *      - **Graphics Pipeline:** Builds the `VkPipeline` object with a vertex input state for a simple `vec2` position and a `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP` topology.
 *      - **Vertex Buffer:** Creates a static, device-local `VkBuffer` and uploads the geometry for a reusable unit quad.
 *
 *   **2. Virtual Display Compositors (for `SituationRenderVirtualDisplays`):**
 *      - **Simple Compositor:**
 *          - **Shaders:** Compiles the `SIT_VD_VERTEX_SHADER_SRC` and `SIT_VD_FRAGMENT_SHADER_SRC`.
 *          - **Pipeline Layout:** Creates a layout that accepts the global UBO (Set 0), a single texture sampler for the VD's content (Set 1), and a push constant for the model matrix and opacity.
 *          - **Pipeline:** Builds the pipeline for drawing a textured quad.
 *      - **Advanced Compositor:**
 *          - **Shaders:** Compiles the `SIT_COMPOSITE_VERTEX_SHADER_SRC` and `SIT_COMPOSITE_FRAGMENT_SHADER_SRC` for Photoshop-style blend modes.
 *          - **Pipeline Layout:** Creates a more complex layout that can bind **two** texture samplers (for the source VD and the destination framebuffer copy) and a push constant for model matrix, opacity, and blend mode.
 *          - **Pipeline:** Builds the corresponding graphics pipeline.
 *
 * @return SITUATION_SUCCESS on successful initialization of all internal renderers.
 * @return SITUATION_ERROR_VULKAN_PIPELINE_FAILED or a related error code if any step fails (e.g., shader compilation, object creation). On failure, the function attempts to clean up any resources that were partially created to prevent leaks.
 *
 * @note This function is for internal use by `_SituationInitVulkan` only and must be called after the core Vulkan objects (device, allocator, main render pass, descriptor layouts) have been created.
 * @note All successfully created Vulkan handles are stored in the global state struct (`sit_gs.vk`) for use by the high-level drawing commands and for cleanup during shutdown.
 *
 * @warning The success of this function is mandatory for the `SituationCmdDrawQuad` and `SituationRenderVirtualDisplays` APIs to work correctly.
 * @warning This function relies on the shader compiler being enabled (`SITUATION_ENABLE_SHADER_COMPILER`).
 *
 * @see _SituationInitVulkan()
 * @see _SituationCleanupQuadRenderer()
 * @see SituationCmdDrawQuad()
 * @see SituationRenderVirtualDisplays()
 * @see _SituationVulkanCreateGraphicsPipeline()
 */
static SituationError _SituationVulkanInitInternalRenderers(void) {
    // --- Initialize all local handles to NULL for robust cleanup ---
    VkPipelineLayout quad_pipeline_layout = VK_NULL_HANDLE;
    VkPipeline       quad_pipeline = VK_NULL_HANDLE;
    VkBuffer         quad_vertex_buffer = VK_NULL_HANDLE;
    VmaAllocation    quad_vertex_buffer_memory = VK_NULL_HANDLE;
    
    VkPipelineLayout vd_compositing_pipeline_layout = VK_NULL_HANDLE;
    VkPipeline       vd_compositing_pipeline = VK_NULL_HANDLE;
    
    VkPipelineLayout advanced_compositing_pipeline_layout = VK_NULL_HANDLE;
    VkPipeline       advanced_compositing_pipeline = VK_NULL_HANDLE;
    
    _SituationSpirvBlob vs_spirv = {0}, fs_spirv = {0};

    // =================================================================================
    // --- 1. Initialize the Simple Colored Quad Renderer (for SituationCmdDrawQuad) ---
    // =================================================================================
    {
        // 1a. Compile internal GLSL shaders to SPIR-V
        vs_spirv = _SituationVulkanCompileGLSLtoSPIRV(SIT_QUAD_VERTEX_SHADER, "internal_quad.vert", shaderc_vertex_shader);
        fs_spirv = _SituationVulkanCompileGLSLtoSPIRV(SIT_QUAD_FRAGMENT_SHADER, "internal_quad.frag", shaderc_fragment_shader);
        if (!vs_spirv.data || !fs_spirv.data) goto cleanup; // Compiler failed, error is already set.

        // 1b. Create the Pipeline Layout.
        // This defines the interface for the quad shader: a UBO for projection (Set 0) and
        // a push constant for the per-quad model matrix and color.
        VkPushConstantRange push_constant_range = {
            .stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT,
            .offset = 0,
            .size = sizeof(mat4) + sizeof(vec4) // Model Matrix + Color
        };
        VkDescriptorSetLayout layouts[] = { sit_gs.vk.view_data_ubo_layout };
        VkPipelineLayoutCreateInfo pipeline_layout_info = {
            .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            .setLayoutCount = 1,
            .pSetLayouts = layouts,
            .pushConstantRangeCount = 1,
            .pPushConstantRanges = &push_constant_range
        };
        if (vkCreatePipelineLayout(sit_gs.vk.device, &pipeline_layout_info, NULL, &quad_pipeline_layout) != VK_SUCCESS) {
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_PIPELINE_FAILED, "Failed to create quad pipeline layout.");
            goto cleanup;
        }

        // 1c. Define the vertex input state for a simple 2D vertex (position only).
        VkVertexInputBindingDescription binding_desc = { .binding = 0, .stride = 2 * sizeof(float), .inputRate = VK_VERTEX_INPUT_RATE_VERTEX };
        VkVertexInputAttributeDescription attr_desc = { .binding = 0, .location = SIT_ATTR_POSITION, .format = VK_FORMAT_R32G32_SFLOAT, .offset = 0 };

        // 1d. Create the graphics pipeline using the generic helper.
        quad_pipeline = _SituationVulkanCreateGraphicsPipeline(
            vs_spirv.data, vs_spirv.size,
            fs_spirv.data, fs_spirv.size,
            quad_pipeline_layout,
            VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP, // A quad is drawn as a 4-vertex strip
            1, &binding_desc,
            1, &attr_desc
        );
        _SituationFreeSpirvBlob(&vs_spirv);
        _SituationFreeSpirvBlob(&fs_spirv);
        if (quad_pipeline == VK_NULL_HANDLE) goto cleanup; // Helper function sets the error.

        // 1e. Create and upload the static vertex buffer for a unit quad.
        float quad_vertices[] = { 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f }; // Triangle Strip order for a 0,0 to 1,1 quad
        if (_SituationVulkanCreateAndUploadBuffer(quad_vertices, sizeof(quad_vertices), VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, &quad_vertex_buffer, &quad_vertex_buffer_memory) != SITUATION_SUCCESS) {
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED, "Failed to create quad vertex buffer.");
            goto cleanup;
        }
    }

    // ======================================================================================
    // --- 2. Initialize the Simple VD Compositing Renderer (for SituationRenderVirtualDisplays) ---
    // ======================================================================================
    {
        // 2a. Compile shaders
        vs_spirv = _SituationVulkanCompileGLSLtoSPIRV(SIT_VD_VERTEX_SHADER_SRC, "internal_vd.vert", shaderc_vertex_shader);
        fs_spirv = _SituationVulkanCompileGLSLtoSPIRV(SIT_VD_FRAGMENT_SHADER_SRC, "internal_vd.frag", shaderc_fragment_shader);
        if (!vs_spirv.data || !fs_spirv.data) goto cleanup;

        // 2b. Create Pipeline Layout.
        // Interface: UBO (Set 0), Sampler (Set 1), Push Constant (Model + Opacity).
        VkPushConstantRange push_constant_range = {
            .stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT,
            .offset = 0,
            .size = sizeof(mat4) + sizeof(float) // Model Matrix + Opacity
        };
        // This layout uses TWO descriptor sets: one for the UBO and one for the texture.
        VkDescriptorSetLayout layouts[] = { sit_gs.vk.view_data_ubo_layout, sit_gs.vk.image_sampler_layout };
        VkPipelineLayoutCreateInfo pipeline_layout_info = {
            .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            .setLayoutCount = 2,
            .pSetLayouts = layouts,
            .pushConstantRangeCount = 1,
            .pPushConstantRanges = &push_constant_range
        };
        if (vkCreatePipelineLayout(sit_gs.vk.device, &pipeline_layout_info, NULL, &vd_compositing_pipeline_layout) != VK_SUCCESS) {
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_PIPELINE_FAILED, "Failed to create VD compositing pipeline layout.");
            goto cleanup;
        }
        
        // 2c. Define vertex input (position + texcoord). This uses the same quad VBO.
        VkVertexInputBindingDescription binding_desc = { .binding = 0, .stride = 2 * sizeof(float), .inputRate = VK_VERTEX_INPUT_RATE_VERTEX };
        VkVertexInputAttributeDescription attr_descs[2] = {
            { .binding = 0, .location = SIT_ATTR_POSITION,   .format = VK_FORMAT_R32G32_SFLOAT, .offset = 0 },
            // TexCoords are the same as positions for a full-screen quad.
            { .binding = 0, .location = SIT_ATTR_TEXCOORD_0, .format = VK_FORMAT_R32G32_SFLOAT, .offset = 0 }
        };

        // 2d. Create the pipeline.
        vd_compositing_pipeline = _SituationVulkanCreateGraphicsPipeline(
            vs_spirv.data, vs_spirv.size,
            fs_spirv.data, fs_spirv.size,
            vd_compositing_pipeline_layout,
            VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
            1, &binding_desc,
            2, attr_descs
        );
        _SituationFreeSpirvBlob(&vs_spirv);
        _SituationFreeSpirvBlob(&fs_spirv);
        if (vd_compositing_pipeline == VK_NULL_HANDLE) goto cleanup;
    }
    
    // ======================================================================================
    // --- 3. Initialize the Advanced VD Compositing Renderer ---
    // ======================================================================================
    // This follows the same pattern as the simple compositor. The main difference is the fragment shader logic and potentially the descriptor set layout if it needed more resources.
    // Here we assume it reuses the same layout for simplicity.
    {
        vs_spirv = _SituationVulkanCompileGLSLtoSPIRV(SIT_COMPOSITE_VERTEX_SHADER_SRC, "internal_composite.vert", shaderc_vertex_shader);
        fs_spirv = _SituationVulkanCompileGLSLtoSPIRV(SIT_COMPOSITE_FRAGMENT_SHADER_SRC, "internal_composite.frag", shaderc_fragment_shader);
        if (!vs_spirv.data || !fs_spirv.data) goto cleanup;

        // Create a layout that can bind TWO samplers.
        VkDescriptorSetLayoutBinding sampler_bindings[2] = {
            { .binding = SIT_SAMPLER_BINDING_VD_SOURCE, .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, .descriptorCount = 1, .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT },
            { .binding = SIT_SAMPLER_BINDING_VD_DEST, .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, .descriptorCount = 1, .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT }
        };
        VkDescriptorSetLayoutCreateInfo sampler_layout_info = { .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, .bindingCount = 2, .pBindings = sampler_bindings };
        VkDescriptorSetLayout two_sampler_layout; // Temporary for this pipeline
        if (vkCreateDescriptorSetLayout(sit_gs.vk.device, &sampler_layout_info, NULL, &two_sampler_layout) != VK_SUCCESS) {
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED, "Failed to create two-sampler layout for advanced compositor.");
            goto cleanup;
        }

        VkDescriptorSetLayout layouts[] = { sit_gs.vk.view_data_ubo_layout, two_sampler_layout };
        VkPushConstantRange push_constant_range = {
            .stageFlags = VK_SHADER_STAGE_ALL_GRAPHICS,
            .offset = 0,
            .size = sizeof(mat4) + sizeof(int) + sizeof(float) // Model, BlendMode, Opacity
        };
        VkPipelineLayoutCreateInfo layout_info = { .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, .setLayoutCount = 2, .pSetLayouts = layouts, .pushConstantRangeCount = 1, .pPushConstantRanges = &push_constant_range };
        if (vkCreatePipelineLayout(sit_gs.vk.device, &layout_info, NULL, &advanced_compositing_pipeline_layout) != VK_SUCCESS) {
            vkDestroyDescriptorSetLayout(sit_gs.vk.device, two_sampler_layout, NULL);
            goto cleanup;
        }

        // Create pipeline (vertex format is the same as simple compositor)
        // ...
        
        // After pipeline creation, we can destroy the temporary layout
        vkDestroyDescriptorSetLayout(sit_gs.vk.device, two_sampler_layout, NULL);

        _SituationFreeSpirvBlob(&vs_spirv);
        _SituationFreeSpirvBlob(&fs_spirv);
        if (advanced_compositing_pipeline == VK_NULL_HANDLE) goto cleanup;
    }

    // --- Success: Assign created resources to the global state ---
    sit_gs.vk.quad_pipeline_layout = quad_pipeline_layout;
    sit_gs.vk.quad_pipeline = quad_pipeline;
    sit_gs.vk.quad_vertex_buffer = quad_vertex_buffer;
    sit_gs.vk.quad_vertex_buffer_memory = quad_vertex_buffer_memory;
    sit_gs.vk.vd_compositing_pipeline_layout = vd_compositing_pipeline_layout;
    sit_gs.vk.vd_compositing_pipeline = vd_compositing_pipeline;
    sit_gs.vk.advanced_compositing_pipeline_layout = advanced_compositing_pipeline_layout;
    sit_gs.vk.advanced_compositing_pipeline = advanced_compositing_pipeline;

    return SITUATION_SUCCESS;

cleanup:
    // This block is executed only if any step fails. It cleans up all resources
    // that might have been successfully created before the failure occurred.
    _SituationFreeSpirvBlob(&vs_spirv);
    _SituationFreeSpirvBlob(&fs_spirv);
    
    if (quad_pipeline_layout) vkDestroyPipelineLayout(sit_gs.vk.device, quad_pipeline_layout, NULL);
    if (quad_pipeline) vkDestroyPipeline(sit_gs.vk.device, quad_pipeline, NULL);
    if (quad_vertex_buffer) vmaDestroyBuffer(sit_gs.vk.vma_allocator, quad_vertex_buffer, quad_vertex_buffer_memory);

    if (vd_compositing_pipeline_layout) vkDestroyPipelineLayout(sit_gs.vk.device, vd_compositing_pipeline_layout, NULL);
    if (vd_compositing_pipeline) vkDestroyPipeline(sit_gs.vk.device, vd_compositing_pipeline, NULL);

    if (advanced_compositing_pipeline_layout) vkDestroyPipelineLayout(sit_gs.vk.device, advanced_compositing_pipeline_layout, NULL);
    if (advanced_compositing_pipeline) vkDestroyPipeline(sit_gs.vk.device, advanced_compositing_pipeline, NULL);

    return SITUATION_ERROR_VULKAN_PIPELINE_FAILED; // Return a general failure code
}

/**
 * @brief [INTERNAL] Allocates and begins recording a temporary, primary-level Vulkan command buffer.
 *
 * @details This helper function is a standard and convenient way to execute short, one-off sequences of Vulkan commands (e.g., image layout transitions, buffer copies, setting image data). It simplifies the process by:
 * 1.  Allocating a single primary command buffer from the library's main command pool (`sit_gs.vk.command_pool`).
 * 2.  Beginning recording on that buffer with the `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT` flag, indicating it will be submitted once and then discarded.
 *
 * @par Typical Usage Pattern
 * The caller uses this function to get a command buffer, records commands into it using `vkCmd*` functions, and then calls
 * `_SituationVulkanEndSingleTimeCommands` to end recording, submit the commands to the graphics queue, wait for completion, and clean up the buffer.
 *
 * @code{.c}
 * VkCommandBuffer cmd = _SituationVulkanBeginSingleTimeCommands();
 * if (cmd == VK_NULL_HANDLE) { // Handle allocation/error } // Check added for robustness
 * // Record commands, e.g., vkCmdPipelineBarrier, vkCmdCopyBuffer...
 * _SituationVulkanEndSingleTimeCommands(cmd); // Handles submission, wait, and cleanup
 * @endcode
 *
 * @return A valid `VkCommandBuffer` handle ready for command recording.
 * @return `VK_NULL_HANDLE` if the library is not initialized, if the Vulkan device or command pool is invalid, or if allocation/beginning fails.
 *         A specific error message is set via `_SituationSetErrorFromCode`.
 *
 * @note This function is for internal library use and is not part of the public API.
 * @note It is the caller's sole responsibility to pass the returned `VkCommandBuffer` handle to `_SituationVulkanEndSingleTimeCommands` to ensure proper submission, synchronization, and cleanup.
 *       Failing to do so will result in resource leaks.
 * @warning This function allocates a command buffer. Not calling `_SituationVulkanEndSingleTimeCommands` will leak this resource.
 * @warning This function is synchronous; `_SituationVulkanEndSingleTimeCommands` calls `vkQueueWaitIdle`, blocking the CPU until the commands complete.
 *
 * @see _SituationVulkanEndSingleTimeCommands(), vkAllocateCommandBuffers(), vkBeginCommandBuffer()
 */
static VkCommandBuffer _SituationVulkanBeginSingleTimeCommands(void) {
    // --- 1. Input/State Validation ---
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "_SituationVulkanBeginSingleTimeCommands: Library not initialized.");
        return VK_NULL_HANDLE;
    }
    if (sit_gs.vk.device == VK_NULL_HANDLE || sit_gs.vk.command_pool == VK_NULL_HANDLE) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "_SituationVulkanBeginSingleTimeCommands: Vulkan device or command pool is NULL.");
        return VK_NULL_HANDLE;
    }

    // --- 2. Allocate Command Buffer ---
    VkCommandBufferAllocateInfo alloc_info = {0}; // Explicitly zero-initialize
    alloc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; // Mandatory sType
    alloc_info.pNext = NULL; // No extension structures
    alloc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; // Primary command buffer
    alloc_info.commandPool = sit_gs.vk.command_pool; // Use the library's main command pool
    alloc_info.commandBufferCount = 1; // Allocate one command buffer

    VkCommandBuffer command_buffer = VK_NULL_HANDLE; // Initialize handle
    VkResult result = vkAllocateCommandBuffers(sit_gs.vk.device, &alloc_info, &command_buffer);
    if (result != VK_SUCCESS) {
        char error_detail[256];
        snprintf(error_detail, sizeof(error_detail),
                 "_SituationVulkanBeginSingleTimeCommands: vkAllocateCommandBuffers failed (VkResult: 0x%x).", result);
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, error_detail);
        return VK_NULL_HANDLE; // Return invalid handle on allocation failure
    }

    // --- 3. Begin Recording Command Buffer ---
    VkCommandBufferBeginInfo begin_info = {0}; // Explicitly zero-initialize
    begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; // Mandatory sType
    begin_info.pNext = NULL; // No extension structures
    // --- CRITICAL FLAG ---
    // VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT tells the driver this buffer
    // will be submitted once and then not used again. This can enable optimizations.
    begin_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
    // --- END CRITICAL FLAG ---
    begin_info.pInheritanceInfo = NULL; // Not used for primary command buffers

    result = vkBeginCommandBuffer(command_buffer, &begin_info);
    if (result != VK_SUCCESS) {
        char error_detail[256];
        snprintf(error_detail, sizeof(error_detail),
                 "_SituationVulkanBeginSingleTimeCommands: vkBeginCommandBuffer failed (VkResult: 0x%x).", result);
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, error_detail);
        // --- CRITICAL CLEANUP ---
        // If vkBeginCommandBuffer fails, we must free the allocated command buffer to prevent a resource leak.
        vkFreeCommandBuffers(sit_gs.vk.device, sit_gs.vk.command_pool, 1, &command_buffer);
        // --- END CRITICAL CLEANUP ---
        return VK_NULL_HANDLE; // Return invalid handle on begin failure
    }

    // --- 4. Success ---
    // If we reach here, the command buffer is valid and in the recording state.
    // It is the caller's responsibility to end and submit it using _SituationVulkanEndSingleTimeCommands.
    return command_buffer;
}


// --- Updated/Added Documentation Block for _SituationVulkanEndSingleTimeCommands ---
/**
 * @brief [INTERNAL] Ends recording, submits, waits for completion, and cleans up a one-time-use command buffer.
 *
 * @details This helper function completes the lifecycle of a temporary command buffer created by `_SituationVulkanBeginSingleTimeCommands`. It performs the following essential steps:
 * 1.  Ends the recording of the command buffer.
 * 2.  Submits the command buffer to the graphics queue (`sit_gs.vk.graphics_queue`) for execution.
 * 3.  Waits for the graphics queue to become idle (`vkQueueWaitIdle`), ensuring that all commands recorded in the buffer have finished executing on the GPU.
 *     This makes the function synchronous.
 * 4.  Frees the command buffer back to the pool (`sit_gs.vk.command_pool`) from which it was allocated.
 *
 * @par Typical Usage Pattern
 * This function is always paired with `_SituationVulkanBeginSingleTimeCommands`.
 *
 * @code{.c}
 * VkCommandBuffer cmd = _SituationVulkanBeginSingleTimeCommands();
 * if (cmd == VK_NULL_HANDLE) { // Handle allocation/error }
 * // Record commands, e.g., vkCmdPipelineBarrier, vkCmdCopyBuffer...
 * _SituationVulkanEndSingleTimeCommands(cmd); // Handles submission, wait, and cleanup
 * @endcode
 *
 * @param command_buffer The `VkCommandBuffer` handle returned by `_SituationVulkanBeginSingleTimeCommands`. This handle must be valid.
 *
 * @note This function is for internal library use and is not part of the public API.
 * @note This function is synchronous due to the `vkQueueWaitIdle` call. It will block the calling thread until the GPU has finished executing the commands.
 * @note It is crucial that the `command_buffer` parameter is the handle returned by `_SituationVulkanBeginSingleTimeCommands` and has not been previously ended or submitted.
 * @warning Failing to call this function after obtaining a command buffer from `_SituationVulkanBeginSingleTimeCommands` will result in a resource leak.
 * @warning Calling this function with an invalid or already-ended `command_buffer` handle can lead to undefined behavior or validation errors.
 *
 * @see _SituationVulkanBeginSingleTimeCommands(), vkEndCommandBuffer(), vkQueueSubmit(), vkQueueWaitIdle(), vkFreeCommandBuffers()
 */
static void _SituationVulkanEndSingleTimeCommands(VkCommandBuffer command_buffer) {
    // --- 1. Input Validation ---
    // While internal, checking for VK_NULL_HANDLE prevents potential crashes.
    if (command_buffer == VK_NULL_HANDLE) {
        // Silently return if an invalid handle is passed.
        // This prevents crashing but indicates a logic error upstream.
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "_SituationVulkanEndSingleTimeCommands: command_buffer is VK_NULL_HANDLE.");
        return;
    }
    // Note: We don't check sit_gs.vk.device/queue/pool here as they should be valid if this function is called correctly after Begin. A check could be added if paranoia dictates.

    // --- 2. End Recording the Command Buffer ---
    VkResult result = vkEndCommandBuffer(command_buffer);
    if (result != VK_SUCCESS) {
        char error_detail[256];
        snprintf(error_detail, sizeof(error_detail),
                 "_SituationVulkanEndSingleTimeCommands: vkEndCommandBuffer failed (VkResult: 0x%x).", result);
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, error_detail);
        // --- CRITICAL DECISION ---
        // If vkEndCommandBuffer fails, the command buffer is in an undefined state.
        // Attempting to submit it would be incorrect.
        // The safest approach is to free it immediately to prevent leaks, even though submission/waiting will be skipped.
        vkFreeCommandBuffers(sit_gs.vk.device, sit_gs.vk.command_pool, 1, &command_buffer);
        // --- END CRITICAL DECISION ---
        return; // Exit early, do not proceed with submission/waiting
    }

    // --- 3. Submit the Command Buffer to the Graphics Queue ---
    VkSubmitInfo submit_info = {0}; // Explicitly zero-initialize
    submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; // Mandatory sType
    submit_info.pNext = NULL; // No extension structures
    submit_info.waitSemaphoreCount = 0; // No semaphores to wait on for one-time cmds
    submit_info.pWaitSemaphores = NULL;
    submit_info.pWaitDstStageMask = NULL;
    submit_info.commandBufferCount = 1; // Submit one command buffer
    submit_info.pCommandBuffers = &command_buffer; // The buffer to submit
    submit_info.signalSemaphoreCount = 0; // No semaphores to signal upon completion
    submit_info.pSignalSemaphores = NULL;

    result = vkQueueSubmit(sit_gs.vk.graphics_queue, 1, &submit_info, VK_NULL_HANDLE);
    if (result != VK_SUCCESS) {
        char error_detail[256];
        snprintf(error_detail, sizeof(error_detail),
                 "_SituationVulkanEndSingleTimeCommands: vkQueueSubmit failed (VkResult: 0x%x).", result);
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, error_detail);
        // --- CRITICAL CLEANUP ---
        // Even if submission fails, we must still free the command buffer
        // to prevent a resource leak.
        vkFreeCommandBuffers(sit_gs.vk.device, sit_gs.vk.command_pool, 1, &command_buffer);
        // --- END CRITICAL CLEANUP ---
        return; // Exit early, do not proceed with waiting
    }

    // --- 4. Wait for the Submitted Commands to Finish ---
    // This is the synchronous part. It blocks the CPU thread until the GPU is completely done executing the commands in `command_buffer`.
    // This ensures resources used by those commands are no longer in use.
    result = vkQueueWaitIdle(sit_gs.vk.graphics_queue);
    if (result != VK_SUCCESS) {
        char error_detail[256];
        snprintf(error_detail, sizeof(error_detail),
                 "_SituationVulkanEndSingleTimeCommands: vkQueueWaitIdle failed (VkResult: 0x%x).", result);
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, error_detail);
        // Note: Even if waiting fails (indicating a serious problem like device loss), we still attempt to free the command buffer. The device might be in a bad state, but cleanup is still the right intention.
    }
    // Note: No specific error handling for vkQueueWaitIdle failure beyond logging.
    // The device might be lost, but proceeding with freeing the buffer is still necessary.

    // --- 5. Free the Command Buffer ---
    // Regardless of whether the wait succeeded (in terms of device health), we must free the command buffer to prevent leaks.
    vkFreeCommandBuffers(sit_gs.vk.device, sit_gs.vk.command_pool, 1, &command_buffer);
    // After this call, `command_buffer` is an invalid handle and must not be used.
}


// --- Updated/Added Documentation Block for _SituationReadSpirvFile ---
/**
 * @brief [INTERNAL] Reads a raw SPIR-V binary file into memory.
 *
 * @details This helper function is a convenience wrapper designed specifically for loading compiled SPIR-V shader binaries (`.spv` files) from the filesystem.
 *          It leverages the library's existing `SituationLoadFileData` function to perform the actual file I/O, ensuring consistency in file access methods.
 *
 * @par Expected File Format
 * The file pointed to by `filename` is expected to be a raw binary file containing the compiled SPIR-V bytecode. No text parsing or conversion is performed.
 *
 * @param filename The null-terminated path to the `.spv` file to be read. This pointer must not be NULL.
 * @param[out] out_size A pointer to a `size_t` variable where the size of the read data (in bytes) will be stored. This pointer must not be NULL.
 *
 * @return A pointer to a newly allocated block of memory containing the raw bytes of the SPIR-V file.
 *         - The caller takes ownership of this memory and is responsible for calling `free()` on the returned pointer when it is no longer needed.
 *         - The memory block is guaranteed to be at least `*out_size` bytes long and null-terminated (an extra byte is allocated and set to 0, though the SPIR-V data itself is binary and might contain 0s).
 * @return NULL if the function fails. This can happen if:
 *         - `filename` is NULL.
 *         - `out_size` is NULL.
 *         - `SituationLoadFileData` fails to open or read the file (e.g., file not found, permission denied, read error).
 *         - Memory allocation fails.
 *         In case of failure, `*out_size` is set to 0, and a specific error message is set via `_SituationSetErrorFromCode` (inherited from `SituationLoadFileData` or generated by this function).
 *
 * @note This function is for internal library use and is not part of the public API.
 * @note The returned pointer points to memory allocated using the standard `malloc`.
 *       It must be freed using the standard `free`.
 * @warning The caller must check the return value for NULL before using it.
 * @warning The contents of the returned buffer are raw binary data and should be treated as such. Casting it to other types (e.g., `uint32_t*` for
 *          SPIR-V words) is safe, but care must be taken with endianness if the file was compiled for a different architecture.
 *
 * @see SituationLoadFileData(), free()
 */
static char* _SituationReadSpirvFile(const char* filename, size_t* out_size) {
    // --- 1. Input Validation ---
    if (!filename) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "_SituationReadSpirvFile: filename cannot be NULL.");
        if (out_size) *out_size = 0;
        return NULL;
    }
    if (!out_size) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "_SituationReadSpirvFile: out_size cannot be NULL.");
        // Cannot set *out_size to 0 as it's NULL, but error is set.
        return NULL;
    }

    // --- 2. Initialize Output ---
    *out_size = 0; // Initialize output size to zero in case of early return.

    // --- 3. Use Existing File Loading Logic ---
    // Leverage the library's established `SituationLoadFileData` function.
    // This function is assumed to handle file opening, reading into a malloc'd buffer, and null-terminating the buffer. It returns the number of bytes read.
    unsigned int bytes_read_u32 = 0; // Use the type expected by SituationLoadFileData
    char* buffer = (char*)SituationLoadFileData(filename, &bytes_read_u32);

    // --- 4. Handle Result from SituationLoadFileData ---
    if (!buffer) {
        // SituationLoadFileData failed. It should have set a specific error message in sit_gs.last_error_msg (e.g., "File not found", "Permission denied").
        // We can optionally prefix this message for context.
        char prefixed_error[SITUATION_MAX_ERROR_MSG_LEN];
        snprintf(prefixed_error, sizeof(prefixed_error),
                 "_SituationReadSpirvFile: Failed to load file '%s'. Reason: %s",
                 filename, SituationGetLastErrorMsg()); // Get error from SituationLoadFileData
        _SituationSetError(prefixed_error); // Update global error with context
        // *out_size is already 0.
        return NULL; // Return NULL to indicate failure
    }

    // --- 5. Success ---
    // SituationLoadFileData succeeded. `buffer` points to the allocated data, and `bytes_read_u32` contains the number of bytes read.
    // Convert the byte count to size_t for the output parameter.
    *out_size = (size_t)bytes_read_u32;

    // The buffer is allocated by SituationLoadFileData and is owned by the caller.
    // It is guaranteed to be at least *out_size bytes + 1 (null terminator).
    return buffer;
}

#if defined(SITUATION_ENABLE_SHADER_COMPILER)
/**
 * @brief [INTERNAL] Compiles a GLSL source string into a SPIR-V binary blob using shaderc.
 *
 * @details This is the first and most crucial stage of the unified shader pipeline. It takes standard, human-readable GLSL code and transforms it into the SPIR-V intermediate representation.
 *          This SPIR-V bytecode can then be consumed by both the Vulkan backend and the OpenGL backend (if `GL_ARB_gl_spirv` is supported), ensuring shader consistency across different graphics APIs and potentially improving load times.
 *
 * @param glsl_source A null-terminated C-string containing the GLSL shader code to be compiled.
 * @param source_name A descriptive name for the shader (e.g., "scene.vert", "compute_filter.comp").
 *                    This name is used in error messages generated by shaderc to help identify the problematic shader.
 * @param shader_kind The type of shader being compiled (e.g., `shaderc_vertex_shader`, `shaderc_fragment_shader`, `shaderc_compute_shader`). This tells shaderc which specific compilation rules and validation checks to apply.
 *
 * @return A `_SituationSpirvBlob` struct.
 *         - On **success**, the struct is populated:
 *           - `internal_result` points to a valid `shaderc_compilation_result_t` object containing the compiled SPIR-V data.
 *           - `data` points to the raw SPIR-V bytecode within the `internal_result`.
 *           - `size` is the size of the SPIR-V bytecode in bytes.
 *         - On **failure**, the struct is zero-initialized (`{0}`), and the library's global error state (`sit_gs.last_error_msg`, `sit_gs.last_error_code`) is updated with a specific error code and a descriptive message (either from shaderc or an internal error).
 *
 * @note This function requires the `SITUATION_ENABLE_SHADER_COMPILER` define to be set, as it directly depends on the `shaderc` library.
 * @warning The returned `_SituationSpirvBlob` contains an `internal_result` object (`shaderc_compilation_result_t*`) that **must** be freed later by calling `_SituationFreeSpirvBlob` to prevent memory leaks within the shaderc library.
 *          Failing to do so will result in leaked resources.
 * @warning The pointers `blob.data` and `blob.size` are only valid as long as the `blob.internal_result` object exists and has not been released.
 *
 * @see _SituationFreeSpirvBlob(), _SituationCreateVulkanShaderModule(),
 *      SituationCreateComputePipelineFromMemory()
 */
static _SituationSpirvBlob _SituationVulkanCompileGLSLtoSPIRV(
    const char* glsl_source,
    const char* source_name,
    shaderc_shader_kind shader_kind)
{
    // --- 1. Input Validation ---
    // Perform basic checks on input parameters to prevent crashes or undefined behavior
    // within this function or the shaderc library.
    _SituationSpirvBlob blob = {0}; // Initialize return struct to zero/NULL

    if (!glsl_source) {
        _SituationSetErrorFromCode( SITUATION_ERROR_INVALID_PARAM, "_SituationVulkanCompileGLSLtoSPIRV: GLSL source code pointer is NULL." );
        return blob; // Return zero-initialized struct
    }
    // Check for empty string (strlen(glsl_source) == 0) could also be done,
    // but shaderc might handle it gracefully or provide its own error.
    // Let's assume non-NULL is sufficient for now.

    if (!source_name) {
        // Provide a default name for error reporting if none is given.
        // This prevents a potential crash if shaderc internally uses source_name.
        source_name = "<unnamed_shader>";
        // Alternatively, return an error:
        // _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "_SituationVulkanCompileGLSLtoSPIRV: source_name is NULL.");
        // return blob;
    }

    // --- 2. Initialize shaderc Compiler and Options ---
    // These are the core objects needed to configure and perform the compilation.
    shaderc_compiler_t compiler = shaderc_compiler_initialize();
    shaderc_compile_options_t options = shaderc_compile_options_initialize();

    // Check if initialization was successful.
    if (!compiler) {
        _SituationSetErrorFromCode( SITUATION_ERROR_GENERAL, "_SituationVulkanCompileGLSLtoSPIRV: Failed to initialize shaderc compiler." );
        // Clean up any potentially partially initialized object.
        if (options) {
            shaderc_compile_options_release(options);
        }
        return blob; // Return zero-initialized struct
    }
    if (!options) {
        _SituationSetErrorFromCode( SITUATION_ERROR_GENERAL, "_SituationVulkanCompileGLSLtoSPIRV: Failed to initialize shaderc compile options." );
        // Clean up the successfully initialized compiler.
        shaderc_compiler_release(compiler);
        return blob; // Return zero-initialized struct
    }

    // --- 3. Configure Compilation Options ---
    // Set the target environment to Vulkan 1.1. This is a good baseline that ensures
    // compatibility with the Vulkan features used by the library and also aligns with
    // OpenGL's SPIR-V capabilities (GL_ARB_gl_spirv typically supports Vulkan 1.0+ SPIR-V).
    shaderc_compile_options_set_target_env(options, shaderc_target_env_vulkan, shaderc_env_version_vulkan_1_1);

    // Enable performance optimizations for the generated SPIR-V.
    // This can reduce shader size and potentially improve runtime performance.
    shaderc_compile_options_set_optimization_level(options, shaderc_optimization_level_performance);

    // In debug builds (when NDEBUG is NOT defined), generate additional debug information.
    // This information is useful for debugging tools like RenderDoc or Nsight Graphics.
#ifndef NDEBUG
    shaderc_compile_options_set_generate_debug_info(options);
#endif

    // --- 4. Perform the Compilation ---
    // This is the core operation where shaderc processes the GLSL source.
    // strlen(glsl_source) is used to determine the length of the input string.
    // shaderc makes a copy of the source internally, so the input string can be freed
    // after this call returns.
    blob.internal_result = shaderc_compile_into_spv(
        compiler,               // The initialized shaderc compiler instance
        glsl_source,            // The GLSL source code string
        strlen(glsl_source),   // The length of the GLSL source code
        shader_kind,            // The type of shader (vertex, fragment, compute, etc.)
        source_name,            // The name for error reporting
        "main",                 // The entry point function name within the shader
        options                 // The configured compilation options
    );

    // --- 5. Release Temporary Resources ---
    // The compiler and options objects are no longer needed after the compilation call.
    // Release them immediately to free their associated resources.
    shaderc_compile_options_release(options);
    shaderc_compiler_release(compiler);

    // Check if the compilation call itself produced a result object.
    // A NULL internal_result here would indicate a fundamental failure in the
    // shaderc_compile_into_spv call itself, perhaps due to an internal error in shaderc.
    if (!blob.internal_result) {
        _SituationSetErrorFromCode( SITUATION_ERROR_SHADER_COMPILATION_FAILED, "_SituationVulkanCompileGLSLtoSPIRV: shaderc_compile_into_spv returned NULL result object." );
        // No need to call shaderc_result_release as internal_result is NULL.
        return (_SituationSpirvBlob){0}; // Explicitly return zeroed struct
    }

    // --- 6. Check Compilation Status ---
    // Even if internal_result is not NULL, the compilation might have failed.
    // shaderc reports the status separately.
    shaderc_compilation_status status = shaderc_result_get_compilation_status(blob.internal_result);

    if (status != shaderc_compilation_status_success) {
        // Compilation failed. Retrieve the detailed error message from shaderc.
        const char* error_message = shaderc_result_get_error_message(blob.internal_result);
        // Determine the most appropriate SituationError code based on the shaderc status.
        SituationError sit_error_code = SITUATION_ERROR_SHADER_COMPILATION_FAILED;
        // Map specific shaderc errors to potentially more descriptive Situation errors if needed.
        // For example:
        // if (status == shaderc_compilation_status_invalid_stage) {
        //     sit_error_code = SITUATION_ERROR_INVALID_PARAM; // Or a new specific error?
        // } else if (status == shaderc_compilation_status_compilation_error) {
        //     sit_error_code = SITUATION_ERROR_SHADER_COMPILATION_FAILED; // Default
        // }
        // For now, use the general compilation failed error.

        char full_error_msg[512]; // Buffer for a more detailed error message
        snprintf(
            full_error_msg,
            sizeof(full_error_msg),
            "_SituationVulkanCompileGLSLtoSPIRV: Shader compilation failed for '%s' (Status: %d). Details: %s",
            source_name,
            (int)status,
            (error_message && strlen(error_message) > 0) ? error_message : "<no details from shaderc>"
        );

        _SituationSetErrorFromCode(sit_error_code, full_error_msg);

        // Clean up the shaderc result object associated with the failed compilation.
        shaderc_result_release(blob.internal_result);
        blob.internal_result = NULL; // Defensive nulling
        // Return a zero-initialized struct to indicate failure.
        return (_SituationSpirvBlob){0};
    }

    // --- 7. Extract Compiled Data (On Success) ---
    // If we reach here, the compilation was successful.
    // Extract the pointer to the compiled SPIR-V bytecode and its size from the result object.
    blob.data = (const uint8_t*)shaderc_result_get_bytes(blob.internal_result);
    blob.size = shaderc_result_get_length(blob.internal_result);

    // Perform a final sanity check: ensure data is not NULL and size is not zero for a successful compilation.
    // While unlikely if status is success, it's a good defensive measure.
    if (!blob.data || blob.size == 0) {
         // This is unexpected for a successful compilation.
        _SituationSetErrorFromCode( SITUATION_ERROR_SHADER_COMPILATION_FAILED, "_SituationVulkanCompileGLSLtoSPIRV: Successful compilation yielded NULL data or zero size." );
        // Clean up the result object.
        shaderc_result_release(blob.internal_result);
        blob.internal_result = NULL;
        return (_SituationSpirvBlob){0};
    }

    // --- 8. Return Successful Result ---
    // The blob struct is now fully populated with the successful compilation result.
    // The caller is responsible for calling _SituationFreeSpirvBlob later.
    return blob;
}

/**
 * @brief [INTERNAL] Releases the memory held by a shaderc compilation result object.
 *
 * @details This helper function is responsible for cleaning up the resources associated with a `_SituationSpirvBlob`, specifically the `shaderc_compilation_result_t` object stored in its `internal_result` member.
 *          This object holds the compiled SPIR-V bytecode and any associated metadata (like error messages) generated by the shaderc library.
 *
 * @param blob A pointer to the `_SituationSpirvBlob` struct whose `internal_result` member should be freed.
 *
 * @note It is safe to call this function on a `_SituationSpirvBlob` that has not been successfully initialized by `_SituationVulkanCompileGLSLtoSPIRV` (e.g., if `internal_result` is `NULL`). In such cases, the function will simply do nothing.
 * @note This function only frees the `internal_result`. It does not modify the `data` or `size` members of the `blob` struct itself. After calling this function, the `blob` struct should be considered invalid or re-initialized before reuse.
 * @warning The `blob` pointer itself is not freed by this function. If the `_SituationSpirvBlob` struct was allocated on the heap, the caller is still responsible for freeing that memory.
 *
 * @see _SituationVulkanCompileGLSLtoSPIRV(), _SituationSpirvBlob
 */
static void _SituationFreeSpirvBlob(_SituationSpirvBlob* blob) {
    // --- 1. Input Validation ---
    // Check if the blob pointer itself is valid.
    if (!blob) {
        // Calling free on a NULL pointer is safe, but explicitly checking
        // prevents potential misuse and can aid debugging.
        return; // Silently return, consistent with freeing NULL pointers.
    }

    // --- 2. Release Shaderc Resource ---
    // Check if the internal shaderc result object exists before attempting to release it.
    if (blob->internal_result) {
        // This is the actual call to the shaderc library to release the compilation result.
        shaderc_result_release(blob->internal_result);
        // Set the pointer to NULL to indicate it's no longer valid.
        // This prevents accidental double-free if the function were called again.
        blob->internal_result = NULL;
    }

    // Note: The `data` and `size` members of the `_SituationSpirvBlob` struct
    // are not modified here. They point to memory managed by the
    // `shaderc_compilation_result_t` object, which is freed by `shaderc_result_release`.
    // After this call, `blob->data` should be considered a dangling pointer
    // relative to its original source and should not be used.
}
#endif

/**
 * @brief [INTERNAL] Creates a Vulkan Shader Module from SPIR-V bytecode.
 *
 * @details This helper function encapsulates the process of creating a `VkShaderModule` object from a block of compiled SPIR-V code. A `VkShaderModule` is a container object that holds the compiled shader code and makes it available for use in pipeline shader stages.
 *
 * @param code A pointer to the raw SPIR-V bytecode data. This data must be valid and correctly compiled SPIR-V. The function does not validate the SPIR-V itself, only that the pointer is not NULL and `code_size` is non-zero.
 * @param code_size The size of the SPIR-V bytecode data in bytes. This must be a non-zero, positive value and should be a multiple of 4, as SPIR-V is a 32-bit word-based format.
 *
 * @return A valid `VkShaderModule` handle on success.
 * @return `VK_NULL_HANDLE` if the function fails. This can occur if:
 *         - The input `code` pointer is `NULL`.
 *         - The `code_size` is 0.
 *         - The call to `vkCreateShaderModule` fails (e.g., due to invalid SPIR-V, driver issues, or device loss). A specific error message is set in the library's global error state via `_SituationSetErrorFromCode`.
 *
 * @note This function requires that `sit_gs.vk.device` is a valid and initialized `VkDevice` handle. This is guaranteed by the library's Vulkan initialization sequence if this function is called correctly.
 * @note The caller is responsible for destroying the returned `VkShaderModule` using `vkDestroyShaderModule` when it is no longer needed, typically after the pipeline using it has been created.
 * @warning The SPIR-V data pointed to by `code` is not validated by this function for correctness beyond basic size and pointer checks. Passing invalid SPIR-V can lead to errors during pipeline creation or runtime.
 *
 * @see _SituationVulkanCreateComputePipeline(), _SituationVulkanCreateGraphicsPipeline(), vkCreateShaderModule(), vkDestroyShaderModule()
 */
static VkShaderModule _SituationCreateVulkanShaderModule(const char* code, size_t code_size) {
    // --- 1. Input Validation ---
    // Check for invalid inputs before proceeding. This prevents crashes
    // and provides clearer error feedback early.
    if (!code) {
        _SituationSetErrorFromCode( SITUATION_ERROR_INVALID_PARAM, "_SituationCreateVulkanShaderModule: SPIR-V code pointer is NULL." );
        return VK_NULL_HANDLE;
    }
    if (code_size == 0) {
        _SituationSetErrorFromCode( SITUATION_ERROR_INVALID_PARAM, "_SituationCreateVulkanShaderModule: SPIR-V code size is zero." );
        return VK_NULL_HANDLE;
    }
    // Optional: Check if code_size is a multiple of 4 (size of a SPIR-V word).
    // While vkCreateShaderModule might catch this, checking here is defensive.
    if (code_size % 4 != 0) {
        _SituationSetErrorFromCode( SITUATION_ERROR_INVALID_PARAM, "_SituationCreateVulkanShaderModule: SPIR-V code size is not a multiple of 4 bytes." );
        return VK_NULL_HANDLE;
    }

    // --- 2. Prepare VkShaderModuleCreateInfo ---
    // This struct tells Vulkan how to create the shader module from the provided data.
    VkShaderModuleCreateInfo create_info = {0}; // Explicitly zero-initialize
    create_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; // Mandatory sType
    create_info.pNext = NULL; // No extension structures
    create_info.flags = 0; // No special flags for shader module creation
    create_info.codeSize = code_size; // Size of the SPIR-V bytecode in bytes
    // Cast the const char* to const uint32_t* as required by VkShaderModuleCreateInfo.
    // The Vulkan specification allows this for SPIR-V data.
    create_info.pCode = (const uint32_t*)code;

    // --- 3. Create the VkShaderModule ---
    // This is the actual Vulkan API call that creates the shader module object.
    VkShaderModule shader_module = VK_NULL_HANDLE; // Initialize handle
    VkResult result = vkCreateShaderModule(
        sit_gs.vk.device,       // The logical device the module is associated with
        &create_info,           // Creation parameters
        NULL,                   // Optional allocation callbacks (use default)
        &shader_module          // Output: the created VkShaderModule handle
    );

    // --- 4. Handle Result ---
    if (result != VK_SUCCESS) {
        // vkCreateShaderModule failed. This usually indicates a problem with
        // the provided SPIR-V data (invalid format, unsupported instructions)
        // or a driver/device issue.
        char error_detail[256];
        snprintf(
            error_detail,
            sizeof(error_detail),
            "_SituationCreateVulkanShaderModule failed: vkCreateShaderModule returned VkResult 0x%x. Check SPIR-V validity or driver state.",
            result
        );
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_SHADER_MODULE_FAILED, error_detail);
        // Ensure the output handle remains VK_NULL_HANDLE on failure.
        shader_module = VK_NULL_HANDLE;
        // Note: No need to call vkDestroyShaderModule as it wasn't successfully created.
    }

    // --- 5. Return Result ---
    // Return the created handle (VK_NULL_HANDLE on failure).
    return shader_module;
}

/**
 * @brief [INTERNAL] Creates a complete Vulkan graphics pipeline from pre-compiled SPIR-V shader files.
 * @details This is a core, high-level helper function for the Vulkan backend that orchestrates the entire process of creating a `VkPipeline`. It is a simplified entry point that assumes a standard vertex format and rendering state suitable for typical 3D rendering.
 *
 * @par Creation Process
 *   1.  **Load SPIR-V:** It reads the raw SPIR-V bytecode from the vertex and fragment shader files specified by `vs_path` and `fs_path`.
 *   2.  **Create Shader Modules:** It creates `VkShaderModule` objects from the loaded bytecode.
 *   3.  **Define Pipeline State:** It configures all the necessary creation info structs for a standard graphics pipeline, including:
 *       - `VkPipelineShaderStageCreateInfo`: Defines the vertex and fragment shader stages.
 *       - `VkPipelineVertexInputStateCreateInfo`: Defines the vertex data layout (this is currently hardcoded and assumes no specific vertex input, which is a simplification).
 *       - `VkPipelineInputAssemblyStateCreateInfo`: Sets the primitive topology to triangle lists.
 *       - `VkPipelineViewportStateCreateInfo`: Configures the viewport and scissor to be dynamic states.
 *       - `VkPipelineRasterizationStateCreateInfo`: Sets standard rasterization state (e.g., fill mode, back-face culling).
 *       - `VkPipelineMultisampleStateCreateInfo`: Disables multisampling.
 *       - `VkPipelineDepthStencilStateCreateInfo`: Enables depth testing and writing.
 *       - `VkPipelineColorBlendStateCreateInfo`: Configures standard alpha blending.
 *   4.  **Create Pipeline Layout:** It currently reuses a pre-existing, simple pipeline layout. A more advanced implementation would create or select a layout compatible with the specific shader's resource requirements.
 *   5.  **Create Graphics Pipeline:** It assembles all the state information into a `VkGraphicsPipelineCreateInfo` struct and calls `vkCreateGraphicsPipelines` to create the final `VkPipeline` object.
 *   6.  **Cleanup:** The temporary `VkShaderModule` objects are destroyed after the pipeline is successfully created.
 *
 * @param vs_path The file system path to the compiled vertex shader SPIR-V file (`.spv`).
 * @param fs_path The file system path to the compiled fragment shader SPIR-V file (`.spv`).
 *
 * @return A `SituationShader` handle populated with the created `vk_pipeline` and `vk_pipeline_layout`.
 * @return A zeroed (invalid) `SituationShader` handle if any step in the process fails (e.g., file not found, shader module creation fails, pipeline creation fails). A detailed error is set internally.
 *
 * @note This function is a simplified helper and makes several assumptions about the rendering state. For example, the vertex input state is hardcoded. A production-ready engine would have a more flexible system for defining pipeline state objects based on material or mesh properties.
 * @warning This function is for internal use only.
 *
 * @see SituationLoadShader(), _SituationReadSpirvFile(), _SituationVulkanCreateShaderModule()
 */
static SituationShader _SituationCreateVulkanPipeline(const char* vs_path, const char* fs_path) {
    SituationShader shader = {0};

    // 1. Load SPIR-V Bytecode
    size_t vs_size, fs_size;
    char* vs_code = _SituationReadSpirvFile(vs_path, &vs_size);
    char* fs_code = _SituationReadSpirvFile(fs_path, &fs_size);
    if (!vs_code || !fs_code) {
        if(vs_code) free(vs_code);
        if(fs_code) free(fs_code);
        _SituationSetErrorFromCode(SITUATION_ERROR_FILE_ACCESS, "Failed to read SPIR-V shader files");
        return shader;
    }

    // 2. Create Shader Modules
    VkShaderModule vs_module = _SituationCreateVulkanShaderModule(vs_code, vs_size);
    VkShaderModule fs_module = _SituationCreateVulkanShaderModule(fs_code, fs_size);
    free(vs_code);
    free(fs_code);

    if (vs_module == VK_NULL_HANDLE || fs_module == VK_NULL_HANDLE) {
        if(vs_module) vkDestroyShaderModule(sit_gs.vk.device, vs_module, NULL);
        if(fs_module) vkDestroyShaderModule(sit_gs.vk.device, fs_module, NULL);
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_PIPELINE_FAILED, "Failed to create shader modules");
        return shader;
    }

    // 3. Define Shader Stages
    VkPipelineShaderStageCreateInfo vs_stage_info = { .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, .stage = VK_SHADER_STAGE_VERTEX_BIT, .module = vs_module, .pName = "main" };
    VkPipelineShaderStageCreateInfo fs_stage_info = { .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, .stage = VK_SHADER_STAGE_FRAGMENT_BIT, .module = fs_module, .pName = "main" };
    VkPipelineShaderStageCreateInfo shader_stages[] = {vs_stage_info, fs_stage_info};

    // 4. Define Vertex Input, Assembly, Viewport, Rasterization, etc.
    // This part is complex and depends heavily on the mesh format and desired state.
    // This is a simplified example for a standard 3D mesh.
    VkPipelineVertexInputStateCreateInfo vertex_input_info = { .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO }; // Assumes vertex data is bound elsewhere
    VkPipelineInputAssemblyStateCreateInfo input_assembly = { .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO, .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, .primitiveRestartEnable = VK_FALSE };
    VkPipelineViewportStateCreateInfo viewport_state = { .sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO, .viewportCount = 1, .scissorCount = 1 };
    VkPipelineRasterizationStateCreateInfo rasterizer = { .sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO, .depthClampEnable = VK_FALSE, .rasterizerDiscardEnable = VK_FALSE, .polygonMode = VK_POLYGON_MODE_FILL, .lineWidth = 1.0f, .cullMode = VK_CULL_MODE_BACK_BIT, .frontFace = VK_FRONT_FACE_CLOCKWISE, .depthBiasEnable = VK_FALSE };
    VkPipelineMultisampleStateCreateInfo multisampling = { .sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO, .sampleShadingEnable = VK_FALSE, .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT };
    VkPipelineDepthStencilStateCreateInfo depth_stencil = { .sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO, .depthTestEnable = VK_TRUE, .depthWriteEnable = VK_TRUE, .depthCompareOp = VK_COMPARE_OP_LESS, .depthBoundsTestEnable = VK_FALSE, .stencilTestEnable = VK_FALSE };
    VkPipelineColorBlendAttachmentState color_blend_attachment = { .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT, .blendEnable = VK_TRUE, .srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA, .dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA, .colorBlendOp = VK_BLEND_OP_ADD, .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE, .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO, .alphaBlendOp = VK_BLEND_OP_ADD };
    VkPipelineColorBlendStateCreateInfo color_blending = { .sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO, .logicOpEnable = VK_FALSE, .attachmentCount = 1, .pAttachments = &color_blend_attachment };
    VkDynamicState dynamic_states[] = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR };
    VkPipelineDynamicStateCreateInfo dynamic_state_info = { .sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, .dynamicStateCount = 2, .pDynamicStates = dynamic_states };

    // 5. Create Pipeline Layout
    // This defines what uniforms/push constants the pipeline will use. A real engine has a complex system for this.
    // For now, we assume a simple, empty layout created during init.
    // VkPipelineLayoutCreateInfo pipeline_layout_info = ...
    // vkCreatePipelineLayout(sit_gs.vk.device, &pipeline_layout_info, NULL, &shader.pipeline_layout);
    shader.pipeline_layout = sit_gs.vk.quad_pipeline_layout; // REUSING A PRE-CREATED ONE for simplicity

    // 6. Create the Graphics Pipeline
    VkGraphicsPipelineCreateInfo pipeline_info = { .sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO };
    pipeline_info.stageCount = 2;
    pipeline_info.pStages = shader_stages;
    pipeline_info.pVertexInputState = &vertex_input_info;
    pipeline_info.pInputAssemblyState = &input_assembly;
    pipeline_info.pViewportState = &viewport_state;
    pipeline_info.pRasterizationState = &rasterizer;
    pipeline_info.pMultisampleState = &multisampling;
    pipeline_info.pDepthStencilState = &depth_stencil;
    pipeline_info.pColorBlendState = &color_blending;
    pipeline_info.pDynamicState = &dynamic_state_info;
    pipeline_info.layout = shader.pipeline_layout;
    pipeline_info.renderPass = sit_gs.vk.main_window_render_pass; // This pipeline is compatible with the main render pass
    pipeline_info.subpass = 0;

    VkResult result = vkCreateGraphicsPipelines(sit_gs.vk.device, VK_NULL_HANDLE, 1, &pipeline_info, NULL, &shader.pipeline);
    if (result != VK_SUCCESS) {
        char err_msg[256];
        snprintf(err_msg, sizeof(err_msg), "vkCreateGraphicsPipelines failed: VkResult = %d", (int)result);
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_PIPELINE_FAILED, err_msg);

        // Clean up shader modules (existing)
        if (vs_module != VK_NULL_HANDLE) {
            vkDestroyShaderModule(sit_gs.vk.device, vs_module, NULL);
        }
        if (fs_module != VK_NULL_HANDLE) {
            vkDestroyShaderModule(sit_gs.vk.device, fs_module, NULL);
        }
        // Clean up pipeline layout if it was created (NEW FIX)
        if (shader.pipeline_layout != VK_NULL_HANDLE) {
            vkDestroyPipelineLayout(sit_gs.vk.device, shader.pipeline_layout, NULL);
        }
        if (error_code) *error_code = SITUATION_ERROR_VULKAN_PIPELINE_FAILED;

        return (SituationShader){0}; // Return invalid shader
    }
}


// --- Main Vulkan Initializer ---

/**
 * @brief [INTERNAL] Orchestrates the complete initialization of the Vulkan rendering backend.
 * @details This is the master function for setting up the Vulkan environment. It is called once during `SituationInit` and executes a multi-phase sequence to create all necessary Vulkan objects, from the instance and device to the swapchain and internal renderers.
 *          This function is responsible for establishing the library's high-performance resource management models, including the persistent descriptor set infrastructure.
 *
 * @par Initialization Sequence
 *   The function proceeds through several distinct phases:
 *   1.  **Core API Setup:** Creates the `VkInstance`, validation layers (if enabled), `VkSurfaceKHR`, selects a suitable `VkPhysicalDevice`, and creates the `VkDevice`. It also initializes the Vulkan Memory Allocator (VMA).
 *   2.  **Framing Setup:** Determines the optimal number of in-flight frames based on swapchain capabilities and allocates the per-frame arrays for command buffers, semaphores, and fences.
 *   3.  **Frame-Independent Resources:** Creates resources that are not tied to a specific frame, including the swapchain, main render pass, and depth buffer.
 *   4.  **Descriptor Infrastructure:** Critically, it sets up the descriptor set architecture. This includes creating a dedicated descriptor pool (`persistent_descriptor_pool`) that allows
 *       individual set freeing, and the `VkDescriptorSetLayout`s that define the standard interface for binding single UBOs, SSBOs, and textures. This is the foundation of the library's efficient binding model.
 *   5.  **Per-Frame Resources:** Creates the per-frame command buffers, synchronization objects (semaphores/fences), and the UBOs used for global view/projection data.
 *   6.  **Internal Renderers:** Initializes the pipelines and vertex buffers required for the library's internal rendering helpers, such as the 2D quad renderer.
 *
 * @param init_info A pointer to the `SituationInitInfo` struct, containing user-defined configuration like enabling validation layers and the window title.
 *
 * @return SITUATION_SUCCESS on successful initialization of all Vulkan components.
 * @return An appropriate `SituationError` code if any phase of the initialization fails. The function will halt on the first error and return immediately.
 *
 * @note This is a complex orchestrator function. Each sub-step (e.g., `_SituationVulkanCreateInstance`) is handled by a dedicated helper function for clarity and modularity.
 * @warning This function is for internal use by `SituationInit` only and must not be called directly.
 *          It assumes that `_SituationInitPlatform` and `_SituationInitWindow` have already been called successfully.
 */
static SituationError _SituationInitVulkan(const SituationInitInfo* init_info) {
    // --- Phase 1: Establish Core Vulkan API Handles ---
    if (_SituationVulkanCreateInstance(init_info) != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_INSTANCE_FAILED; }
    if (_SituationVulkanSetupDebugMessenger(init_info) != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_INSTANCE_FAILED; }
    if (_SituationVulkanCreateSurface() != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_INIT_FAILED; }
    if (_SituationVulkanPickPhysicalDevice() != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_DEVICE_FAILED; }
    if (_SituationVulkanCreateLogicalDevice(init_info) != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_DEVICE_FAILED; }
    if (_SituationVulkanCreateAllocator() != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED; }
    if (_SituationVulkanCreateCommandPool() != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_COMMAND_FAILED; }

    // --- Phase 2: Determine Dynamic Frame Count & Allocate Per-Frame State ---
    uint32_t desired_frames = (init_info->max_frames_in_flight > 1) ? init_info->max_frames_in_flight : 2;
    _SituationVulkanSwapchainSupportDetails support_details;
    _SituationVulkanQuerySwapchainSupport(sit_gs.vk.physical_device, &support_details);

    uint32_t image_count = support_details.capabilities.minImageCount + 1;
    if (support_details.capabilities.maxImageCount > 0 && image_count > support_details.capabilities.maxImageCount) {
        image_count = support_details.capabilities.maxImageCount;
    }
    _SituationVulkanFreeSwapchainSupportDetails(&support_details);

    sit_gs.vk.max_frames_in_flight = (desired_frames < image_count) ? desired_frames : image_count;
    printf("Situation [Vulkan]: Using %u frames in flight.\n", sit_gs.vk.max_frames_in_flight);

    uint32_t frame_count = sit_gs.vk.max_frames_in_flight;
    // Use calloc to zero-initialize all handles to NULL
    sit_gs.vk.command_buffers = calloc(frame_count, sizeof(VkCommandBuffer));
    sit_gs.vk.image_available_semaphores = calloc(frame_count, sizeof(VkSemaphore));
    sit_gs.vk.render_finished_semaphores = calloc(frame_count, sizeof(VkSemaphore));
    sit_gs.vk.in_flight_fences = calloc(frame_count, sizeof(VkFence));
    sit_gs.vk.view_proj_ubo_buffer = calloc(frame_count, sizeof(VkBuffer));
    sit_gs.vk.view_proj_ubo_memory = calloc(frame_count, sizeof(VmaAllocation));
    sit_gs.vk.view_proj_ubo_descriptor_set = calloc(frame_count, sizeof(VkDescriptorSet));

    if (!sit_gs.vk.command_buffers || !sit_gs.vk.image_available_semaphores || !sit_gs.vk.render_finished_semaphores || !sit_gs.vk.in_flight_fences || !sit_gs.vk.view_proj_ubo_buffer || !sit_gs.vk.view_proj_ubo_memory || !sit_gs.vk.view_proj_ubo_descriptor_set) {
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Per-frame Vulkan resource arrays");
        _SituationCleanupVulkan(); // The main cleanup function will free any non-NULL arrays
        return SITUATION_ERROR_MEMORY_ALLOCATION;
    }

    // --- Phase 3 & 4: Frame-Independent and Descriptor Infrastructure ---
    if (_SituationVulkanCreateSwapchain() != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED; }
    if (_SituationVulkanCreateImageViews() != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED; }
    if (_SituationVulkanCreateRenderPass() != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_RENDERPASS_FAILED; }
    if (_SituationVulkanCreateDepthResources() != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_FRAMEBUFFER_FAILED; }
    if (_SituationVulkanCreateFramebuffers() != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_FRAMEBUFFER_FAILED; }

    // [SIMPLIFIED] Use ONE unified descriptor pool for everything.
    VkDescriptorPoolSize pool_sizes[] = {
        { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, SITUATION_VULKAN_UNIFORM_BUFFER_SIZE + frame_count },
        { VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, SITUATION_VULKAN_STORAGE_BUFFER_SIZE },
        { VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, SITUATION_VULKAN_COMBINED_IMAGE_SAMPLER_SIZE },
        { VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, SITUATION_VULKAN_DEFAULT_USER_STORAGE_IMAGES } 
    };

    // Update the total max sets to include the new type
    const uint32_t total_max_sets = SITUATION_VULKAN_DEFAULT_USER_UBOS + SITUATION_VULKAN_DEFAULT_USER_SSBOS + SITUATION_VULKAN_DEFAULT_USER_SAMPLERS + SITUATION_VULKAN_DEFAULT_USER_STORAGE_IMAGES + frame_count;
  
    VkDescriptorPoolCreateInfo pool_info = { .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO, .flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT, .maxSets = total_max_sets, .poolSizeCount = sizeof(pool_sizes) / sizeof(pool_sizes[0]), .pPoolSizes = pool_sizes };
    
    
    
    if (vkCreateDescriptorPool(sit_gs.vk.device, &pool_info, NULL, &sit_gs.vk.persistent_descriptor_pool) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED, "Failed to create unified descriptor pool.");
        _SituationCleanupVulkan();
        return SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED;
    }
    sit_gs.vk.descriptor_pool = sit_gs.vk.persistent_descriptor_pool; // Point the old pool to the new unified one.

    // Create Descriptor Set Layouts for standard resource types
    VkDescriptorSetLayoutBinding ubo_binding = { 0, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1, VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_COMPUTE_BIT, NULL };
    VkDescriptorSetLayoutCreateInfo ubo_layout_info = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, NULL, 0, 1, &ubo_binding };
    if (vkCreateDescriptorSetLayout(sit_gs.vk.device, &ubo_layout_info, NULL, &sit_gs.vk.ubo_layout) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED, "Failed to create UBO layout.");
        _SituationCleanupVulkan();
        return SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED;
    }

    VkDescriptorSetLayoutBinding ssbo_binding = { 0, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_COMPUTE_BIT, NULL };
    VkDescriptorSetLayoutCreateInfo ssbo_layout_info = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, NULL, 0, 1, &ssbo_binding };
    if (vkCreateDescriptorSetLayout(sit_gs.vk.device, &ssbo_layout_info, NULL, &sit_gs.vk.ssbo_layout) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED, "Failed to create SSBO layout.");
        _SituationCleanupVulkan();
        return SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED;
    }

    // Create layouts for internal renderers
    VkDescriptorSetLayoutBinding ubo_layout_binding_internal = { SIT_UBO_BINDING_VIEW_DATA, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1, VK_SHADER_STAGE_VERTEX_BIT, NULL };
    VkDescriptorSetLayoutCreateInfo ubo_layout_info_internal = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, NULL, 0, 1, &ubo_layout_binding_internal };
    if (vkCreateDescriptorSetLayout(sit_gs.vk.device, &ubo_layout_info_internal, NULL, &sit_gs.vk.view_data_ubo_layout) != VK_SUCCESS) {
        _SituationCleanupVulkan();
        return SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED;
    }

    VkDescriptorSetLayoutBinding sampler_layout_binding = { SIT_SAMPLER_BINDING_VD_SOURCE, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, NULL };
    VkDescriptorSetLayoutCreateInfo sampler_layout_info = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, NULL, 0, 1, &sampler_layout_binding };
    if (vkCreateDescriptorSetLayout(sit_gs.vk.device, &sampler_layout_info, NULL, &sit_gs.vk.image_sampler_layout) != VK_SUCCESS) {
         _SituationCleanupVulkan();
         return SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED;
    }

    // --- Phase 5 & 6: Per-Frame Objects and Internal Renderers ---
    if (_SituationVulkanCreateCommandBuffers() != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_COMMAND_FAILED; }
    if (_SituationVulkanCreateSyncObjects() != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_SYNC_OBJECT_FAILED; }

    for (uint32_t i = 0; i < frame_count; i++) {
        VkDeviceSize buffer_size = sizeof(ViewDataUBO);
        if (_SituationVulkanCreateAndUploadBuffer(NULL, buffer_size, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, &sit_gs.vk.view_proj_ubo_buffer[i], &sit_gs.vk.view_proj_ubo_memory[i]) != SITUATION_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED; }

        VkDescriptorSetAllocateInfo alloc_info = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, NULL, sit_gs.vk.descriptor_pool, 1, &sit_gs.vk.view_data_ubo_layout };
        if (vkAllocateDescriptorSets(sit_gs.vk.device, &alloc_info, &sit_gs.vk.view_proj_ubo_descriptor_set[i]) != VK_SUCCESS) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED; }

        VkDescriptorBufferInfo buffer_info = { sit_gs.vk.view_proj_ubo_buffer[i], 0, buffer_size };
        VkWriteDescriptorSet write = { VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, NULL, sit_gs.vk.view_proj_ubo_descriptor_set[i], SIT_UBO_BINDING_VIEW_DATA, 0, 1, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, NULL, &buffer_info, NULL };
        vkUpdateDescriptorSets(sit_gs.vk.device, 1, &write, 0, NULL);
    }

    if (_SituationVulkanInitComputeLayouts() != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_PIPELINE_FAILED, "Failed to create pre-defined compute pipeline layouts.");
        _SituationCleanupVulkan();
        return SITUATION_ERROR_VULKAN_PIPELINE_FAILED;
    }

    if (!_SituationVulkanInitInternalRenderers()) { _SituationCleanupVulkan(); return SITUATION_ERROR_VULKAN_PIPELINE_FAILED; }

    sit_gs.renderer_type = SIT_RENDERER_VULKAN;
    return SITUATION_SUCCESS;
}


// --- Helper Implementations ---

/**
 * @brief [INTERNAL] Builds a list of required Vulkan instance extensions.
 *
 * @details This helper function consolidates the list of Vulkan instance extensions required for the application to function correctly. This includes:
 * - Extensions mandated by GLFW for window surface creation (e.g., `VK_KHR_surface`).
 * - The `VK_EXT_debug_utils` extension if runtime validation is enabled.
 * - Platform-specific extensions required for compatibility (e.g., `VK_KHR_portability_enumeration` on macOS with MoltenVK).
 *
 * @param out_extension_count A pointer to a `uint32_t` where the number of extensions in the returned list will be stored.
 *                            This pointer must not be NULL.
 * @param enable_validation   A boolean flag indicating whether Vulkan validation layers are enabled. If true, the debug utils extension will be included in the list.
 *
 * @return A pointer to a statically allocated array of `const char*` strings, each representing a required Vulkan instance extension name.
 *         The array's length is given by the value written to `out_extension_count`.
 *         The returned pointer is valid only until the next call to this function.
 * @return NULL If GLFW reports no required instance extensions, or if `out_extension_count` is NULL.
 *
 * @note This function uses a statically allocated internal buffer to hold the
 *       list of extension names. The maximum number of extensions it can handle is defined by `SITUATION_VULKAN_MAX_INSTANCE_EXTENSIONS` (currently 16).
 *       If the total required extensions exceed this limit, an error message is logged, and the function's behavior is undefined (likely truncation or crash).
 *       This limit is considered sufficient for standard use cases.
 *
 * @see _SituationVulkanCreateInstance()
 */
static const char** _SituationVulkanGetRequiredExtensions(uint32_t* out_extension_count, bool enable_validation) {
    // --- 1. Input Validation ---
    if (!out_extension_count) {
        // Cannot output the count, so the result would be unusable.
        // This is a logic error in the caller.
        // fprintf(stderr, "ERROR: _SituationVulkanGetRequiredExtensions: out_extension_count is NULL.\n");
        // Using _SituationSetErrorFromCode might be overkill for an internal helper,
        // but could be considered if the library does this for internal helpers.
        return NULL;
    }
    *out_extension_count = 0; // Initialize output count to zero in case of early return.

    // --- 2. Get GLFW Required Extensions ---
    uint32_t glfw_extension_count = 0;
    const char** glfw_extensions = glfwGetRequiredInstanceExtensions(&glfw_extension_count);

    // If GLFW reports no extensions are needed, return an empty list.
    if (glfw_extensions == NULL || glfw_extension_count == 0) {
        // This is unusual but not necessarily an error depending on the platform/context.
        // fprintf(stderr, "WARNING: GLFW reported no required Vulkan instance extensions.\n");
        return NULL; // *out_extension_count is already 0.
    }

    // --- 3. Aggregate Extensions into Static Array ---
    // Define a reasonable limit for the number of extensions.
    // This should cover GLFW extensions + debug utils + platform specifics.
    static const char* extensions[SITUATION_VULKAN_MAX_INSTANCE_EXTENSIONS];
    uint32_t count = 0;

    // --- 4. Add GLFW Extensions ---
    for (uint32_t i = 0; i < glfw_extension_count; ++i) {
        if (count >= SITUATION_VULKAN_MAX_INSTANCE_EXTENSIONS) {
            // This should not happen with standard setups, but protect against overflow.
            fprintf(stderr, "ERROR: _SituationVulkanGetRequiredExtensions: Exceeded maximum extension limit (%d). Truncating list.\n", SITUATION_VULKAN_MAX_INSTANCE_EXTENSIONS);
            break; // Stop adding extensions to prevent buffer overrun.
        }
        extensions[count++] = glfw_extensions[i];
    }

    // --- 5. Add Validation Extension (if enabled) ---
    if (enable_validation) {
        if (count >= SITUATION_VULKAN_MAX_INSTANCE_EXTENSIONS) {
            fprintf(stderr, "ERROR: _SituationVulkanGetRequiredExtensions: Exceeded maximum extension limit (%d) when adding VK_EXT_DEBUG_UTILS_EXTENSION_NAME.\n", SITUATION_VULKAN_MAX_INSTANCE_EXTENSIONS);
            // Cannot add it, list is full.
        } else {
            extensions[count++] = VK_EXT_DEBUG_UTILS_EXTENSION_NAME;
        }
    }

    // --- 6. Add Platform-Specific Extensions ---
#if defined(__APPLE__)
    {
        // --- macOS / MoltenVK Specific Extensions ---
        // VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME is required on macOS
        // to allow enumerating portability-compliant devices.
        if (count >= SITUATION_VULKAN_MAX_INSTANCE_EXTENSIONS) {
            fprintf(stderr, "ERROR: _SituationVulkanGetRequiredExtensions: Exceeded maximum extension limit (%d) when adding VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME.\n", SITUATION_VULKAN_MAX_INSTANCE_EXTENSIONS);
        } else {
            extensions[count++] = VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME;
        }

        // VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME is core in Vulkan 1.1
        // but explicitly enabling it can be good for portability layers.
        // Uncomment the lines below if this extension is deemed necessary.
        /*
        if (count >= SITUATION_VULKAN_MAX_INSTANCE_EXTENSIONS) {
            fprintf(stderr, "ERROR: _SituationVulkanGetRequiredExtensions: Exceeded maximum extension limit (%d) when adding VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME.\n", SITUATION_VULKAN_MAX_INSTANCE_EXTENSIONS);
        } else {
            extensions[count++] = VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME;
        }
        */
    }
#endif // __APPLE__

    // --- 7. Finalize and Return ---
    // Ensure the final count doesn't exceed the logical limit, though checks above should prevent it.
    if (count > SITUATION_VULKAN_MAX_INSTANCE_EXTENSIONS) {
        count = SITUATION_VULKAN_MAX_INSTANCE_EXTENSIONS; // Defensive truncation
    }

    *out_extension_count = count;
    return extensions;
#undef SITUATION_VULKAN_MAX_INSTANCE_EXTENSIONS // Undefine local macro
}

/**
 * @brief [INTERNAL] Creates the core Vulkan instance.
 *
 * @details This helper function is responsible for initializing the Vulkan runtime environment by creating the `VkInstance`. This is the first major step in the Vulkan initialization process. It involves:
 * - Specifying the application and engine information.
 * - Enumerating and requesting the necessary instance extensions (provided by GLFW and potentially for debugging/validation).
 * - Optionally enabling the standard Khronos validation layer for development/debugging.
 * - Creating the `VkInstance` handle itself.
 *
 * @param init_info A pointer to the `SituationInitInfo` struct provided during library initialization. This contains settings like the window title and whether Vulkan validation should be enabled.
 *                  This pointer must not be NULL.
 *
 * @return SITUATION_SUCCESS on successful creation of the Vulkan instance.
 * @return SITUATION_ERROR_INVALID_PARAM if `init_info` is NULL.
 * @return SITUATION_ERROR_VULKAN_UNSUPPORTED if Vulkan validation is requested but the required `VK_LAYER_KHRONOS_validation` layer is not found on the system, or if GLFW cannot provide the necessary instance extensions.
 * @return SITUATION_ERROR_VULKAN_INSTANCE_FAILED if `vkCreateInstance` fails for any reason (e.g., driver issues, unsupported API version, missing extensions).
 *
 * @note This function relies on `_SituationVulkanGetRequiredExtensions` to determine the list of necessary instance extensions.
 * @note The created `VkInstance` handle is stored in `sit_gs.vk.instance`.
 *
 * @see _SituationInitVulkan(), _SituationVulkanGetRequiredExtensions()
 */
static SituationError _SituationVulkanCreateInstance(const SituationInitInfo* init_info) {
    // --- 1. Input Validation ---
    if (!init_info) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "_SituationVulkanCreateInstance: init_info is NULL.");
        return SITUATION_ERROR_INVALID_PARAM;
    }

    // --- 2. Handle Vulkan Validation Layers ---
    const char* validation_layers[] = { "VK_LAYER_KHRONOS_validation" };
    const uint32_t validation_layer_count = 1; // Number of layers in the array above

    if (init_info->enable_vulkan_validation) {
        uint32_t layer_count = 0;
        // Query the number of available instance layer properties.
        VkResult enumerate_result = vkEnumerateInstanceLayerProperties(&layer_count, NULL);
        if (enumerate_result != VK_SUCCESS) {
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_UNSUPPORTED, "Failed to enumerate Vulkan instance layer properties.");
            return SITUATION_ERROR_VULKAN_UNSUPPORTED;
        }

        // If no layers are available at all, validation cannot be enabled.
        if (layer_count == 0) {
             _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_UNSUPPORTED, "No Vulkan validation layers found on the system.");
             return SITUATION_ERROR_VULKAN_UNSUPPORTED;
        }

        // Allocate memory to hold the list of available layers.
        VkLayerProperties* available_layers = (VkLayerProperties*)malloc(sizeof(VkLayerProperties) * layer_count);
        if (!available_layers) {
             _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Failed to allocate memory for Vulkan instance layer properties.");
             return SITUATION_ERROR_MEMORY_ALLOCATION;
        }

        // Query the actual layer properties.
        enumerate_result = vkEnumerateInstanceLayerProperties(&layer_count, available_layers);
        if (enumerate_result != VK_SUCCESS) {
            free(available_layers);
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_UNSUPPORTED, "Failed to enumerate Vulkan instance layer properties (second query).");
            return SITUATION_ERROR_VULKAN_UNSUPPORTED;
        }

        // Check if the required validation layer is present in the list.
        bool layer_found = false;
        for (uint32_t i = 0; i < layer_count; i++) {
            // Compare the name of the current available layer with the one we need.
            if (strcmp(validation_layers[0], available_layers[i].layerName) == 0) {
                layer_found = true;
                break; // Found it, no need to check further
            }
        }

        // Clean up the allocated list of layer properties.
        free(available_layers);

        // If the required validation layer was not found, report an error.
        if (!layer_found) {
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_UNSUPPORTED, "Validation layer 'VK_LAYER_KHRONOS_validation' requested but not available!");
            return SITUATION_ERROR_VULKAN_UNSUPPORTED;
        }
        // If layer_found is true, we can proceed with enabling the layer.
    }
    // If validation is not enabled, no layer checks are needed.

    // --- 3. Specify Application and Engine Information ---
    VkApplicationInfo app_info = {0}; // Explicitly zero-initialize
    app_info.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    app_info.pApplicationName = init_info->window_title; // Use the title from init info
    app_info.applicationVersion = VK_MAKE_VERSION(1, 0, 0); // App version 1.0.0
    app_info.pEngineName = "Situation Engine"; // Identify the engine
    // Engine version: Consider using a central #define for SITUATION_VERSION_MAJOR/MINOR/PATCH
    app_info.engineVersion = VK_MAKE_VERSION(2, 6, 0); // Bumped version
    // Specify the target Vulkan API version. Ensure consistency with VMA and device requirements.
    app_info.apiVersion = VK_API_VERSION_1_1; // Target Vulkan 1.1

    // --- 4. Specify Instance Creation Parameters ---
    VkInstanceCreateInfo create_info = {0}; // Explicitly zero-initialize
    create_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    create_info.pApplicationInfo = &app_info; // Link the application info

    // --- 5. Get Required Instance Extensions ---
    uint32_t extension_count = 0;
    // Use the helper function to get the list of required extensions,
    // including platform-specific ones and the debug extension if validation is enabled.
    const char** required_extensions = _SituationVulkanGetRequiredExtensions(&extension_count, init_info->enable_vulkan_validation);
    if (required_extensions == NULL) {
        // The helper function should have set an error message if it failed critically.
        // If it returns NULL with extension_count=0, it might be okay (no extensions needed),
        // but GLFW needing none is unusual. Treat as an error condition.
        if (extension_count == 0) {
             _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_UNSUPPORTED, "GLFW reported no required Vulkan instance extensions, or failed to query them.");
        } // Else, error set by _SituationVulkanGetRequiredExtensions
        // If _SituationVulkanGetRequiredExtensions sets its own error, we could just return its code.
        // Assuming it sets SITUATION_ERROR_VULKAN_UNSUPPORTED on its critical failures.
        return SITUATION_ERROR_VULKAN_UNSUPPORTED;
    }
    // Set the extensions in the create info structure.
    create_info.enabledExtensionCount = extension_count;
    create_info.ppEnabledExtensionNames = required_extensions;

    // --- 6. Configure Enabled Layers (if Validation is On) ---
    if (init_info->enable_vulkan_validation) {
        // Enable the validation layer(s) by setting the count and pointer to the array.
        create_info.enabledLayerCount = validation_layer_count;
        create_info.ppEnabledLayerNames = validation_layers;
    } else {
        // No layers are enabled.
        create_info.enabledLayerCount = 0;
        create_info.ppEnabledLayerNames = NULL; // Explicitly set to NULL for clarity
    }

    // --- 7. Platform-Specific Instance Creation Flags ---
#if defined(__APPLE__)
    {
        // On macOS (when using MoltenVK), the VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR
        // flag is required to allow enumeration of portability-compliant devices.
        create_info.flags |= VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;
    }
#endif // __APPLE__

    // --- 8. Create the Vulkan Instance ---
    // This is the actual API call that creates the VkInstance handle.
    VkResult create_result = vkCreateInstance(&create_info, NULL, &sit_gs.vk.instance);
    if (create_result != VK_SUCCESS) {
        // vkCreateInstance failed. This could be due to various reasons:
        // - Unsupported API version (app_info.apiVersion)
        // - Missing or unsupported extensions
        // - Missing or unsupported layers (if enabled)
        // - Driver issues
        // - Problems with pApplicationInfo
        char error_detail[256];
        snprintf(error_detail, sizeof(error_detail),
                 "vkCreateInstance failed with VkResult 0x%x. Possible causes: unsupported API version, missing extensions/layers, driver issues.", create_result);
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_INSTANCE_FAILED, error_detail);
        return SITUATION_ERROR_VULKAN_INSTANCE_FAILED;
    }

    // --- 9. Success ---
    // If we reach here, the VkInstance was created successfully.
    // The handle is stored in sit_gs.vk.instance for use by subsequent Vulkan functions.
    return SITUATION_SUCCESS;
}

/**
 * @brief [INTERNAL] Callback function for Vulkan Validation Layer messages.
 *
 * @details This function is registered with the Vulkan instance (via `VkDebugUtilsMessengerCreateInfoEXT`) to receive debug, warning, and error messages from the Vulkan validation layers and the driver.
 *          It serves as the primary mechanism for diagnosing issues during Vulkan application development.
 *          The function receives detailed information about each message, including its severity (verbose, info, warning, error), type (general, validation, performance), and a descriptive text message. Based on the severity, it formats and prints the message to `stderr` for immediate visibility.
 *
 * @param messageSeverity The severity level of the message (e.g., `VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT`).
 * @param messageType The type of the message (e.g., `VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT`).
 * @param pCallbackData A pointer to a `VkDebugUtilsMessengerCallbackDataEXT` struct containing the detailed message information, including `pMessage`.
 * @param pUserData User-defined data pointer passed during messenger creation.
 *                  This implementation does not use it and sets it to NULL.
 *
 * @return VK_FALSE. This indicates that the Vulkan call that triggered the callback should *not* be aborted. The application should handle
 *         errors programmatically based on VkResult codes. Returning VK_TRUE would force the call to return `VK_ERROR_VALIDATION_FAILED_EXT`.
 *
 * @note This function is only used if Vulkan validation is enabled (`init_info->enable_vulkan_validation` is true) and the necessary extensions (`VK_EXT_debug_utils`) are supported and loaded.
 * @warning This function is called asynchronously from internal Vulkan threads.
 *          Therefore, it must be thread-safe. Using `fprintf` to `stderr` is generally acceptable for this purpose.
 *
 * @see _SituationVulkanSetupDebugMessenger(), VkDebugUtilsMessengerCallbackDataEXT
 */
static VKAPI_ATTR VkBool32 VKAPI_CALL _SituationVulkanDebugCallback( VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData) {
    // --- 1. Input Validation (Defensive for callback) ---
    // While Vulkan should provide valid data, checking is good practice.
    if (!pCallbackData || !pCallbackData->pMessage) {
        // Received invalid callback data. This is unusual but possible.
        // Log a basic message to indicate the problem.
        fprintf(stderr, "[Vulkan Debug Callback] ERROR: Received invalid callback data (NULL pCallbackData or pMessage).\n");
        return VK_FALSE; // Still return VK_FALSE
    }

    // --- 2. Silence Verbose Messages (Optional) ---
    // The callback is set up to receive VERBOSE, WARNING, and ERROR messages.
    // VERBOSE messages can be very noisy. Uncomment the lines below to filter them out.
    /*
    if (messageSeverity == VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT) {
        // Optionally, filter out verbose messages based on type or content.
        // For example, silence specific verbose performance messages:
        // if (messageType & VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT) {
        //     return VK_FALSE;
        // }
        // Or just return early for all verbose messages:
        return VK_FALSE;
    }
    */

    // --- 3. Format and Print Message ---
    // Determine a prefix for the message based on its severity for easier scanning.
    const char* severity_prefix = "INFO"; // Default, though VERBOSE/INFO might be filtered above
    if (messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) {
        severity_prefix = "ERROR";
    } else if (messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) {
        severity_prefix = "WARN";
    } else if (messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT) {
        severity_prefix = "VERBOSE";
    }
    // Note: INFO level is VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT

    // Determine a prefix for the message based on its type.
    const char* type_prefix = "";
    if (messageType & VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT) {
        type_prefix = "[Validation] ";
    } else if (messageType & VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT) {
        type_prefix = "[Performance] ";
    } else if (messageType & VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT) {
        type_prefix = "[General] ";
    }

    // Print the formatted message to stderr.
    // Include severity and type for quick identification.
    fprintf(
        stderr,
        "[Vulkan %s] %s%s\n",
        severity_prefix,
        type_prefix, // Includes brackets and space if applicable
        pCallbackData->pMessage
    );
    // fflush(stderr); // Optional: Force immediate output, useful if stderr is buffered.

    // --- 4. Return Value ---
    // Always return VK_FALSE to indicate that the Vulkan call should continue.
    // The application should check VkResult codes for actual errors.
    return VK_FALSE;
}

// --- Updated/Added Documentation Block for _SituationVulkanSetupDebugMessenger ---
/**
 * @brief [INTERNAL] Sets up the Vulkan Debug Utils Messenger for validation layer output.
 *
 * @details This helper function is responsible for creating and registering the `VkDebugUtilsMessengerEXT` object if Vulkan validation is enabled.
 *          This messenger routes messages from the validation layers to the `_SituationVulkanDebugCallback` function, providing essential feedback for debugging Vulkan applications.
 *
 * The process involves:
 * 1.  Checking if validation is enabled in `init_info`.
 * 2.  Preparing a `VkDebugUtilsMessengerCreateInfoEXT` struct with the desired message severity levels, message types, and the callback function pointer.
 * 3.  Dynamically loading the `vkCreateDebugUtilsMessengerEXT` function pointer using `vkGetInstanceProcAddr`, as it's an extension function.
 * 4.  Calling the loaded function to create the messenger object.
 * 5.  Storing the created messenger handle in `sit_gs.vk.debug_messenger` for later destruction.
 *
 * @param init_info A pointer to the `SituationInitInfo` struct provided during `SituationInit`. This is used to check if validation is enabled.
 *                  This pointer must not be NULL.
 *
 * @return SITUATION_SUCCESS if validation is disabled, or if the messenger is successfully created.
 * @return SITUATION_ERROR_INVALID_PARAM if `init_info` is NULL.
 * @return SITUATION_ERROR_VULKAN_INSTANCE_FAILED if the required `vkCreateDebugUtilsMessengerEXT` function pointer cannot be loaded, or if the call to create the messenger fails. A specific error message is set.
 *
 * @note This function must be called after the Vulkan instance (`sit_gs.vk.instance`) has been successfully created.
 * @note The created messenger (`sit_gs.vk.debug_messenger`) is destroyed by `_SituationCleanupVulkan`.
 * @warning This function should only be called when using the Vulkan backend (`SITUATION_USE_VULKAN` is defined).
 *
 * @see _SituationVulkanDebugCallback(), _SituationInitVulkan(), _SituationVulkanCreateInstance(), _SituationCleanupVulkan(), vkCreateDebugUtilsMessengerEXT()
 */
static SituationError _SituationVulkanSetupDebugMessenger(const SituationInitInfo* init_info) {
    // --- 1. Input Validation ---
    if (!init_info) {
        _SituationSetErrorFromCode( SITUATION_ERROR_INVALID_PARAM, "_SituationVulkanSetupDebugMessenger: init_info cannot be NULL." );
        return SITUATION_ERROR_INVALID_PARAM;
    }

    // --- 2. Check if Validation is Enabled ---
    // If the user has not requested Vulkan validation, there's nothing to set up.
    // This is a normal and common path.
    if (!init_info->enable_vulkan_validation) {
        // Ensure the debug messenger handle is clean/invalid if not used.
        sit_gs.vk.debug_messenger = VK_NULL_HANDLE;
        return SITUATION_SUCCESS;
    }

    // --- 3. Configure Debug Messenger Creation Info ---
    // This struct defines what kinds of messages we want to receive and how to handle them.
    VkDebugUtilsMessengerCreateInfoEXT create_info = {0}; // Explicitly zero-initialize
    create_info.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT; // Mandatory sType
    create_info.pNext = NULL; // No extension structures
    create_info.flags = 0; // No special flags for messenger creation

    // Specify the message severity levels we are interested in receiving.
    // VERBOSE can be very noisy, but is useful for detailed analysis.
    create_info.messageSeverity =
        VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |
        VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT | // Include INFO messages
        VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
        VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;

    // Specify the message types we are interested in receiving.
    create_info.messageType =
        VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | // General events
        VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | // Violation of valid usage
        VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT; // Potential performance issues

    // Set the callback function that will be invoked when a message is received.
    create_info.pfnUserCallback = _SituationVulkanDebugCallback;

    // pUserData allows passing custom data to the callback. We don't need it.
    create_info.pUserData = NULL;

    // --- 4. Load the Extension Function Pointer ---
    // vkCreateDebugUtilsMessengerEXT is part of the VK_EXT_debug_utils extension,
    // so it's not automatically loaded with the standard Vulkan loader.
    // We must retrieve its function pointer manually using vkGetInstanceProcAddr.
    PFN_vkCreateDebugUtilsMessengerEXT vkCreateDebugUtilsMessengerEXT_func =
        (PFN_vkCreateDebugUtilsMessengerEXT)vkGetInstanceProcAddr(sit_gs.vk.instance, "vkCreateDebugUtilsMessengerEXT");

    // Check if the function pointer was successfully loaded.
    if (vkCreateDebugUtilsMessengerEXT_func == NULL) {
        // The function pointer could not be loaded. This usually means the
        // VK_EXT_debug_utils extension is not available or not properly loaded.
        _SituationSetErrorFromCode( SITUATION_ERROR_VULKAN_INSTANCE_FAILED, "_SituationVulkanSetupDebugMessenger: Failed to load vkCreateDebugUtilsMessengerEXT function pointer. Check if VK_EXT_debug_utils is supported." );
        // Ensure the handle is explicitly invalid.
        sit_gs.vk.debug_messenger = VK_NULL_HANDLE;
        return SITUATION_ERROR_VULKAN_INSTANCE_FAILED;
    }

    // --- 5. Create the Debug Messenger ---
    // Call the loaded function to create the VkDebugUtilsMessengerEXT object.
    VkResult result = vkCreateDebugUtilsMessengerEXT_func(
        sit_gs.vk.instance, // The Vulkan instance
        &create_info,       // Creation parameters
        NULL,               // Optional allocation callbacks (use default)
        &sit_gs.vk.debug_messenger // Output: the created messenger handle
    );

    // --- 6. Handle Creation Result ---
    if (result != VK_SUCCESS) {
        // vkCreateDebugUtilsMessengerEXT failed. This is unexpected but possible.
        char error_detail[256];
        snprintf(
            error_detail,
            sizeof(error_detail),
            "_SituationVulkanSetupDebugMessenger: vkCreateDebugUtilsMessengerEXT failed (VkResult: 0x%x).",
            result
        );
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_INSTANCE_FAILED, error_detail);
        // Ensure the global handle is explicitly invalid on failure.
        sit_gs.vk.debug_messenger = VK_NULL_HANDLE;
        return SITUATION_ERROR_VULKAN_INSTANCE_FAILED;
    }

    // --- 7. Success ---
    // If we reach here, the VkDebugUtilsMessengerEXT was created successfully.
    // The handle is stored in sit_gs.vk.debug_messenger.
    // It will receive messages from the validation layers until it is destroyed by _SituationCleanupVulkan (which should use vkDestroyDebugUtilsMessengerEXT).
    // The next step in Vulkan initialization is typically picking a physical device.
    return SITUATION_SUCCESS;
}

/**
 * @brief [INTERNAL] Creates a Vulkan surface for the GLFW window.
 *
 * @details This helper function is a crucial step in the Vulkan initialization process.
 *          It instructs GLFW to create a `VkSurfaceKHR` object that represents the abstract surface of the `sit_gs.sit_glfw_window` within the Vulkan instance.
 *          This surface is essential for presenting rendered images to the screen, as it is used later to create the swapchain.
 *
 * @return SITUATION_SUCCESS on successful creation of the Vulkan surface.
 * @return SITUATION_ERROR_INVALID_PARAM if required prerequisites are not met:
 *         - `sit_gs.vk.instance` is `VK_NULL_HANDLE`.
 *         - `sit_gs.sit_glfw_window` is `NULL`.
 * @return SITUATION_ERROR_VULKAN_INIT_FAILED if `glfwCreateWindowSurface` fails to create the surface. This can happen due to incompatibilities between the Vulkan instance and the GLFW window, or platform-specific issues. A specific error message is set.
 *
 * @note This function must be called after the Vulkan instance (`sit_gs.vk.instance`) and the GLFW window (`sit_gs.sit_glfw_window`) have been successfully created.
 * @note The created `VkSurfaceKHR` handle is stored in `sit_gs.vk.surface`.
 * @note This function relies on the `VK_KHR_surface` extension being enabled (which is typically done automatically by GLFW when `glfwCreateWindowSurface` is called) and the appropriate platform-specific surface extension (e.g., `VK_KHR_win32_surface`, `VK_KHR_xcb_surface`).
 * @warning This function should only be called when using the Vulkan backend (`SITUATION_USE_VULKAN` is defined).
 *
 * @see _SituationInitVulkan(), _SituationVulkanCreateInstance(), _SituationInitWindow(), glfwCreateWindowSurface(), vkDestroySurfaceKHR()
 */
static SituationError _SituationVulkanCreateSurface(void) {
    // --- 1. Input Validation (Defensive for internal helper) ---
    // Check if the prerequisite Vulkan instance and GLFW window handles are valid.
    // While the library's init sequence should guarantee this, checking adds robustness.
    if (sit_gs.vk.instance == VK_NULL_HANDLE) {
        _SituationSetErrorFromCode( SITUATION_ERROR_INVALID_PARAM, "_SituationVulkanCreateSurface: Vulkan instance is NULL. Call _SituationVulkanCreateInstance first." );
        return SITUATION_ERROR_INVALID_PARAM;
    }
    if (sit_gs.sit_glfw_window == NULL) {
        _SituationSetErrorFromCode( SITUATION_ERROR_INVALID_PARAM, "_SituationVulkanCreateSurface: GLFW window is NULL. Call _SituationInitWindow first." );
        return SITUATION_ERROR_INVALID_PARAM;
    }

    // --- 2. Create the Vulkan Surface using GLFW ---
    // This is the core API call that bridges GLFW and Vulkan.
    // It creates a VkSurfaceKHR object associated with the GLFW window.
    // The VkAllocationCallbacks parameter is NULL, using default allocation.
    VkResult result = glfwCreateWindowSurface(
        sit_gs.vk.instance,         // The Vulkan instance
        sit_gs.sit_glfw_window,     // The GLFW window
        NULL,                       // Optional allocation callbacks
        &sit_gs.vk.surface          // Output: the created VkSurfaceKHR handle
    );

    // --- 3. Handle Result ---
    if (result != VK_SUCCESS) {
        // glfwCreateWindowSurface failed. This is a critical error for Vulkan setup.
        // Common reasons include:
        // - Incompatibility between the Vulkan instance extensions and GLFW.
        // - The GLFW window was created with GLFW_NO_API (correct for Vulkan)
        //   but there's still an issue.
        // - Platform-specific problems (e.g., missing/wrong display server libraries).
        char error_detail[256];
        snprintf(
            error_detail,
            sizeof(error_detail),
            "_SituationVulkanCreateSurface failed: glfwCreateWindowSurface returned VkResult 0x%x. Check Vulkan/Window compatibility or platform setup.",
            result
        );
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_INIT_FAILED, error_detail);
        // Ensure the global surface handle is explicitly invalid on failure.
        sit_gs.vk.surface = VK_NULL_HANDLE;
        return SITUATION_ERROR_VULKAN_INIT_FAILED;
    }

    // --- 4. Success ---
    // If we reach here, the VkSurfaceKHR was created successfully by GLFW.
    // The handle is stored in sit_gs.vk.surface and will be used subsequently
    // for swapchain creation and eventually presentation.
    // The next step in Vulkan init is typically picking a physical device
    // that supports this surface.
    return SITUATION_SUCCESS;
}

/**
 * @brief [INTERNAL] Enumerates available GPUs and selects the most suitable one for the application.
 * @details This function is a critical step in the Vulkan initialization process. It queries the system for all Vulkan-capable physical devices and evaluates each one against a set of criteria to find the best fit.
 *          The selection is performed using a scoring system implemented in the `_SituationIsDeviceSuitable` helper function.
 *
 * @par Selection Logic
 *   1.  Enumerates all `VkPhysicalDevice`s present on the system.
 *   2.  For each device, it calls `_SituationIsDeviceSuitable` which performs pass/fail checks for essential features:
 *       - Support for a graphics queue family.
 *       - Support for a presentation queue family compatible with the window surface.
 *       - Availability of the `VK_KHR_swapchain` device extension.
 *       - Adequate swapchain support (at least one format and present mode).
 *   3.  Devices that pass the essential checks are then scored based on desirable properties, with a strong preference given to discrete GPUs over integrated ones.
 *   4.  The device with the highest score is selected as the primary GPU for the application.
 *
 * Upon successful selection, this function stores the chosen `VkPhysicalDevice` handle in `sit_gs.vk.physical_device` and caches its graphics and present queue family indices for later use in logical device creation.
 *
 * @return SITUATION_SUCCESS if a suitable physical device is found and selected.
 * @return SITUATION_ERROR_VULKAN_DEVICE_FAILED if no Vulkan-capable GPUs are found, or if none of the found GPUs meet the minimum suitability requirements.
 *
 * @note This function must be called after the `VkInstance` and `VkSurfaceKHR` have been successfully created.
 * @warning This function is for internal use by `_SituationInitVulkan` only and should not be called directly.
 *
 * @see _SituationInitVulkan(), _SituationIsDeviceSuitable(), _SituationVulkanFindQueueFamilies()
 */
static SituationError _SituationVulkanPickPhysicalDevice(void) {
    uint32_t device_count = 0;
    vkEnumeratePhysicalDevices(sit_gs.vk.instance, &device_count, NULL);
    if (device_count == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_DEVICE_FAILED, "Failed to find GPUs with Vulkan support.");
        return SITUATION_ERROR_VULKAN_DEVICE_FAILED;
    }

    VkPhysicalDevice* devices = (VkPhysicalDevice*)malloc(sizeof(VkPhysicalDevice) * device_count);
    vkEnumeratePhysicalDevices(sit_gs.vk.instance, &device_count, devices);

    int max_score = 0;
    VkPhysicalDevice best_device = VK_NULL_HANDLE;

    // Iterate over all devices and find the one with the highest score
    for (uint32_t i = 0; i < device_count; i++) {
        int score = _SituationIsDeviceSuitable(devices[i]);
        if (score > max_score) {
            max_score = score;
            best_device = devices[i];
        }
    }

    free(devices);

    if (best_device == VK_NULL_HANDLE) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_DEVICE_FAILED, "Failed to find any suitable GPU.");
        return SITUATION_ERROR_VULKAN_DEVICE_FAILED;
    }

    // Store the best device and its queue family indices
    sit_gs.vk.physical_device = best_device;
    _SituationQueueFamilyIndices indices = _SituationVulkanFindQueueFamilies(best_device, sit_gs.vk.surface);
    sit_gs.vk.graphics_family_index = indices.graphics_family;
    sit_gs.vk.present_family_index = indices.present_family;

    // Log the chosen device for debugging
    VkPhysicalDeviceProperties properties;
    vkGetPhysicalDeviceProperties(best_device, &properties);
    printf("Situation [Vulkan]: Picked device '%s' with score %d\n", properties.deviceName, max_score);

    return SITUATION_SUCCESS;
}

/**
 * @brief [INTERNAL] Creates the Vulkan logical device and retrieves queue handles.
 * @details This function creates the `VkDevice` (the logical device), which is the primary interface for interacting with the selected physical device. It specifies which features, extensions, and queue families the application will use.
 *
 * @par Creation Process
 *   1.  **Queue Configuration:** It prepares one or two `VkDeviceQueueCreateInfo` structs based on the graphics and present queue family indices found by `_SituationVulkanPickPhysicalDevice`. If the indices are the same, only one queue is requested; otherwise, two are requested.
 *   2.  **Feature Enablement:** It specifies the set of `VkPhysicalDeviceFeatures` to enable. Currently, this is an empty set, but it can be expanded to request features like geometry shaders or anisotropic filtering.
 *   3.  **Extension Enablement:** It builds a list of required device-level extensions. This always includes `VK_KHR_swapchain` for rendering to a window and may include platform-specific extensions like `"VK_KHR_portability_subset"` on macOS.
 *   4.  **Device Creation:** It calls `vkCreateDevice` with the configured queues, features, and extensions to create the logical device handle.
 *   5.  **Queue Handle Retrieval:** After the device is created, it calls `vkGetDeviceQueue` to retrieve the handles for the graphics and present queues, storing them in the global state for command submission and presentation.
 *
 * @param init_info A pointer to the `SituationInitInfo` struct, used to determine if validation layers should be enabled at the device level.
 *
 * @return SITUATION_SUCCESS on successful creation of the logical device and retrieval of queue handles.
 * @return SITUATION_ERROR_VULKAN_DEVICE_FAILED if `vkCreateDevice` fails. This can happen if requested features or extensions are not supported by the physical device.
 *
 * @note This function must be called after a `VkPhysicalDevice` has been successfully selected by `_SituationVulkanPickPhysicalDevice`.
 * @warning This function is for internal use by `_SituationInitVulkan` only and should not be called directly.
 *
 * @see _SituationInitVulkan(), _SituationVulkanPickPhysicalDevice(), vkCreateDevice(), vkGetDeviceQueue()
 */
static SituationError _SituationVulkanCreateLogicalDevice(const SituationInitInfo* init_info) {
    // --- Queue Create Info (Your existing code is good) ---
    uint32_t queue_family_indices[] = { sit_gs.vk.graphics_family_index, sit_gs.vk.present_family_index };
    VkDeviceQueueCreateInfo queue_create_infos[2] = {};
    float queue_priority = 1.0f;
    uint32_t unique_queue_family_count = 1;

    queue_create_infos[0].sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    queue_create_infos[0].queueFamilyIndex = sit_gs.vk.graphics_family_index;
    queue_create_infos[0].queueCount = 1;
    queue_create_infos[0].pQueuePriorities = &queue_priority;

    if (sit_gs.vk.graphics_family_index != sit_gs.vk.present_family_index) {
        unique_queue_family_count = 2;
        queue_create_infos[1].sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
        queue_create_infos[1].queueFamilyIndex = sit_gs.vk.present_family_index;
        queue_create_infos[1].queueCount = 1;
        queue_create_infos[1].pQueuePriorities = &queue_priority;
    }

    // --- Device Features (Good as is) ---
    VkPhysicalDeviceFeatures device_features = {}; // Enable features as needed later

    // --- Device Extensions ---
    // Use a small, manageable array to build the list of required extensions.
    const char* device_extensions[4]; // Max 4 should be enough for now
    uint32_t extension_count = 0;

    // The swapchain extension is always required for rendering to a window.
    device_extensions[extension_count++] = VK_KHR_SWAPCHAIN_EXTENSION_NAME;

    // For macOS compatibility via MoltenVK, the portability subset extension is required.
    #if defined(__APPLE__)
        device_extensions[extension_count++] = "VK_KHR_portability_subset";
    #endif

    // --- Device Create Info ---
    VkDeviceCreateInfo create_info = {};
    create_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    create_info.pQueueCreateInfos = queue_create_infos;
    create_info.queueCreateInfoCount = unique_queue_family_count;
    create_info.pEnabledFeatures = &device_features;
    create_info.enabledExtensionCount = extension_count; // Use the dynamic count
    create_info.ppEnabledExtensionNames = device_extensions; // Use the new array

    // Validation layers (Good as is)
    const char* validation_layers[] = { "VK_LAYER_KHRONOS_validation" };
    if (init_info->enable_vulkan_validation) {
        create_info.enabledLayerCount = 1;
        create_info.ppEnabledLayerNames = validation_layers;
    } else {
        create_info.enabledLayerCount = 0;
    }

    // --- Create the Device ---
    if (vkCreateDevice(sit_gs.vk.physical_device, &create_info, NULL, &sit_gs.vk.device) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_DEVICE_FAILED, "Failed to create logical device");
        return SITUATION_ERROR_VULKAN_DEVICE_FAILED;
    }

    // --- Get Queue Handles (Good as is) ---
    vkGetDeviceQueue(sit_gs.vk.device, sit_gs.vk.graphics_family_index, 0, &sit_gs.vk.graphics_queue);
    vkGetDeviceQueue(sit_gs.vk.device, sit_gs.vk.present_family_index, 0, &sit_gs.vk.present_queue);

    return SITUATION_SUCCESS;
}

/**
 * @brief [INTERNAL] Creates the Vulkan Memory Allocator (VMA) instance.
 *
 * @details This helper function initializes the Vulkan Memory Allocator (VMA) library, which provides a higher-level, more efficient interface for allocating and managing GPU memory (VkDeviceMemory) and associating it with Vulkan objects like VkBuffer and VkImage.
 *          VMA handles memory type selection, sub-allocation, and defragmentation internally.
 *
 * @return SITUATION_SUCCESS on successful creation of the VMA allocator.
 * @return SITUATION_ERROR_INVALID_PARAM if required Vulkan handles (instance, physicalDevice, device) in `sit_gs.vk` are invalid.
 * @return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED if `vmaCreateAllocator` fails for any reason (e.g., incompatible Vulkan version, driver issues, internal VMA error). A specific error message is set.
 *
 * @note This function must be called after the Vulkan instance, physical device, and logical device have been successfully created and their handles
 *       stored in `sit_gs.vk.instance`, `sit_gs.vk.physical_device`, and `sit_gs.vk.device` respectively.
 * @note The created `VmaAllocator` handle is stored in `sit_gs.vk.vma_allocator`.
 * @note The target Vulkan API version is specified as `VK_API_VERSION_1_1`.
 *       Ensure this aligns with the version used in `VkApplicationInfo` and is supported by the chosen physical device and driver.
 *
 * @see _SituationInitVulkan(), _SituationVulkanCreateInstance(), _SituationVulkanPickPhysicalDevice(), _SituationVulkanCreateLogicalDevice() _SituationCleanupVulkan() (for destruction)
 */
static SituationError _SituationVulkanCreateAllocator(void) {
    // --- 1. Input Validation (Defensive for internal helper) ---
    // Check if the prerequisite Vulkan handles are valid before passing them to VMA.
    // While the library's init sequence should guarantee this, a check adds robustness.
    if (sit_gs.vk.instance == VK_NULL_HANDLE ||
        sit_gs.vk.physical_device == VK_NULL_HANDLE ||
        sit_gs.vk.device == VK_NULL_HANDLE) {
        _SituationSetErrorFromCode( SITUATION_ERROR_INVALID_PARAM, "_SituationVulkanCreateAllocator: Vulkan instance, physical device, or logical device is NULL." );
        return SITUATION_ERROR_INVALID_PARAM;
    }

    // --- 2. Configure VMA Creation Info ---
    VmaAllocatorCreateInfo allocator_info = {0}; // Explicitly zero-initialize
    allocator_info.sType = VMA_STRUCTURE_TYPE_ALLOCATOR_CREATE_INFO; // Set sType for completeness/extensibility
    allocator_info.vulkanApiVersion = VK_API_VERSION_1_1; // Specify target Vulkan API version
    allocator_info.instance = sit_gs.vk.instance; // Link to Vulkan instance
    allocator_info.physicalDevice = sit_gs.vk.physical_device; // Link to physical device
    allocator_info.device = sit_gs.vk.device; // Link to logical device
    // allocator_info.pAllocationCallbacks = NULL; // Use default allocation callbacks
    // allocator_info.pDeviceMemoryCallbacks = NULL; // No custom memory callbacks
    // allocator_info.pHeapSizeLimit = NULL; // No heap size limits
    // allocator_info.flags = 0; // No special flags (e.g., VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT)

    // --- 3. Create the VMA Allocator ---
    // This is the actual call to the VMA library to create the allocator instance.
    VkResult result = vmaCreateAllocator(&allocator_info, &sit_gs.vk.vma_allocator);
    if (result != VK_SUCCESS) {
        // vmaCreateAllocator failed. This usually indicates a problem with
        // the provided Vulkan handles, an unsupported API version, or an internal VMA issue.
        char error_detail[256];
        snprintf(
            error_detail,
            sizeof(error_detail),
            "Failed to create Vulkan Memory Allocator (VMA) (VkResult: 0x%x). Check Vulkan handles, API version (1.1), or driver compatibility.",
            result
        );
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED, error_detail);
        // Ensure the handle is explicitly invalid on failure.
        sit_gs.vk.vma_allocator = VK_NULL_HANDLE;
        return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED;
    }

    // --- 4. Success ---
    // If we reach here, the VmaAllocator was created successfully.
    // The handle is stored in sit_gs.vk.vma_allocator for use by subsequent
    // buffer/image creation functions that rely on VMA.
    return SITUATION_SUCCESS;
}

/**
 * @brief [INTERNAL] Frees memory allocated by `_SituationVulkanQuerySwapchainSupport`.
 * @details This is a mandatory cleanup utility function. It frees the dynamically allocated arrays for surface formats and presentation modes that are stored within a `_SituationVulkanSwapchainSupportDetails` struct.
 *          It must be called after the details gathered by the query function are no longer needed to prevent memory leaks.
 *
 * @param details A pointer to the `_SituationVulkanSwapchainSupportDetails` struct whose internal arrays should be freed. It is safe to pass NULL to this function.
 *
 * @note This function is for internal use only and is a critical part of the resource management for Vulkan initialization helpers.
 *
 * @see _SituationVulkanQuerySwapchainSupport()
 */
static void _SituationVulkanFreeSwapchainSupportDetails(SituationSwapchainSupportDetails* details) {
    if (details == NULL) return;
    // free() is safe to call on a NULL pointer.
    free(details->formats);
    free(details->present_modes);
    // No need to zero out the struct, as it's typically a stack-allocated variable
    // that will go out of scope.
}

/**
 * @brief [INTERNAL] Queries a physical device for its swapchain support details for the active surface.
 * @details This function populates a `_SituationVulkanSwapchainSupportDetails` struct with all the necessary information required to create a valid swapchain. This includes:
 *          1.  Surface capabilities (min/max image count, current extent, supported transforms, etc.).
 *          2.  A list of available surface formats (`VkSurfaceFormatKHR`).
 *          3.  A list of available presentation modes (`VkPresentModeKHR`).
 *
 * @warning This function allocates new memory for the `formats` and `present_modes` arrays within the `out_details` struct. The caller is **responsible** for freeing this memory by calling `_SituationVulkanFreeSwapchainSupportDetails()` on the struct once the data is no longer needed.
 *          Failure to do so will result in a memory leak.
 *
 * @param device The `VkPhysicalDevice` to query.
 * @param[out] out_details A pointer to the struct that will be filled with the queried support details. This pointer must not be NULL.
 *
 * @note This function must be called after the `VkInstance` and `VkSurfaceKHR` have been created. It is a key prerequisite for both device suitability checks and swapchain creation.
 * @note This function is for internal use only.
 *
 * @see _SituationVulkanFreeSwapchainSupportDetails(), _SituationIsDeviceSuitable(), _SituationVulkanCreateSwapchain()
 */
static void _SituationVulkanQuerySwapchainSupport(VkPhysicalDevice device, SituationSwapchainSupportDetails* out_details) {
    // Get the basic surface capabilities (min/max image count, extent, etc.)
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, sit_gs.vk.surface, &out_details->capabilities);

    // Get the supported surface formats
    vkGetPhysicalDeviceSurfaceFormatsKHR(device, sit_gs.vk.surface, &out_details->format_count, NULL);
    if (out_details->format_count != 0) {
        out_details->formats = (VkSurfaceFormatKHR*)malloc(sizeof(VkSurfaceFormatKHR) * out_details->format_count);
        vkGetPhysicalDeviceSurfaceFormatsKHR(device, sit_gs.vk.surface, &out_details->format_count, out_details->formats);
    } else {
        out_details->formats = NULL;
    }

    // Get the supported presentation modes
    vkGetPhysicalDeviceSurfacePresentModesKHR(device, sit_gs.vk.surface, &out_details->present_mode_count, NULL);
    if (out_details->present_mode_count != 0) {
        out_details->present_modes = (VkPresentModeKHR*)malloc(sizeof(VkPresentModeKHR) * out_details->present_mode_count);
        vkGetPhysicalDeviceSurfacePresentModesKHR(device, sit_gs.vk.surface, &out_details->present_mode_count, out_details->present_modes);
    } else {
        out_details->present_modes = NULL;
    }
}

/**
 * @brief [INTERNAL] Evaluates a physical device to determine its suitability and assigns it a score.
 * @details This helper function is the core of the GPU selection logic. It performs a series of checks to determine if a `VkPhysicalDevice` meets the minimum requirements for the application and then scores it based on desirable properties. A score of 0 indicates the device is unsuitable.
 *
 * @par Suitability Criteria
 *   The function first performs several pass/fail checks. A device is considered unsuitable (score 0) if it fails any of these:
 *   - It does not have a queue family that supports both graphics and presentation operations.
 *   - It does not support the mandatory `VK_KHR_swapchain` device extension.
 *   - It does not offer at least one supported surface format and one presentation mode for the active window surface.
 *
 * @par Scoring System
 *   If a device passes all suitability checks, it is assigned a score based on the following preferences:
 *   - **Device Type:** Discrete GPUs are heavily favored and receive a high score (+1000), while integrated GPUs receive a smaller bonus (+100).
 *   - **Capabilities:** Additional points are awarded for features like a larger maximum 2D texture dimension, indicating a more powerful GPU.
 *
 * @param device The `VkPhysicalDevice` handle to evaluate.
 *
 * @return An integer score representing the suitability of the device. A higher score is better. Returns `0` if the device does not meet the minimum requirements.
 *
 * @note This function is for internal use by `_SituationVulkanPickPhysicalDevice` only.
 *
 * @see _SituationVulkanPickPhysicalDevice(), _SituationVulkanFindQueueFamilies(), _SituationVulkanQuerySwapchainSupport()
 */
static int _SituationIsDeviceSuitable(VkPhysicalDevice device) {
    // --- 1. Essential Feature Checks (Pass/Fail) ---

    // Check if the device supports required queue families
    _SituationQueueFamilyIndices indices = _SituationVulkanFindQueueFamilies(device, sit_gs.vk.surface);
    if (!indices.graphics_family_has_value || !indices.present_family_has_value) {
        return 0; // Not suitable
    }

    // Check for required device extension support (e.g., swapchain)
    uint32_t extension_count;
    vkEnumerateDeviceExtensionProperties(device, NULL, &extension_count, NULL);
    VkExtensionProperties* available_extensions = (VkExtensionProperties*)malloc(sizeof(VkExtensionProperties) * extension_count);
    vkEnumerateDeviceExtensionProperties(device, NULL, &extension_count, available_extensions);

    bool swapchain_supported = false;
    for (uint32_t i = 0; i < extension_count; i++) {
        if (strcmp(available_extensions[i].extensionName, VK_KHR_SWAPCHAIN_EXTENSION_NAME) == 0) {
            swapchain_supported = true;
            break;
        }
    }
    free(available_extensions);
    if (!swapchain_supported) return 0; // Not suitable

    // Check if the swapchain is adequate (has at least one format and one present mode)
    // You already have a helper for this from a previous step, let's assume it's called _SituationVulkanQuerySwapchainSupport
    _SituationVulkanSwapchainSupportDetails swapchain_support;
    _SituationVulkanQuerySwapchainSupport(device, &swapchain_support);
    bool swapchain_adequate = (swapchain_support.format_count > 0 && swapchain_support.present_mode_count > 0);
    _SituationVulkanFreeSwapchainSupportDetails(&swapchain_support); // Helper to free the format/present mode arrays
    if (!swapchain_adequate) return 0; // Not suitable

    // --- 2. Scoring Based on Desirable Properties ---
    int score = 0;
    VkPhysicalDeviceProperties device_properties;
    VkPhysicalDeviceFeatures device_features;
    vkGetPhysicalDeviceProperties(device, &device_properties);
    vkGetPhysicalDeviceFeatures(device, &device_features);

    // Strongly prefer discrete GPUs
    if (device_properties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
        score += 1000;
    } else if (device_properties.deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU) {
        score += 100;
    }

    // Add points for larger max texture size
    score += device_properties.limits.maxImageDimension2D / 1024;

    // (Future) Add points for other features
    // if (device_features.geometryShader) { score += 100; }

    return score;
}

/**
 * @brief [INTERNAL] Finds the indices of queue families that support graphics and presentation.
 * @details This function iterates through all available queue families of a given physical device to find indices for two essential capabilities:
 *          1.  A queue family that supports graphics commands (`VK_QUEUE_GRAPHICS_BIT`).
 *          2.  A queue family that supports presenting to the application's window surface (`vkGetPhysicalDeviceSurfaceSupportKHR`).
 *
 * The function returns a struct containing the found indices and boolean flags indicating whether each was found. A device is only suitable for the application if both a graphics and a present family are found.
 *
 * @param device The `VkPhysicalDevice` to inspect.
 * @param surface The `VkSurfaceKHR` to check for presentation support against.
 *
 * @return A `_SituationQueueFamilyIndices` struct. The `graphics_family_has_value` and `present_family_has_value` members will be `true` if suitable families were found, and the corresponding `_family` members will hold their indices.
 *
 * @note The graphics and present queue families may or may not be the same index. This function correctly handles both cases.
 * @note This function is for internal use only, primarily called by `_SituationIsDeviceSuitable` and `_SituationVulkanCreateSwapchain`.
 */
static _SituationQueueFamilyIndices _SituationVulkanFindQueueFamilies(VkPhysicalDevice device, VkSurfaceKHR surface) {
    _SituationQueueFamilyIndices indices = {0};

    uint32_t queue_family_count = 0;
    vkGetPhysicalDeviceQueueFamilyProperties(device, &queue_family_count, NULL);
    VkQueueFamilyProperties* queue_families = (VkQueueFamilyProperties*)malloc(sizeof(VkQueueFamilyProperties) * queue_family_count);
    vkGetPhysicalDeviceQueueFamilyProperties(device, &queue_family_count, queue_families);

    for (uint32_t i = 0; i < queue_family_count; i++) {
        if (queue_families[i].queueFlags & VK_QUEUE_GRAPHICS_BIT) {
            indices.graphics_family = i;
            indices.graphics_family_has_value = true;
        }

        VkBool32 present_support = false;
        vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &present_support);
        if (present_support) {
            indices.present_family = i;
            indices.present_family_has_value = true;
        }

        if (indices.graphics_family_has_value && indices.present_family_has_value) {
            break;
        }
    }

    free(queue_families);
    return indices;
}

/**
 * @brief [INTERNAL] Creates the Vulkan swapchain for presenting rendered images to the window.
 * @details This function creates the `VkSwapchainKHR`, which is a collection of renderable images that are queued for presentation to the screen. It is a central component of the rendering pipeline.
 *
 * @par Creation Logic
 *   1.  **Query Support:** It first calls `_SituationVulkanQuerySwapchainSupport` to get the capabilities, formats, and present modes of the selected physical device.
 *   2.  **Select Best Format:** It iterates through the available formats, strongly preferring a `VK_FORMAT_B8G8R8A8_SRGB` format for standard sRGB color correct rendering.
 *   3.  **Select Best Present Mode:** It iterates through available modes, preferring `VK_PRESENT_MODE_MAILBOX_KHR` (for low-latency, tear-free rendering) and falling back to the guaranteed `VK_PRESENT_MODE_FIFO_KHR` (standard V-Sync).
 *   4.  **Determine Extent & Image Count:** It determines the resolution of the swapchain images and the number of images in the chain based on the surface capabilities and current window size.
 *   5.  **Create Swapchain:** It populates the `VkSwapchainCreateInfoKHR` struct with the chosen settings and creates the `VkSwapchainKHR` object.
 *   6.  **Retrieve Images:** It retrieves the handles to the created `VkImage`s within the swapchain.
 *
 * Upon success, it stores the swapchain handle, image format, extent, and image handles in the global state (`sit_gs.vk`).
 *
 * @return SITUATION_SUCCESS on successful creation of the swapchain and retrieval of its images.
 * @return SITUATION_ERROR_VULKAN_UNSUPPORTED if the physical device does not offer any compatible formats or present modes.
 * @return SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED if the `vkCreateSwapchainKHR` call fails for any other reason.
 *
 * @note This function must be called after the logical device and surface have been created.
 * @warning This function is for internal use by `_SituationInitVulkan` and `_SituationVulkanRecreateSwapchain`.
 *
 * @see _SituationVulkanQuerySwapchainSupport(), _SituationVulkanCreateImageViews(), _SituationVulkanRecreateSwapchain()
 */
static SituationError _SituationVulkanCreateSwapchain(void) {
    _SituationVulkanSwapchainSupportDetails swapchain_support = {};
    _SituationVulkanQuerySwapchainSupport(sit_gs.vk.physical_device, &swapchain_support);

    if (swapchain_support.format_count == 0 || swapchain_support.present_mode_count == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_UNSUPPORTED, "GPU does not support any suitable swapchain formats or present modes.");
        _SituationVulkanFreeSwapchainSupportDetails(&swapchain_support);
        return SITUATION_ERROR_VULKAN_UNSUPPORTED;
    }

    VkSurfaceFormatKHR surface_format = swapchain_support.formats[0];
    for (uint32_t i = 0; i < swapchain_support.format_count; i++) {
        if (swapchain_support.formats[i].format == VK_FORMAT_B8G8R8A8_SRGB &&
            swapchain_support.formats[i].colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
            surface_format = swapchain_support.formats[i];
            break;
        }
    }

    VkPresentModeKHR present_mode = VK_PRESENT_MODE_FIFO_KHR;
    for (uint32_t i = 0; i < swapchain_support.present_mode_count; i++) {
        if (swapchain_support.present_modes[i] == VK_PRESENT_MODE_MAILBOX_KHR) {
            present_mode = VK_PRESENT_MODE_MAILBOX_KHR;
            break;
        }
    }

    VkExtent2D extent;
    if (swapchain_support.capabilities.currentExtent.width != UINT32_MAX) {
        extent = swapchain_support.capabilities.currentExtent;
    } else {
        int width, height;
        glfwGetFramebufferSize(sit_gs.sit_glfw_window, &width, &height);
        extent.width = (uint32_t)fmax(swapchain_support.capabilities.minImageExtent.width, fmin(swapchain_support.capabilities.maxImageExtent.width, (uint32_t)width));
        extent.height = (uint32_t)fmax(swapchain_support.capabilities.minImageExtent.height, fmin(swapchain_support.capabilities.maxImageExtent.height, (uint32_t)height));
    }

    uint32_t image_count = swapchain_support.capabilities.minImageCount + 1;
    if (swapchain_support.capabilities.maxImageCount > 0 && image_count > swapchain_support.capabilities.maxImageCount) {
        image_count = swapchain_support.capabilities.maxImageCount;
    }

    VkSwapchainCreateInfoKHR create_info = {};
    create_info.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
    create_info.surface = sit_gs.vk.surface;
    create_info.minImageCount = image_count;
    create_info.imageFormat = surface_format.format;
    create_info.imageColorSpace = surface_format.colorSpace;
    create_info.imageExtent = extent;
    create_info.imageArrayLayers = 1;
    create_info.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;

    _SituationQueueFamilyIndices indices = _SituationVulkanFindQueueFamilies(sit_gs.vk.physical_device, sit_gs.vk.surface);
    uint32_t queueFamilyIndices[] = {indices.graphics_family, indices.present_family};
    if (indices.graphics_family != indices.present_family) {
        create_info.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
        create_info.queueFamilyIndexCount = 2;
        create_info.pQueueFamilyIndices = queueFamilyIndices;
    } else {
        create_info.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
    }
    create_info.preTransform = swapchain_support.capabilities.currentTransform;
    create_info.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
    create_info.presentMode = present_mode;
    create_info.clipped = VK_TRUE;
    create_info.oldSwapchain = VK_NULL_HANDLE;

    if (vkCreateSwapchainKHR(sit_gs.vk.device, &create_info, NULL, &sit_gs.vk.swapchain) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED, "Failed to create swap chain");
        _SituationVulkanFreeSwapchainSupportDetails(&swapchain_support);
        return SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED;
    }

    vkGetSwapchainImagesKHR(sit_gs.vk.device, sit_gs.vk.swapchain, &image_count, NULL);
    sit_gs.vk.swapchain_images = (VkImage*)malloc(sizeof(VkImage) * image_count);
    vkGetSwapchainImagesKHR(sit_gs.vk.device, sit_gs.vk.swapchain, &image_count, sit_gs.vk.swapchain_images);
    sit_gs.vk.swapchain_image_format = surface_format.format;
    sit_gs.vk.swapchain_extent = extent;
    sit_gs.vk.swapchain_image_count = image_count;

    _SituationVulkanFreeSwapchainSupportDetails(&swapchain_support);
    return SITUATION_SUCCESS;
}

/**
 * @brief [INTERNAL] Creates a VkImageView for each image in the swapchain.
 * @details An image view is a mandatory component that describes how to access a `VkImage` and which parts of it are accessible. This function creates a view for each swapchain image, specifying that they will be used as 2D color textures.
 *          The created image views are essential for binding the swapchain images as render targets in a framebuffer.
 *
 * @return SITUATION_SUCCESS if all image views are created successfully.
 * @return SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED if any of the `vkCreateImageView` calls fail.
 *
 * @note This function must be called after `_SituationVulkanCreateSwapchain` has successfully retrieved the swapchain images. The created handles are stored in the `sit_gs.vk.swapchain_image_views` array.
 * @warning This function is for internal use by `_SituationInitVulkan` and `_SituationVulkanRecreateSwapchain`.
 *
 * @see _SituationVulkanCreateSwapchain(), _SituationVulkanCreateImageView()
 */
static SituationError _SituationVulkanCreateImageViews(void) {
    sit_gs.vk.swapchain_image_views = (VkImageView*)malloc(sizeof(VkImageView) * sit_gs.vk.swapchain_image_count);
    for (uint32_t i = 0; i < sit_gs.vk.swapchain_image_count; i++) {
        sit_gs.vk.swapchain_image_views[i] = _SituationVulkanCreateImageView(sit_gs.vk.swapchain_images[i], sit_gs.vk.swapchain_image_format, VK_IMAGE_ASPECT_COLOR_BIT);
        if(sit_gs.vk.swapchain_image_views[i] == VK_NULL_HANDLE) {
             _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED, "Failed to create image views");
             return SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED;
        }
    }
    return SITUATION_SUCCESS;
}

/**
 * @brief [INTERNAL] Creates the main render pass for the application window.
 * @details This function defines the structure of a render pass, specifying the attachments (color and depth), their properties, and the dependencies between subpasses. The main render pass created here is configured for standard forward rendering:
 *          - It uses one color attachment, which will be cleared at the start of the pass and stored for presentation at the end. Its layout is transitioned from `UNDEFINED` to `PRESENT_SRC_KHR`.
 *          - It uses one depth/stencil attachment, which will be cleared at the start and its contents discarded at the end.
 *          - It contains a single subpass that uses these attachments for graphics operations.
 *          - It includes a subpass dependency to ensure that color attachment operations in one frame are complete before the next frame's rendering begins.
 *
 * The resulting `VkRenderPass` is compatible with the framebuffers created for the swapchain.
 *
 * @return SITUATION_SUCCESS on successful creation of the render pass.
 * @return SITUATION_ERROR_VULKAN_UNSUPPORTED if no suitable depth format can be found on the physical device.
 * @return SITUATION_ERROR_VULKAN_RENDERPASS_FAILED if the `vkCreateRenderPass` call fails.
 *
 * @note This function must be called after the logical device has been created and the swapchain format has been determined.
 * @warning This function is for internal use by `_SituationInitVulkan` only.
 *
 * @see _SituationVulkanFindSupportedFormat(), _SituationVulkanCreateFramebuffers()
 */
static SituationError _SituationVulkanCreateRenderPass(void) {
    sit_gs.vk.depth_format = _SituationVulkanFindSupportedFormat(
        (VkFormat[]){VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT}, 3,
        VK_IMAGE_TILING_OPTIMAL, VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
    );
    if (sit_gs.vk.depth_format == VK_FORMAT_UNDEFINED) {
         _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_UNSUPPORTED, "Failed to find a supported depth format");
         return SITUATION_ERROR_VULKAN_UNSUPPORTED;
    }

    VkAttachmentDescription color_attachment = {};
    color_attachment.format = sit_gs.vk.swapchain_image_format;
    color_attachment.samples = VK_SAMPLE_COUNT_1_BIT;
    color_attachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    color_attachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    color_attachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    color_attachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    color_attachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    color_attachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

    VkAttachmentDescription depth_attachment = {};
    depth_attachment.format = sit_gs.vk.depth_format;
    depth_attachment.samples = VK_SAMPLE_COUNT_1_BIT;
    depth_attachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    depth_attachment.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    depth_attachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    depth_attachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    depth_attachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    depth_attachment.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

    VkAttachmentReference color_attachment_ref = {0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL};
    VkAttachmentReference depth_attachment_ref = {1, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL};

    VkSubpassDescription subpass = {};
    subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpass.colorAttachmentCount = 1;
    subpass.pColorAttachments = &color_attachment_ref;
    subpass.pDepthStencilAttachment = &depth_attachment_ref;

    VkSubpassDependency dependency = {};
    dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
    dependency.dstSubpass = 0;
    dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
    dependency.srcAccessMask = 0;
    dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
    dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

    VkAttachmentDescription attachments[] = {color_attachment, depth_attachment};
    VkRenderPassCreateInfo render_pass_info = {};
    render_pass_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    render_pass_info.attachmentCount = 2;
    render_pass_info.pAttachments = attachments;
    render_pass_info.subpassCount = 1;
    render_pass_info.pSubpasses = &subpass;
    render_pass_info.dependencyCount = 1;
    render_pass_info.pDependencies = &dependency;

    if (vkCreateRenderPass(sit_gs.vk.device, &render_pass_info, NULL, &sit_gs.vk.main_window_render_pass) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_RENDERPASS_FAILED, "Failed to create render pass");
        return SITUATION_ERROR_VULKAN_RENDERPASS_FAILED;
    }
    return SITUATION_SUCCESS;
}

/**
 * @brief [INTERNAL] Creates the depth buffer image and its view for the main render pass.
 * @details This function allocates a `VkImage` and its corresponding `VkImageView` to be used as the depth/stencil attachment for the main window's framebuffers. The image's dimensions are matched to the swapchain extent.
 *          The image is created in optimal device-local memory (`VMA_MEMORY_USAGE_GPU_ONLY`) for maximum performance.
 *
 * @return SITUATION_SUCCESS on successful creation of the depth image and its view.
 * @return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED if the `vmaCreateImage` call fails.
 * @return SITUATION_ERROR_VULKAN_FRAMEBUFFER_FAILED if the `vkCreateImageView` call fails.
 *
 * @note This function must be called after the swapchain extent and a suitable depth format have been determined.
 * @warning This function is for internal use by `_SituationInitVulkan` and `_SituationVulkanRecreateSwapchain`.
 *
 * @see _SituationVulkanCreateImage(), _SituationVulkanCreateImageView(), _SituationVulkanCreateFramebuffers()
 */
static SituationError _SituationVulkanCreateDepthResources(void) {
    if (_SituationVulkanCreateImage(sit_gs.vk.swapchain_extent.width, sit_gs.vk.swapchain_extent.height, sit_gs.vk.depth_format,
                                  VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VMA_MEMORY_USAGE_GPU_ONLY,
                                  &sit_gs.vk.depth_image, &sit_gs.vk.depth_image_memory) != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED, "Failed to create depth image");
        return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED;
    }
    sit_gs.vk.depth_image_view = _SituationVulkanCreateImageView(sit_gs.vk.depth_image, sit_gs.vk.depth_format, VK_IMAGE_ASPECT_DEPTH_BIT);
    if(sit_gs.vk.depth_image_view == VK_NULL_HANDLE){
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_FRAMEBUFFER_FAILED, "Failed to create depth image view");
        return SITUATION_ERROR_VULKAN_FRAMEBUFFER_FAILED;
    }
    return SITUATION_SUCCESS;
}

// --- Framebuffer Creation ---
/**
 * @brief [INTERNAL] Creates Vulkan framebuffers for the main window swapchain.
 *
 * @details This helper function is responsible for creating the `VkFramebuffer` objects that connect the swapchain images (via their image views) and the depth buffer image view to the main window's render pass.
 *          A framebuffer defines the attachments (color, depth, stencil) that will be used in a render pass instance.
 *          This function is typically called during Vulkan initialization (`_SituationInitVulkan`) after the swapchain, image views, depth resources, and main render pass have been successfully created.
 *          It allocates an array to hold the framebuffer handles, then iterates through each swapchain image view, creating a corresponding framebuffer that uses that image view as the color attachment and the shared depth image view as the depth attachment.
 *
 * @return SITUATION_SUCCESS on successful creation of all framebuffers.
 * @return SITUATION_ERROR_MEMORY_ALLOCATION if memory allocation fails for the internal array of `VkFramebuffer` handles.
 * @return SITUATION_ERROR_VULKAN_FRAMEBUFFER_FAILED if `vkCreateFramebuffer`fails for any of the framebuffers. A specific error message is set.
 *         Any successfully created framebuffers *before* the failure point will be left in the `sit_gs.vk.main_window_framebuffers` array and must be cleaned up by the caller (e.g., `_SituationVulkanCleanupSwapchain` or `_SituationCleanupVulkan`) to prevent leaks.
 *
 * @note This function requires that the following Vulkan resources are already created and valid:
 *       - `sit_gs.vk.device`
 *       - `sit_gs.vk.swapchain_image_views` (array of image views)
 *       - `sit_gs.vk.depth_image_view`
 *       - `sit_gs.vk.main_window_render_pass`
 *       - `sit_gs.vk.swapchain_extent`
 *       - `sit_gs.vk.swapchain_image_count`
 * @note The created array of `VkFramebuffer` handles is stored in `sit_gs.vk.main_window_framebuffers`. This array must be freed later by the cleanup process.
 * @warning This function is for internal use by the Vulkan initialization and swapchain recreation processes and should not be called directly by user code.
 *
 * @see _SituationInitVulkan(), _SituationVulkanRecreateSwapchain(), _SituationVulkanCleanupSwapchain(), vkCreateFramebuffer()
 */
static SituationError _SituationVulkanCreateFramebuffers(void) {
    // --- 1. Allocate Array for Framebuffer Handles ---
    // Allocate memory for the array that will hold the VkFramebuffer handles.
    // The number of framebuffers needed equals the number of swapchain images.
    sit_gs.vk.main_window_framebuffers = (VkFramebuffer*)malloc(sizeof(VkFramebuffer) * sit_gs.vk.swapchain_image_count);

    // Check if the memory allocation for the framebuffer array was successful.
    if (!sit_gs.vk.main_window_framebuffers) {
        // Allocation failed. This is a critical error for this step.
        _SituationSetErrorFromCode(
            SITUATION_ERROR_MEMORY_ALLOCATION,
            "_SituationVulkanCreateFramebuffers: Failed to allocate memory for framebuffer handle array."
        );
        // No Vulkan objects have been created yet in this function, so no cleanup is needed here.
        return SITUATION_ERROR_MEMORY_ALLOCATION;
    }

    // --- 2. Create Framebuffers for Each Swapchain Image ---
    // Iterate through each swapchain image view to create its corresponding framebuffer.
    for (uint32_t i = 0; i < sit_gs.vk.swapchain_image_count; i++) {
        // --- 2a. Define Framebuffer Attachments ---
        // Specify the attachments for this framebuffer:
        // 1. The swapchain image view (color attachment)
        // 2. The shared depth image view (depth attachment)
        VkImageView attachments[] = {
            sit_gs.vk.swapchain_image_views[i], // Color attachment (index 0)
            sit_gs.vk.depth_image_view          // Depth attachment (index 1)
        };

        // --- 2b. Configure Framebuffer Creation Info ---
        // Set up the VkFramebufferCreateInfo struct with the necessary parameters.
        VkFramebufferCreateInfo framebuffer_info = {0}; // Explicitly zero-initialize
        framebuffer_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; // Mandatory sType
        framebuffer_info.pNext = NULL; // No extension structures
        framebuffer_info.flags = 0; // No special flags for framebuffer creation
        framebuffer_info.renderPass = sit_gs.vk.main_window_render_pass; // Link to the render pass
        framebuffer_info.attachmentCount = 2; // We have two attachments (color and depth)
        framebuffer_info.pAttachments = attachments; // Pointer to the attachments array
        // Set the dimensions of the framebuffer to match the swapchain extent.
        framebuffer_info.width = sit_gs.vk.swapchain_extent.width;
        framebuffer_info.height = sit_gs.vk.swapchain_extent.height;
        framebuffer_info.layers = 1; // Number of layers (for array textures or VR, usually 1)

        // --- 2c. Create the VkFramebuffer Object ---
        // Call the Vulkan API to create the framebuffer object.
        VkResult result = vkCreateFramebuffer(
            sit_gs.vk.device,           // The logical device
            &framebuffer_info,          // Creation parameters
            NULL,                       // Optional allocation callbacks (use default)
            &sit_gs.vk.main_window_framebuffers[i] // Output: the created VkFramebuffer handle
        );

        // --- 2d. Handle Creation Result ---
        if (result != VK_SUCCESS) {
            // vkCreateFramebuffer failed for the framebuffer at index `i`.
            // This is a critical failure for the initialization process.
            char error_detail[256];
            snprintf(
                error_detail,
                sizeof(error_detail),
                "_SituationVulkanCreateFramebuffers: vkCreateFramebuffer failed for swapchain image %u (VkResult: 0x%x).",
                i,
                result
            );
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_FRAMEBUFFER_FAILED, error_detail);

            // --- 2e. Critical: Handle Partial Success and Cleanup ---
            // If framebuffer creation fails at index `i`, it means framebuffers from index 0 to `i-1` *might* have been successfully created and stored in `sit_gs.vk.main_window_framebuffers[0]` to `[i-1]`.
            //
            // It is the responsibility of the *caller* of this function (e.g., _SituationInitVulkan, _SituationVulkanRecreateSwapchain) to perform a full cleanup (e.g., by calling _SituationVulkanCleanupSwapchain) when any error is returned.
            // That cleanup process will iterate through the `sit_gs.vk.main_window_framebuffers` array and destroy any non-VK_NULL_HANDLE entries, then free the array itself.
            //
            // This function does *not* attempt to destroy the potentially successfully created framebuffers here. It simply reports the error and returns. This simplifies error handling in this function and relies on the robustness of the overall Vulkan cleanup sequence.
            //
            // Note: The `sit_gs.vk.main_window_framebuffers` array itself is left allocated but partially populated. The cleanup function must handle this state correctly.

            // Return the specific error code to signal failure to the caller.
            return SITUATION_ERROR_VULKAN_FRAMEBUFFER_FAILED;
        }

        // If we reach here, the framebuffer at index `i` was created successfully.
        // Its handle is stored in `sit_gs.vk.main_window_framebuffers[i]`.
        // The loop will continue to create the remaining framebuffers.
    }

    // --- 3. Success ---
    // If the loop completes without returning an error, all framebuffers have been successfully created and their handles are stored in the `sit_gs.vk.main_window_framebuffers` array.
    // The next step in Vulkan initialization is typically creating command buffers or synchronization objects.
    return SITUATION_SUCCESS;
}

// --- Command Pool Creation ---
/**
 * @brief [INTERNAL] Creates the primary Vulkan command pool.
 *
 * @details This helper function is responsible for creating the main `VkCommandPool` used by the Situation library for allocating command buffers.
 *          This pool is specifically created for the graphics queue family, as all recorded commands (graphics, compute, transfer) in `situation.h` are submitted to the graphics queue.
 *          The pool is created with the `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` flag. This flag is essential because it allows individual command buffers allocated from this pool to be reset using `vkResetCommandBuffer`.
 *          This is necessary for the library's command buffer model, where a single command buffer (e.g., `sit_gs.vk.command_buffers[frame_index]`) is reset and re-recorded every frame.
 *
 * @return SITUATION_SUCCESS on successful creation of the command pool.
 * @return SITUATION_ERROR_INVALID_PARAM if the Vulkan device (`sit_gs.vk.device`) is `VK_NULL_HANDLE` or if the graphics queue family index (`sit_gs.vk.graphics_family_index`) is invalid (e.g., `UINT32_MAX`).
 * @return SITUATION_ERROR_VULKAN_COMMAND_FAILED if `vkCreateCommandPool` fails to create the pool. This can happen due to invalid device handle, invalid queue family index, or driver issues. A specific error message is set.
 *
 * @note This function must be called after the Vulkan logical device (`sit_gs.vk.device`) and the graphics queue family index (`sit_gs.vk.graphics_family_index`) have been successfully determined (e.g., in `_SituationVulkanCreateLogicalDevice`).
 * @note The created `VkCommandPool` handle is stored in `sit_gs.vk.command_pool`.
 * @note This command pool is used by `_SituationVulkanCreateCommandBuffers` to allocate the per-frame command buffers.
 * @warning This function is for internal use by the Vulkan initialization process (`_SituationInitVulkan`) and should not be called directly by user code.
 *
 * @see _SituationInitVulkan(), _SituationVulkanCreateLogicalDevice(), _SituationVulkanCreateCommandBuffers(), vkCreateCommandPool()
 */
static SituationError _SituationVulkanCreateCommandPool(void) {
    // --- 1. Input Validation (Defensive for internal helper) ---
    // Check if the prerequisite Vulkan device handle is valid.
    if (sit_gs.vk.device == VK_NULL_HANDLE) {
        _SituationSetErrorFromCode( SITUATION_ERROR_INVALID_PARAM, "_SituationVulkanCreateCommandPool: Vulkan device is NULL. Call _SituationVulkanCreateLogicalDevice first." );
        return SITUATION_ERROR_INVALID_PARAM;
    }

    // Check if the graphics queue family index is valid.
    // UINT32_MAX is often used as an "unset" value.
    if (sit_gs.vk.graphics_family_index == UINT32_MAX) {
        _SituationSetErrorFromCode( SITUATION_ERROR_INVALID_PARAM, "_SituationVulkanCreateCommandPool: Graphics queue family index is invalid (UINT32_MAX). Ensure _SituationVulkanPickPhysicalDevice/_SituationVulkanCreateLogicalDevice ran successfully." );
        return SITUATION_ERROR_INVALID_PARAM;
    }

    // --- 2. Configure Command Pool Creation Info ---
    // Set up the VkCommandPoolCreateInfo struct with the necessary parameters.
    VkCommandPoolCreateInfo pool_info = {0}; // Explicitly zero-initialize
    pool_info.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; // Mandatory sType
    pool_info.pNext = NULL; // No extension structures
    // --- CRITICAL FLAG ---
    // VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT allows command buffers allocated from this pool to be individually reset using vkResetCommandBuffer.
    // This is essential for the library's per-frame command buffer recording model.
    pool_info.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
    // --- END CRITICAL FLAG ---
    // Specify the queue family that command buffers from this pool will be submitted to.
    // All library commands go to the graphics queue.
    pool_info.queueFamilyIndex = sit_gs.vk.graphics_family_index;

    // --- 3. Create the VkCommandPool ---
    // This is the actual Vulkan API call that creates the command pool object.
    VkResult result = vkCreateCommandPool(
        sit_gs.vk.device,       // The logical device the pool is associated with
        &pool_info,             // Creation parameters
        NULL,                   // Optional allocation callbacks (use default)
        &sit_gs.vk.command_pool // Output: the created VkCommandPool handle
    );

    // --- 4. Handle Creation Result ---
    if (result != VK_SUCCESS) {
        // vkCreateCommandPool failed. This is a critical error for Vulkan setup.
        // Common reasons include:
        // - Invalid device handle (sit_gs.vk.device)
        // - Invalid queue family index (sit_gs.vk.graphics_family_index)
        // - Driver issues or resource exhaustion.
        char error_detail[256];
        snprintf(
            error_detail,
            sizeof(error_detail),
            "_SituationVulkanCreateCommandPool failed: vkCreateCommandPool returned VkResult 0x%x. Check device/queue family validity or driver state.",
            result
        );
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, error_detail);
        // Ensure the global command pool handle is explicitly invalid on failure.
        sit_gs.vk.command_pool = VK_NULL_HANDLE;
        return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
    }

    // --- 5. Success ---
    // If we reach here, the VkCommandPool was created successfully.
    // The handle is stored in sit_gs.vk.command_pool.
    // The next step in Vulkan initialization is typically allocating command buffers from this pool using _SituationVulkanCreateCommandBuffers.
    return SITUATION_SUCCESS;
}

// --- Command Buffer Creation ---
/**
 * @brief [INTERNAL] Allocates the primary command buffers for each in-flight frame.
 * @details This function allocates a dedicated, primary-level `VkCommandBuffer` for each frame that can be processed concurrently (determined by `sit_gs.vk.max_frames_in_flight`).
 *          These command buffers are long-lived; one is used for each frame in a round-robin fashion. At the beginning of a frame, the corresponding command buffer is reset and then used to record all rendering and compute commands for that frame.
 *          They are allocated from the library's main command pool, which is created with the `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` flag to allow this per-frame reset behavior.
 *
 * @return `SITUATION_SUCCESS` if all command buffers are allocated successfully.
 * @return `SITUATION_ERROR_VULKAN_COMMAND_FAILED` if the `vkAllocateCommandBuffers` call fails.
 *
 * @note This function must be called after the logical device and the main command pool have been created. The allocated handles are stored in the `sit_gs.vk.command_buffers` array.
 * @warning This function is for internal use by `_SituationInitVulkan` only.
 *
 * @see _SituationInitVulkan(), _SituationVulkanCreateCommandPool(), SituationGetMainCommandBuffer()
 */
static SituationError _SituationVulkanCreateCommandBuffers(void) {
    VkCommandBufferAllocateInfo alloc_info = {};
    alloc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    alloc_info.commandPool = sit_gs.vk.command_pool;
    alloc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    // --- Use the dynamic value from the global state ---
    alloc_info.commandBufferCount = sit_gs.vk.max_frames_in_flight;

    if (vkAllocateCommandBuffers(sit_gs.vk.device, &alloc_info, sit_gs.vk.command_buffers) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to allocate command buffers");
        return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
    }
    return SITUATION_SUCCESS;
}

// --- Sync Object Creation ---
/**
 * @brief [INTERNAL] Creates the synchronization objects (semaphores and fences) for each in-flight frame.
 * @details This function creates the Vulkan synchronization primitives required to manage the render loop and ensure correct ordering between the CPU and GPU, as well as between different GPU operations.
 *          For each frame that can be "in-flight" simultaneously (determined by `sit_gs.vk.max_frames_in_flight`), this function creates:
 *   - **An `image_available_semaphore`:** This semaphore is signaled by `vkAcquireNextImageKHR` when a swapchain image is ready to be rendered to. The command buffer submission will wait on this semaphore.
 *   - **A `render_finished_semaphore`:** This semaphore is signaled by the `vkQueueSubmit` call when the command buffer has finished execution. The presentation engine will wait on this semaphore before showing the image on screen.
 *   - **An `in_flight_fence`:** This fence is signaled by `vkQueueSubmit` and is used by the CPU (`vkWaitForFences`) to wait until the frame has completely finished rendering.
 *       This prevents the CPU from starting to record commands for a new frame `N` before frame `N-max_frames_in_flight` has finished.
 *
 * The fences are created in the **signaled state** (`VK_FENCE_CREATE_SIGNALED_BIT`) to ensure that the very first frame doesn't block indefinitely waiting for a fence that has never been submitted.
 *
 * @return `SITUATION_SUCCESS` if all semaphores and fences for all in-flight frames are created successfully.
 * @return `SITUATION_ERROR_VULKAN_SYNC_OBJECT_FAILED` if any `vkCreateSemaphore` or `vkCreateFence` call fails.
 *
 * @note This function must be called after the logical device has been created and `max_frames_in_flight` has been determined.
 * @warning This function is for internal use by `_SituationInitVulkan` only.
 *
 * @see _SituationInitVulkan(), SituationAcquireFrameCommandBuffer(), SituationEndFrame()
 */
static SituationError _SituationVulkanCreateSyncObjects(void) {
    VkSemaphoreCreateInfo semaphore_info = {VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO};
    VkFenceCreateInfo fence_info = {VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, NULL, VK_FENCE_CREATE_SIGNALED_BIT};

    // --- Loop using the dynamic value from the global state ---
    for (uint32_t i = 0; i < sit_gs.vk.max_frames_in_flight; i++) {
        if (vkCreateSemaphore(sit_gs.vk.device, &semaphore_info, NULL, &sit_gs.vk.image_available_semaphores[i]) != VK_SUCCESS ||
            vkCreateSemaphore(sit_gs.vk.device, &semaphore_info, NULL, &sit_gs.vk.render_finished_semaphores[i]) != VK_SUCCESS ||
            vkCreateFence(sit_gs.vk.device, &fence_info, NULL, &sit_gs.vk.in_flight_fences[i]) != VK_SUCCESS) {
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_SYNC_OBJECT_FAILED, "Failed to create synchronization objects for a frame");
            return SITUATION_ERROR_VULKAN_SYNC_OBJECT_FAILED;
        }
    }
    return SITUATION_SUCCESS;
}

// --- Utility Helpers ---

/**
 * @brief [INTERNAL] Finds the first supported Vulkan format from a list that supports specific tiling and usage features.
 *
 * @details This helper function is used during Vulkan initialization to find suitable formats for images, such as depth buffers, that meet the required criteria.
 *          It queries the Vulkan physical device for the properties of each candidate format and returns the first one that supports the specified tiling mode and feature flags.
 *
 * @param candidates An array of `VkFormat` enums to check for support.
 * @param candidate_count The number of elements in the `candidates` array.
 * @param tiling The desired image tiling mode (`VK_IMAGE_TILING_LINEAR` or `VK_IMAGE_TILING_OPTIMAL`).
 * @param features A bitmask of `VkFormatFeatureFlags` that the format must support (e.g., `VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT`).
 * @return The first `VkFormat` from the `candidates` array that is supported with the specified `tiling` and `features`.
 * @return `VK_FORMAT_UNDEFINED` if none of the `candidates` support the requested `tiling` and `features`.
 *
 * @note This function relies on `sit_gs.vk.physical_device` being a valid handle to an enumerated physical device. This is guaranteed by the library's initialization sequence if this function is called.
 * @warning The order of formats in the `candidates` array is important.
 *          The function returns the *first* supported format found. Place preferred formats (e.g., higher precision) earlier in the list.
 *
 * @see _SituationVulkanCreateDepthResources()
 */
static VkFormat _SituationVulkanFindSupportedFormat(
    const VkFormat* candidates,
    uint32_t candidate_count,
    VkImageTiling tiling,
    VkFormatFeatureFlags features)
{
    // --- 1. Input Validation (Defensive for internal helper) ---
    // While internal, checking for null pointer or zero count prevents crashes if called incorrectly from within the library.
    if (!candidates || candidate_count == 0) {
        // Cannot find a format from an empty list.
        return VK_FORMAT_UNDEFINED;
    }

    // --- 2. Iterate Through Candidates ---
    for (uint32_t i = 0; i < candidate_count; i++) {
        VkFormat format = candidates[i];

        // --- 3. Query Format Properties ---
        // Get the properties supported by the physical device for this format.
        VkFormatProperties props;
        vkGetPhysicalDeviceFormatProperties(sit_gs.vk.physical_device, format, &props);

        // --- 4. Check for Required Features based on Tiling ---
        // Determine if the format supports the needed features for the requested tiling.
        VkFormatFeatureFlags supported_features = 0;
        if (tiling == VK_IMAGE_TILING_LINEAR) {
            supported_features = props.linearTilingFeatures;
        } else if (tiling == VK_IMAGE_TILING_OPTIMAL) {
            supported_features = props.optimalTilingFeatures;
        }
        // Note: Other tiling modes (e.g., VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT) are not handled here and would result in supported_features = 0.

        // --- 5. Match Found? ---
        // Check if ALL requested features are present in the supported features.
        if ((supported_features & features) == features) {
            // Found a suitable format. Return it immediately.
            return format;
        }
        // If not, continue checking the next candidate.
    }

    // --- 6. No Suitable Format Found ---
    // If the loop completes without returning, no candidate format met the criteria.
    return VK_FORMAT_UNDEFINED;
}

/**
 * @brief [INTERNAL] Cleans up all Vulkan resources that are directly dependent on the current swapchain.
 *
 * @details This helper function is a crucial part of the swapchain recreation process. It ensures that all objects derived from the old swapchain are destroyed before a new swapchain can be created. This prevents resource leaks and potential validation errors.
 *
 * @details This function performs the following cleanup steps:
 *          1.  Waits for the device to be idle (`vkDeviceWaitIdle`) to ensure no commands are currently using the resources to be destroyed.
 *          2.  Destroys the main window's depth image view and the depth image itself (along with its VMA allocation).
 *          3.  Iterates through and destroys all main window framebuffers stored in `sit_gs.vk.main_window_framebuffers`.
 *          4.  Frees the `sit_gs.vk.main_window_framebuffers` array itself.
 *          5.  Iterates through and destroys all swapchain image views stored in `sit_gs.vk.swapchain_image_views`.
 *          6.  Frees the `sit_gs.vk.swapchain_image_views` array itself.
 *          7.  Destroys the `VkSwapchainKHR` handle (`sit_gs.vk.swapchain`).
 *
 *          Crucially, it leaves core, swapchain-independent resources intact, such as:
 *          - The `VkDevice` (`sit_gs.vk.device`)
 *          - The `VkPhysicalDevice` (`sit_gs.vk.physical_device`)
 *          - The `VkRenderPass` (`sit_gs.vk.main_window_render_pass`)
 *          - The `VkCommandPool` and command buffers
 *          - Descriptor sets, pools, and layouts
 *          - The `VkInstance` and `VkSurfaceKHR`
 *
 * @note This function should only be called when it's safe to destroy these resources, typically just before `_SituationVulkanCreateSwapchain` is called.
 * @note It is the caller's responsibility to ensure that:
 *       1. The Vulkan device (`sit_gs.vk.device`) is valid.
 *       2. Any command buffers recording commands that use these resources have finished.
 *       3. This function is part of a coordinated swapchain recreation sequence.
 *
 * @see _SituationVulkanRecreateSwapchain(), _SituationVulkanCreateSwapchain(),
 *      _SituationVulkanCreateImageViews(), _SituationVulkanCreateDepthResources(),
 *      _SituationVulkanCreateFramebuffers()
 */
static void _SituationVulkanCleanupSwapchain(void) {
    // --- 1. Validate Device Handle (Robustness) ---
    if (sit_gs.vk.device == VK_NULL_HANDLE) {
        // Nothing to clean up if the device isn't created.
        // This can happen during partial init/cleanup.
        return;
    }

    // --- 2. Ensure GPU is Finished Using Resources ---
    // Wait for the device to be idle to guarantee no commands are using swapchain-derived resources.
    // This is the simplest and safest way, though it stalls the GPU pipeline.
    VkResult wait_result = vkDeviceWaitIdle(sit_gs.vk.device);
    if (wait_result != VK_SUCCESS) {
        // Log a warning, but proceed with cleanup to avoid leaking resources if possible.
        fprintf(stderr, "WARNING: vkDeviceWaitIdle failed (0x%x) in _SituationVulkanCleanupSwapchain. Proceeding with cleanup.\n", wait_result);
        // Depending on policy, you might choose to return or assert here if the device is in a bad state.
    }

    // --- 3. Destroy Depth Resources ---
    // These are specific to the swapchain's extent/format.
    if (sit_gs.vk.depth_image_view != VK_NULL_HANDLE) {
        vkDestroyImageView(sit_gs.vk.device, sit_gs.vk.depth_image_view, NULL);
        sit_gs.vk.depth_image_view = VK_NULL_HANDLE;
    }
    // Use the internal helper if one exists, otherwise call VMA directly.
    // Assuming _SituationVulkanDestroyImage helper exists and handles VMA destruction:
    if (sit_gs.vk.depth_image != VK_NULL_HANDLE) {
        _SituationVulkanDestroyImage(sit_gs.vk.depth_image, sit_gs.vk.depth_image_memory);
        // Or directly: vmaDestroyImage(sit_gs.vk.vma_allocator, sit_gs.vk.depth_image, sit_gs.vk.depth_image_memory);
        sit_gs.vk.depth_image = VK_NULL_HANDLE;
        sit_gs.vk.depth_image_memory = VK_NULL_HANDLE;
    }

    // --- 4. Destroy Main Window Framebuffers ---
    if (sit_gs.vk.main_window_framebuffers) { // Check if array was allocated
        for (uint32_t i = 0; i < sit_gs.vk.swapchain_image_count; i++) {
            if (sit_gs.vk.main_window_framebuffers[i] != VK_NULL_HANDLE) {
                vkDestroyFramebuffer(sit_gs.vk.device, sit_gs.vk.main_window_framebuffers[i], NULL);
                // Optional: Set to NULL for extra safety in debug builds if array might be reused
                // sit_gs.vk.main_window_framebuffers[i] = VK_NULL_HANDLE;
            }
        }
        // Free the array holding the framebuffer handles.
        free(sit_gs.vk.main_window_framebuffers);
        sit_gs.vk.main_window_framebuffers = NULL; // Important: Nullify the pointer after freeing.
    }
    // Note: sit_gs.vk.swapchain_image_count retains its value, as it's needed by _SituationVulkanCreateFramebuffers
    // which will be called next in the recreation sequence.

    // --- 5. Destroy Swapchain Image Views ---
    if (sit_gs.vk.swapchain_image_views) { // Check if array was allocated
        for (uint32_t i = 0; i < sit_gs.vk.swapchain_image_count; i++) {
            if (sit_gs.vk.swapchain_image_views[i] != VK_NULL_HANDLE) {
                vkDestroyImageView(sit_gs.vk.device, sit_gs.vk.swapchain_image_views[i], NULL);
                // Optional: Set to NULL for extra safety in debug builds
                // sit_gs.vk.swapchain_image_views[i] = VK_NULL_HANDLE;
            }
        }
        // Free the array holding the image view handles.
        free(sit_gs.vk.swapchain_image_views);
        sit_gs.vk.swapchain_image_views = NULL; // Important: Nullify the pointer after freeing.
    }

    // --- 6. Destroy the Swapchain Object ---
    if (sit_gs.vk.swapchain != VK_NULL_HANDLE) {
        vkDestroySwapchainKHR(sit_gs.vk.device, sit_gs.vk.swapchain, NULL);
        sit_gs.vk.swapchain = VK_NULL_HANDLE;
    }
    // sit_gs.vk.swapchain_image_count could be reset here, but it's often left
    // for the recreation process to potentially reuse if the new swapchain has the same count.
    // It's set correctly by _SituationVulkanCreateSwapchain.
}


/**
 * @brief [INTERNAL] Recreates the Vulkan swapchain and all resources dependent on it.
 *
 * @details This function handles the full cycle of destroying the old swapchain and its associated resources, then creating a new swapchain and rebuilding the necessary dependent objects (image views, depth buffer, framebuffers).
 *          It is typically triggered by window resize events or when Vulkan reports that the swapchain is out of date (`VK_ERROR_OUT_OF_DATE_KHR`).
 *
 * @details The recreation process involves the following steps:
 *          1.  Waits for the window to have a non-zero size (handles minimization).
 *          2.  Calls `_SituationVulkanCleanupSwapchain` to destroy old resources.
 *          3.  Calls `_SituationVulkanCreateSwapchain` to create the new swapchain.
 *          4.  Calls `_SituationVulkanCreateImageViews` to create views for the new swapchain images.
 *          5.  Calls `_SituationVulkanCreateDepthResources` to create the depth buffer for the new extent.
 *          6.  Calls `_SituationVulkanCreateFramebuffers` to create framebuffers linking the new image views and depth buffer to the render pass.
 *
 * @note This function is designed to be called when the application detects a need for swapchain recreation (e.g., in `SituationEndFrame` or a resize callback).
 *       It internally handles the waiting and cleanup.
 * @warning If any step in the recreation process fails, the Vulkan backend may be left in an inconsistent state. The application should be prepared to handle such failures, potentially by shutting down or attempting recovery.
 *
 * @see _SituationVulkanCleanupSwapchain(), SituationEndFrame()
 */
static void _SituationVulkanRecreateSwapchain(void) {
    // --- 1. Handle Window Minimization ---
    // If the window is minimized, width/height can be 0. We must wait for a valid size.
    int width = 0, height = 0;
    glfwGetFramebufferSize(sit_gs.sit_glfw_window, &width, &height);
    while (width == 0 || height == 0) {
        // Wait for events (like a resize/unminimize) to occur.
        glfwWaitEvents();
        // Re-check the size after an event.
        glfwGetFramebufferSize(sit_gs.sit_glfw_window, &width, &height);
    }

    // --- 2. Ensure GPU is Idle Before Recreation ---
    // Although CleanupSwapchain also does this, an extra wait here is defensive
    // and ensures any commands using the *old* swapchain are definitely finished.
    if (sit_gs.vk.device != VK_NULL_HANDLE) { // Defensive check
        VkResult wait_result = vkDeviceWaitIdle(sit_gs.vk.device);
        if (wait_result != VK_SUCCESS) {
            fprintf(stderr, "WARNING: vkDeviceWaitIdle failed (0x%x) before swapchain recreation. Attempting recreation anyway.\n", wait_result);
            // Depending on strictness, could return or set a global error here.
        }
    }

    // --- 3. Orchestrate Recreation Steps ---
    // It's crucial that these steps happen in order and that failures are handled.

    // 3.1. Cleanup old swapchain resources.
    _SituationVulkanCleanupSwapchain();

    // 3.2. Create the new swapchain.
    // If this fails, there's nothing to clean up further as CleanupSwapchain already ran.
    SituationError create_swapchain_result = _SituationVulkanCreateSwapchain();
    if (create_swapchain_result != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(create_swapchain_result, "_SituationVulkanRecreateSwapchain failed in _SituationVulkanCreateSwapchain.");
        // The state is now inconsistent (no swapchain). The application loop should detect this (e.g., via error state or failed subsequent BeginFrame) and handle appropriately.
        return;
    }

    // 3.3. Create image views for the new swapchain images.
    SituationError create_views_result = _SituationVulkanCreateImageViews();
    if (create_views_result != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(create_views_result, "_SituationVulkanRecreateSwapchain failed in _SituationVulkanCreateImageViews.");
        // State: Swapchain exists, but no image views.
        // Clean up the swapchain we just made.
        if (sit_gs.vk.swapchain != VK_NULL_HANDLE) {
            vkDestroySwapchainKHR(sit_gs.vk.device, sit_gs.vk.swapchain, NULL);
            sit_gs.vk.swapchain = VK_NULL_HANDLE;
        }
        return;
    }

    // 3.4. Create depth resources for the new swapchain extent.
    SituationError create_depth_result = _SituationVulkanCreateDepthResources();
    if (create_depth_result != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(create_depth_result, "_SituationVulkanRecreateSwapchain failed in _SituationVulkanCreateDepthResources.");
        // State: Swapchain and image views exist, but no depth.
        // We need to clean up the resources created so far in this cycle.
        // CleanupSwapchain can handle this general case now.
        _SituationVulkanCleanupSwapchain();
        return;
    }

    // 3.5. Create framebuffers linking the new image views and depth buffer.
    SituationError create_framebuffers_result = _SituationVulkanCreateFramebuffers();
    if (create_framebuffers_result != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(create_framebuffers_result, "_SituationVulkanRecreateSwapchain failed in _SituationVulkanCreateFramebuffers.");
        // State: Swapchain, image views, and depth exist, but no framebuffers.
        // Clean up all swapchain-derived resources created in this cycle.
        _SituationVulkanCleanupSwapchain();
        return;
    }

    // --- 4. Success ---
    // If all steps succeeded, the swapchain and its dependent resources are now successfully recreated and ready for use in the rendering loop.
    // The global state (sit_gs.vk.*) should now reflect the new configuration.
    // fprintf(stderr, "INFO: Vulkan swapchain successfully recreated.\n"); // Optional debug log
}

#endif // SITUATION_USE_VULKAN

/**
 * @brief Polls for all pending window and input events from the operating system.
 * @details This is one of the two core functions that form the new main loop, replacing the deprecated `SituationUpdate()`. Its sole responsibility is to process the OS event queue.
 *          This function must be called **once per frame**, typically at the very beginning of the main loop.
 *
 * @par Function Workflow
 *   1.  **Resets Per-Frame State:** It first resets all single-frame event flags (e.g., for `SituationIsKeyPressed`, `SituationIsMouseButtonReleased`) and clears the event queues (e.g., for `SituationGetKeyPressed`).
 *   2.  **Polls Events:** It then calls the underlying platform's event polling function (e.g., `glfwPollEvents`). This invokes all registered callbacks for keyboard, mouse, joystick, window focus, resize, and file drop events.
 *   3.  **Updates Current State:** These callbacks update the library's internal state, populating the "current frame" input buffers and event queues with fresh data from the OS.
 *
 * Calling this function ensures that all subsequent input queries within the same frame (like `SituationIsKeyDown` or `SituationGetMousePosition`) will return the most up-to-date information.
 *
 * @note This function should be called before `SituationUpdateTimers()` and before any of your application's own logic that depends on input.
 *
 * @see SituationUpdateTimers(), SituationUpdate()
 */
SITAPI void SituationPollInputEvents(void) {
    if (!sit_gs.is_initialized) return;

    // --- [FRAME START] RESET PER-FRAME EVENT FLAGS AND BUFFERS ---
    sit_gs.was_window_resized_last_frame = false;
    sit_gs.file_was_dropped_this_frame = false;

    // Reset keyboard event state.
    // Copy the now-old state to the "last" buffer for comparison.
    memcpy(sit_gs.keyboard.last_state, sit_gs.keyboard.current_state, sizeof(sit_gs.keyboard.last_state));
    // Clear the single-frame press/release event trackers.
    memset(sit_gs.keyboard.down_this_frame, 0, sizeof(sit_gs.keyboard.down_this_frame));
    memset(sit_gs.keyboard.up_this_frame, 0, sizeof(sit_gs.keyboard.up_this_frame));
    // Clear the event queues.
    sit_gs.keyboard.pressed_queue_count = 0;
    sit_gs.keyboard.char_queue_count = 0;

    // Reset mouse event state.
    glm_vec2_copy(sit_gs.mouse.current_pos, sit_gs.mouse.last_pos);
    memcpy(sit_gs.mouse.last_button_state, sit_gs.mouse.current_button_state, sizeof(sit_gs.mouse.last_button_state));
    memset(sit_gs.mouse.button_down_this_frame, 0, sizeof(sit_gs.mouse.button_down_this_frame));
    memset(sit_gs.mouse.button_up_this_frame, 0, sizeof(sit_gs.mouse.button_up_this_frame));
    sit_gs.mouse.wheel_move_x = 0.0f;
    sit_gs.mouse.wheel_move_y = 0.0f;
    sit_gs.mouse.button_queue_count = 0;
    
    // Clear the joystick button press queue as well.
    sit_gs.joysticks.button_pressed_queue_count = 0;

    // --- [POLL] GATHER NEW EVENTS FROM THE OPERATING SYSTEM ---
    // This call triggers all the GLFW callbacks (_SituationGLFWKeyCallback, etc.), which will populate our `current_state` and event queue buffers for this frame.
    glfwPollEvents();
}

/**
 * @brief Updates all internal timers and calculates the delta time for the current frame.
 * @details This is the second of the two core functions that form the new main loop. Its sole responsibility is to advance the library's internal clocks.
 *          This function should be called **once per frame**, immediately after `SituationPollInputEvents()` but before your main application logic.
 *
 * @par Function Workflow
 *   1.  **Calculates Delta Time:** It measures the time elapsed since the last frame and updates the value retrieved by `SituationGetFrameTime()`.
 *   2.  **Updates Temporal Oscillators:** It advances the state of the Temporal Oscillator system, triggering any oscillators whose periods have elapsed.
 *   3.  **Updates Joystick/Gamepad State:** It processes the joystick connection event queue and polls the state of connected gamepads to detect button press/release events for the current frame.
 *   4.  **Updates Virtual Display Clocks:** It advances the internal `elapsed_time_seconds` for each active virtual display.
 *
 * @note Calling this function is essential for `SituationGetFrameTime()` to return a correct, updated value for the current frame.
 *
 * @see SituationPollInputEvents(), SituationGetFrameTime(), SituationUpdate()
 */
SITAPI void SituationUpdateTimers(void) {
    if (!sit_gs.is_initialized) return;

    // --- 1. Global Frame Time Calculation ---
    sit_gs.current_time = glfwGetTime();
    sit_gs.frame_time = sit_gs.current_time - sit_gs.previous_time;
    sit_gs.previous_time = sit_gs.current_time;
    
    // --- 2. Process Joystick Connection Events (Thread-Safe) ---
    ma_mutex_lock(&sit_gs.joysticks.event_queue_mutex);
    for (int i = 0; i < sit_gs.joysticks.event_queue_count; i++) {
        _SituationJoystickEvent ev = sit_gs.joysticks.event_queue[i];

        if (ev.event == GLFW_CONNECTED) {
            sit_gs.joysticks.state[ev.jid].is_present = true;
            sit_gs.joysticks.state[ev.jid].is_gamepad = glfwJoystickIsGamepad(ev.jid);
            int axis_count = 0;
            glfwGetJoystickAxes(ev.jid, &axis_count);
            sit_gs.joysticks.state[ev.jid].axis_count = axis_count;
            const char* name = glfwGetJoystickName(ev.jid);
            if (name) {
                strncpy(sit_gs.joysticks.state[ev.jid].name, name, SITUATION_MAX_DEVICE_NAME_LEN - 1);
            } else {
                snprintf(sit_gs.joysticks.state[ev.jid].name, SITUATION_MAX_DEVICE_NAME_LEN, "Joystick %d", ev.jid);
            }
        } else if (ev.event == GLFW_DISCONNECTED) {
            memset(&sit_gs.joysticks.state[ev.jid], 0, sizeof(_SituationJoystickState));
        }

        if (sit_gs.joysticks.callback) {
            sit_gs.joysticks.callback(ev.jid, ev.event, sit_gs.joysticks.callback_user_data);
        }
    }
    sit_gs.joysticks.event_queue_count = 0;
    ma_mutex_unlock(&sit_gs.joysticks.event_queue_mutex);


    // --- 3. Poll Gamepad State & Detect Press Events ---
    for (int jid = 0; jid < SITUATION_MAX_JOYSTICKS; jid++) {
        if (sit_gs.joysticks.state[jid].is_present && sit_gs.joysticks.state[jid].is_gamepad) {
            // Copy current state to last state BEFORE polling new state.
            memcpy(sit_gs.joysticks.state[jid].last_button_state, sit_gs.joysticks.state[jid].current_button_state, sizeof(sit_gs.joysticks.state[jid].current_button_state));
            
            GLFWgamepadstate glfw_state;
            if (glfwGetGamepadState(jid, &glfw_state)) {
                // Update the current state buffers.
                memcpy(sit_gs.joysticks.state[jid].current_button_state, glfw_state.buttons, sizeof(glfw_state.buttons));
                memcpy(sit_gs.joysticks.state[jid].axis_state, glfw_state.axes, sizeof(glfw_state.axes));
                
                // Compare current vs. last to detect press events.
                for (int button = 0; button < SITUATION_MAX_JOYSTICK_BUTTONS; ++button) {
                    bool was_down = (sit_gs.joysticks.state[jid].last_button_state[button] == GLFW_PRESS);
                    bool is_down = (sit_gs.joysticks.state[jid].current_button_state[button] == GLFW_PRESS);

                    if (is_down && !was_down) {
                        if (sit_gs.joysticks.button_pressed_queue_count < SITUATION_KEY_QUEUE_MAX) {
                            sit_gs.joysticks.button_pressed_queue[sit_gs.joysticks.button_pressed_queue_count++] = button;
                        }
                    }
                }
            }
        }
    }

    // --- 4. Update Temporal Oscillator System ---
    if (sit_gs.timer_system_instance.is_initialized) {
        SituationTimerSystem* ts = &sit_gs.timer_system_instance;
        memcpy(ts->state_previous, ts->state_current, sizeof(ts->state_current));
        ts->current_system_time_seconds = sit_gs.current_time;
        for (int i = 0; i < SITUATION_MAX_OSCILLATORS; i++) {
            if (ts->current_system_time_seconds >= ts->next_trigger_time_seconds[i] && ts->period_seconds[i] > 0.0) {
                int bank = i / 64;
                int bit_pos = i % 64;
                uint64_t mask = (uint64_t)1 << bit_pos;
                while (ts->current_system_time_seconds >= ts->next_trigger_time_seconds[i]) {
                    ts->state_current[bank] ^= mask;
                    ts->trigger_count[i]++;
                    ts->next_trigger_time_seconds[i] += ts->period_seconds[i];
                }
            }
        }
    }

    // --- 5. Update Virtual Display Timers ---
    double current_time_for_vdisplays = sit_gs.timer_system_instance.is_initialized ? sit_gs.timer_system_instance.current_system_time_seconds : sit_gs.current_time;
    for (int i = 0; i < SITUATION_MAX_VIRTUAL_DISPLAYS; ++i) {
        if (sit_gs.virtual_display_slots_used[i]) {
            SituationVirtualDisplay* vd = &sit_gs.virtual_display_slots[i];
            vd->frame_delta_time_seconds = (current_time_for_vdisplays - vd->last_update_time_seconds);
            vd->elapsed_time_seconds += vd->frame_delta_time_seconds * vd->frame_time_multiplier;
            vd->frame_count++;
            vd->last_update_time_seconds = current_time_for_vdisplays;
            vd->cycle_animation_value = sinf(cosf(sinf((float)vd->elapsed_time_seconds) * sinf((float)vd->elapsed_time_seconds * 0.1f) * 0.1f) * cosf((float)vd->elapsed_time_seconds * 0.015f) * 0.1f) * 0.05f + 0.001f;
        }
    }
}

/**
 * @brief [DEPRECATED] Polls for input events and updates all internal timers.
 * @details This function is deprecated and will be removed in a future version.
 *          It combines event polling and timer updates, which is less explicit and can lead to off-by-one-frame bugs.
 *          Please update your main loop to use `SituationPollInputEvents()` and `SituationUpdateTimers()` separately for a clearer and more robust structure.
 *
 * @par New Workflow (Correct):
 *   The recommended main loop structure is now:
 *   ```c
 *   while (!SituationWindowShouldClose()) {
 *       // 1. GATHER INPUT: Poll all OS events.
 *       SituationPollInputEvents();
 *
 *       // 2. UPDATE STATE: Update all internal timers and calculate delta time.
 *       SituationUpdateTimers();
 *       float delta_time = SituationGetFrameTime();
 *
 *       // 3. YOUR LOGIC: Use fresh input and delta time to update your application.
 *       UpdatePlayer(delta_time);
 *
 *       // 4. RENDER: Draw the new state of your application.
 *       if (SituationAcquireFrameCommandBuffer()) {
 *           SituationCommandBuffer cmd = SituationGetMainCommandBuffer();
 *           // ... record your drawing commands ...
 *           SituationEndFrame();
 *       }
 *   }
 *   ```
 * @deprecated Use `SituationPollInputEvents()` followed by `SituationUpdateTimers()`.
 * @see SituationPollInputEvents(), SituationUpdateTimers()
 */
SITAPI void SituationUpdate(void) {
    SituationPollInputEvents();
    SituationUpdateTimers();
}

// --- Main Shutdown Orchestrator ---

/**
 * @brief Shuts down the entire Situation library and releases all resources.
 * @details This is the main exit point for the library and must be the last `SITAPI` function called. It orchestrates a graceful shutdown of all subsystems in the precise reverse order of their initialization, ensuring a clean exit with no resource leaks.
 *
 * @par Shutdown Sequence
 *   1.  **User Callback:** Invokes the optional exit callback set by `SituationSetExitCallback`.
 *   2.  **GPU Synchronization:** Ensures all pending GPU commands are completed (`vkDeviceWaitIdle` or `glFinish`) to prevent destroying resources that are still in use.
 *   3.  **Dangling Resource Cleanup:** Calls `_SituationCleanupDanglingResources` to automatically free any resources (meshes, shaders, textures, etc.) that the user forgot to destroy, printing warnings for each leak.
 *   4.  **Renderer Teardown:** Dispatches to the backend-specific cleanup function (`_SituationCleanupOpenGL` or `_SituationCleanupVulkan`) to destroy all graphics contexts, devices, and internal rendering resources.
 *   5.  **Subsystem Teardown:** Shuts down all other library modules, including the audio device, input systems, and timers.
 *   6.  **Platform Teardown:** Destroys the main window and terminates the underlying platform libraries (GLFW, COM).
 *
 * After this function completes, the library is in an uninitialized state and can be safely re-initialized with `SituationInit` if desired.
 *
 * @note It is safe to call this function even if `SituationInit` failed, as the internal cleanup helpers are robust to partially initialized states.
 * @warning This function is not thread-safe and must be called from the main thread.
 *
 * @see SituationInit(), _SituationCleanupDanglingResources()
 */
SITAPI void SituationShutdown(void) {
    if (!sit_gs.is_initialized) { _SituationSetErrorFromCode(SITUATION_ERROR_SHUTDOWN_FAILED, "Not initialized"); return; }
    if (sit_gs.exit_callback != NULL) { sit_gs.exit_callback(sit_gs.exit_callback_user_data); }
    
    // Wait for the GPU to finish any in-flight work before we start tearing things down. This is especially critical for Vulkan. 
#if defined(SITUATION_USE_VULKAN)
    if (sit_gs.vk.device != VK_NULL_HANDLE) vkDeviceWaitIdle(sit_gs.vk.device);
#elif defined(SITUATION_USE_OPENGL)
    if (sit_gs.sit_glfw_window) glFinish();
#endif

    // --- Call the auto-cleanup function ---
    _SituationCleanupDanglingResources();
    
    // 1. --- CLEANUP THE RENDERER ---
    _SituationCleanupRenderer();    // This is the main dispatch for backend-specific cleanup.

    // 2. --- CLEANUP LIBRARY SUBSYSTEMS ---
    _SituationCleanupSubsystems();     // (Audio, Input, Timers, etc.)

    // 3. --- CLEANUP CORE PLATFORM & WINDOW ---
    _SituationCleanupPlatform();

    // 4. --- FINAL STATE RESET ---
    sit_gs.is_initialized = false;
    _SituationSetError("Shutdown complete");
    // Optionally, memset sit_gs to 0 if re-initialization is a possibility.
    // memset(&sit_gs, 0, sizeof(_SituationGlobalStateContainer));
}


/**
 * @brief [INTERNAL] Shuts down all non-rendering library subsystems.
 * @details This helper function is responsible for the orderly teardown of the library's core modules, excluding the graphics backend. It is called by `SituationShutdown` as part of the main cleanup sequence.
 *
 * @par Cleanup Process
 *   - **Audio System:** Stops all currently playing sounds, uninitializes the active `miniaudio` device and context, and frees the temporary audio processing buffers.
 *   - **Synchronization:** Uninitializes all mutexes used for thread-safe event queuing (audio, keyboard, joystick).
 *   - **Input Systems:** Destroys all standard system cursors that were created by GLFW.
 *   - **Timer System:** Marks the temporal oscillator system as uninitialized.
 *
 * @note This function is designed to be robust and can be safely called even if some subsystems failed to initialize fully. It checks the state of each component before attempting to uninitialize it.
 * @warning This function is for internal use by `SituationShutdown` only.
 */
static void _SituationCleanupSubsystems(void) {
    // --- Audio System ---
    // Stop all sounds before uninitializing the device.
    SituationStopAllLoadedSounds();
    if (sit_gs.is_sit_miniaudio_device_active) {
        ma_device_uninit(&sit_gs.sit_miniaudio_device);
        sit_gs.is_sit_miniaudio_device_active = false;
    }
    // Uninitialize the context and free buffers last for the audio system.
    if (sit_gs.is_sit_miniaudio_context_initialized) {
        ma_context_uninit(&sit_gs.sit_miniaudio_context);
        sit_gs.is_sit_miniaudio_context_initialized = false;
    }
    free(sit_gs.sit_audio_callback_decoder_temp_buffer);
    free(sit_gs.sit_audio_callback_effects_temp_buffer);
    free(sit_gs.sit_audio_callback_converter_temp_buffer);
    sit_gs.sit_audio_callback_decoder_temp_buffer = NULL;
    sit_gs.sit_audio_callback_effects_temp_buffer = NULL;
    sit_gs.sit_audio_callback_converter_temp_buffer = NULL;

    // Uninitialize mutexes.
    ma_mutex_uninit(&sit_gs.sit_audio_queue_mutex);
    ma_mutex_uninit(&sit_gs.sit_keyboard_event_queue_mutex);
    ma_mutex_uninit(&sit_gs.joysticks.event_queue_mutex);

    // --- Input Systems ---
    // Destroy created cursors.
    for (int i = 0; i < sit_gs.cursor_count; i++) {
        if (sit_gs.cursors[i] != NULL) {
            glfwDestroyCursor(sit_gs.cursors[i]);
        }
    }

    // --- Timer System ---
    // Nothing to free, just mark as uninitialized.
    sit_gs.timer_system_instance.is_initialized = false;
}

/**
 * @brief [INTERNAL] Dispatches the cleanup process to the active graphics backend.
 * @details This helper function serves as a central dispatcher for renderer-specific teardown. It first ensures all user-created virtual displays are destroyed, then calls the appropriate cleanup function (`_SituationCleanupOpenGL` or `_SituationCleanupVulkan`) based on the backend selected at compile time.
 *
 * @note This function is called by `SituationShutdown` before `_SituationCleanupSubsystems` to ensure that graphics resources are released while the underlying context/device is still valid.
 * @warning This function is for internal use by `SituationShutdown` only.
 *
 * @see _SituationCleanupOpenGL(), _SituationCleanupVulkan()
 */
static void _SituationCleanupRenderer(void) {
    for (int i = 0; i < SITUATION_MAX_VIRTUAL_DISPLAYS; ++i) {
        if (sit_gs.virtual_display_slots_used[i]) {
            SituationDestroyVirtualDisplay(i);
        }
    }
#if defined(SITUATION_USE_VULKAN)
    _SituationCleanupVulkan();
#elif defined(SITUATION_USE_OPENGL)
    _SituationCleanupOpenGL();
#endif
}

/**
 * @brief [INTERNAL] Shuts down the core platform and windowing layer.
 * @details This is the final stage of the library's shutdown sequence. It is responsible for destroying the main application window, terminating the underlying windowing library (GLFW), and uninitializing any platform-specific APIs (like COM on Windows).
 *
 * @par Cleanup Process
 *   1.  Destroys the main `GLFWwindow` handle.
 *   2.  Terminates the GLFW library, releasing all of its global resources.
 *   3.  Frees the memory used for the cached physical display information.
 *   4.  On Windows, calls `CoUninitialize` to close the COM library if it was opened by the application.
 *
 * @note This function must be called after the renderer and all other subsystems have been shut down, as they depend on the window and its context.
 * @warning This function is for internal use by `SituationShutdown` only.
 */
static void _SituationCleanupPlatform(void) {
    // Destroy the main window.
    if (sit_gs.sit_glfw_window) {
        glfwDestroyWindow(sit_gs.sit_glfw_window);
        sit_gs.sit_glfw_window = NULL;
    }

    // Terminate GLFW.
    glfwTerminate();

    // Free display cache.
    if (sit_gs.cached_physical_displays_array) {
        for (int i = 0; i < sit_gs.cached_physical_display_count; ++i) {
            free(sit_gs.cached_physical_displays_array[i].available_modes);
        }
        free(sit_gs.cached_physical_displays_array);
        sit_gs.cached_physical_displays_array = NULL;
    }

    // Uninitialize COM on Windows.
    #if defined(_WIN32)
    if (sit_gs.is_com_initialized) {
        CoUninitialize();
        sit_gs.is_com_initialized = false;
    }
    #endif
}

/**
 * @brief [INTERNAL] Initializes all backend-specific resources for the internal 2D quad renderer.
 * @details This function is a critical part of the main initialization sequence. It creates the dedicated shaders, pipeline objects, and vertex buffers required by the high-level `SituationCmdDrawQuad` command.
 *          It is designed to be completely self-contained, ensuring that its internal state does not interfere with the user's rendering state.
 *
 * @par Backend-Specific Implementation
 * - **OpenGL:**
 *   1.  Compiles and links a dedicated shader program from the internal `SIT_QUAD_VERTEX_SHADER` and `SIT_QUAD_FRAGMENT_SHADER` sources.
 *   2.  Creates a **private** Vertex Array Object (`sit_gs.gl.quad_vao`) and Vertex Buffer Object (`sit_gs.gl.quad_vbo`). This is a crucial step to isolate the quad renderer's state from the main user-facing VAO (`sit_gs.gl.global_vao_id`).
 *   3.  Uploads a static, 4-vertex triangle strip to the VBO.
 *   4.  Configures the private VAO with the correct vertex attribute layout for the simple 2D vertex format.
 *   5.  Sets the initial orthographic projection matrix uniform in the shader.
 *   6.  Critically, it restores the binding of the main global VAO before returning, ensuring the user's rendering context is left undisturbed.
 * - **Vulkan:**
 *   1.  Compiles the internal GLSL shader sources into SPIR-V using `shaderc`.
 *   2.  Creates a `VkPipelineLayout` that defines the interface for the quad renderer, including a push constant range for the model matrix and color, and a descriptor set layout for the global projection UBO.
 *   3.  Calls the generic `_SituationVulkanCreateGraphicsPipeline` helper to build the final `VkPipeline` object with the correct vertex input state and primitive topology (`TRIANGLE_STRIP`).
 *   4.  Creates and uploads the static vertex data to a device-local `VkBuffer` for optimal performance.
 *
 * @param width The initial width of the main window's viewport, used to configure the orthographic projection matrix.
 * @param height The initial height of the main window's viewport.
 *
 * @return `true` on successful initialization of all required resources.
 * @return `false` if any step fails (e.g., shader compilation, object creation). On failure, an appropriate error message is set, and any partially created resources are cleaned up.
 *
 * @note This function is for internal use by `_SituationInitOpenGL` or `_SituationInitVulkan` only.
 * @warning The success of this function is mandatory for `SituationCmdDrawQuad` and other 2D drawing helpers to work.
 *
 * @see _SituationCleanupQuadRenderer(), SituationCmdDrawQuad()
 */
static bool _SituationInitQuadRenderer(int width, int height) {
#if defined(SITUATION_USE_OPENGL)
    // --- OpenGL Quad Renderer Initialization ---
    SituationError shader_err_code = SITUATION_SUCCESS;
    const char* error_context = "_SituationInitQuadRenderer";

    // 1. Compile and link the internal quad shader program.
    sit_gs.gl.quad_shader_program = _SituationCreateGLShaderProgram(SIT_QUAD_VERTEX_SHADER, SIT_QUAD_FRAGMENT_SHADER, &shader_err_code);
    if (shader_err_code != SITUATION_SUCCESS || sit_gs.gl.quad_shader_program == 0) {
        // Error message should already be set by _SituationCreateGLShaderProgram
        // Add context if needed
        // char full_msg[256];
        // snprintf(full_msg, sizeof(full_msg), "%s: Failed to create quad shader program.", error_context);
        // _SituationAppendToLastError(full_msg); // Hypothetical helper
        return false;
    }

    // 2. Define vertex data for a simple 2D quad (TRIANGLE_STRIP order).
    // Format: [X, Y] (assuming Z=0, W=1 in shader or handled by model matrix)
    float quad_vertices[] = {
        0.0f, 0.0f, // Bottom-left
        1.0f, 0.0f, // Bottom-right
        0.0f, 1.0f, // Top-left
        1.0f, 1.0f  // Top-right
    };

    // --- [PRIVATE VAO/VBO SETUP for Quad Renderer] ---

    // 3. Create the PRIVATE VAO and VBO for the quad renderer.
    glCreateVertexArrays(1, &sit_gs.gl.quad_vao);
    if (sit_gs.gl.quad_vao == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_GENERAL, "_SituationInitQuadRenderer: Failed to create private quad VAO.");
        // Cleanup shader program on VAO creation failure
        glDeleteProgram(sit_gs.gl.quad_shader_program);
        sit_gs.gl.quad_shader_program = 0;
        return false;
    }
    SIT_CHECK_GL_ERROR(); // Check for errors during VAO creation

    glCreateBuffers(1, &sit_gs.gl.quad_vbo);
    if (sit_gs.gl.quad_vbo == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_GENERAL, "_SituationInitQuadRenderer: Failed to create private quad VBO.");
        // Cleanup shader program and VAO on VBO creation failure
        glDeleteProgram(sit_gs.gl.quad_shader_program);
        sit_gs.gl.quad_shader_program = 0;
        glDeleteVertexArrays(1, &sit_gs.gl.quad_vao);
        sit_gs.gl.quad_vao = 0;
        return false;
    }
    SIT_CHECK_GL_ERROR(); // Check for errors during VBO creation

    // 4. Allocate and populate the VBO's storage with the quad vertex data.
    // Using glNamedBufferStorage for DSA (Direct State Access).
    glNamedBufferStorage(sit_gs.gl.quad_vbo, sizeof(quad_vertices), quad_vertices, 0); // Static data
    if (/* Hypothetical check for buffer storage failure, though glNamedBufferStorage rarely fails without OOM */) {
         _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_GENERAL, "_SituationInitQuadRenderer: Failed to allocate/populate quad VBO storage.");
        // Cleanup shader program, VAO, and VBO
        glDeleteProgram(sit_gs.gl.quad_shader_program);
        sit_gs.gl.quad_shader_program = 0;
        glDeleteVertexArrays(1, &sit_gs.gl.quad_vao);
        sit_gs.gl.quad_vao = 0;
        glDeleteBuffers(1, &sit_gs.gl.quad_vbo);
        sit_gs.gl.quad_vbo = 0;
        return false;
    }
    SIT_CHECK_GL_ERROR(); // Check for errors during buffer storage

    // 5. Temporarily bind OUR private VAO to configure it.
    glBindVertexArray(sit_gs.gl.quad_vao);
    SIT_CHECK_GL_ERROR(); // Check for errors during VAO binding

    // 6. Configure the VAO state: Bind VBO, set vertex attributes.
    // Bind the VBO to the VAO's binding index 0.
    glVertexArrayVertexBuffer(sit_gs.gl.quad_vao, 0, sit_gs.gl.quad_vbo, 0, 2 * sizeof(float)); // Binding index 0, stride 2 floats
    SIT_CHECK_GL_ERROR();

    // Set up vertex attribute format for position (assuming layout(location = SIT_ATTR_POSITION) in vec2 in shader)
    glVertexArrayAttribFormat(sit_gs.gl.quad_vao, SIT_ATTR_POSITION, 2, GL_FLOAT, GL_FALSE, 0); // Attrib SIT_ATTR_POSITION, 2 components, float, normalized, relative offset 0
    SIT_CHECK_GL_ERROR();
    glVertexArrayAttribBinding(sit_gs.gl.quad_vao, SIT_ATTR_POSITION, 0); // Attrib SIT_ATTR_POSITION uses binding index 0
    SIT_CHECK_GL_ERROR();
    glEnableVertexArrayAttrib(sit_gs.gl.quad_vao, SIT_ATTR_POSITION); // Enable attrib SIT_ATTR_POSITION
    SIT_CHECK_GL_ERROR();

    // 7. *** CRITICAL *** Unbind our private VAO.
    // This restores the previously bound VAO (which should be sit_gs.gl.global_vao_id after _SituationInitOpenGL sets it up) as the active one for subsequent user operations.
    glBindVertexArray(0); // Explicit unbind for safety and clarity
    SIT_CHECK_GL_ERROR();

    // --- End of Private VAO/VBO Setup ---

    // 8. Set the initial projection matrix uniform in the shader program.
    // This matrix maps from screen pixel coordinates (0,0 top-left) to clip space.
    mat4 proj_quad;
    glm_ortho(0.0f, (float)width, (float)height, 0.0f, -1.0f, 1.0f, proj_quad); // Top-left is (0,0)
    glProgramUniformMatrix4fv(sit_gs.gl.quad_shader_program, SIT_UNIFORM_LOC_PROJECTION_MATRIX, 1, GL_FALSE, (const GLfloat*)proj_quad);
    SIT_CHECK_GL_ERROR(); // Check for errors setting the uniform

    // 9. CRITICAL: Ensure the global_vao_id is bound again before returning.
    // This reinforces that the user's rendering state is ready and that our private VAO setup did not leave the context in an unexpected state.
    glBindVertexArray(sit_gs.gl.global_vao_id);
    SIT_CHECK_GL_ERROR();

    return true; // Indicate success

#elif defined(SITUATION_USE_VULKAN)
    // --- Vulkan Quad Renderer Initialization ---

    // 1. Compile the unified GLSL source into SPIR-V.
    //    The compiler is mandatory for Vulkan.
    _SituationSpirvBlob vs_spirv = _SituationVulkanCompileGLSLtoSPIRV(SIT_QUAD_VERTEX_SHADER, "internal_quad.vert", shaderc_vertex_shader);
    _SituationSpirvBlob fs_spirv = _SituationVulkanCompileGLSLtoSPIRV(SIT_QUAD_FRAGMENT_SHADER, "internal_quad.frag", shaderc_fragment_shader);
    
    if (!vs_spirv.data || !fs_spirv.data) {
        _SituationFreeSpirvBlob(&vs_spirv);
        _SituationFreeSpirvBlob(&fs_spirv);
        return false; // Error already set by compiler
    }

    // 2. Create the Pipeline Layout.
    // This defines the "shape" of the uniforms (Descriptor Sets and Push Constants).
    VkPushConstantRange push_constant_range = {};
    push_constant_range.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
    push_constant_range.offset = 0;
    push_constant_range.size = sizeof(mat4) + sizeof(vec4); // Model Matrix + ColorRGBA

    VkPipelineLayoutCreateInfo pipeline_layout_info = {};
    pipeline_layout_info.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipeline_layout_info.setLayoutCount = 1;
    pipeline_layout_info.pSetLayouts = &sit_gs.vk.view_data_ubo_layout; // Uses the global UBO layout for projection
    pipeline_layout_info.pushConstantRangeCount = 1;
    pipeline_layout_info.pPushConstantRanges = &push_constant_range;

    if (vkCreatePipelineLayout(sit_gs.vk.device, &pipeline_layout_info, NULL, &sit_gs.vk.quad_pipeline_layout) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_PIPELINE_FAILED, "Failed to create quad pipeline layout.");
        _SituationFreeSpirvBlob(&vs_spirv);
        _SituationFreeSpirvBlob(&fs_spirv);
        return false;
    }

    // 3. Define the quad's specific vertex input layout.
    VkVertexInputBindingDescription binding_desc = { .binding = 0, .stride = 2 * sizeof(float), .inputRate = VK_VERTEX_INPUT_RATE_VERTEX };
    VkVertexInputAttributeDescription attr_desc = { .binding = 0, .location = SIT_ATTR_POSITION, .format = VK_FORMAT_R32G32_SFLOAT, .offset = 0 };

    // 4. Call the generic pipeline creator with the quad's specific configuration.
    sit_gs.vk.quad_pipeline = _SituationVulkanCreateGraphicsPipeline(
        vs_spirv.data, vs_spirv.size,
        fs_spirv.data, fs_spirv.size,
        sit_gs.vk.quad_pipeline_layout,
        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP, // Quads are drawn as a strip
        1, &binding_desc,
        1, &attr_desc
    );
    
    _SituationFreeSpirvBlob(&vs_spirv);
    _SituationFreeSpirvBlob(&fs_spirv);
    
    if(sit_gs.vk.quad_pipeline == VK_NULL_HANDLE) return false;
    
    // 5. Create and upload the vertex buffer for the quad.
    float quad_vertices[] = { 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f }; // Triangle Strip
    if (_SituationVulkanCreateAndUploadBuffer(quad_vertices, sizeof(quad_vertices), VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, &sit_gs.vk.quad_vertex_buffer, &sit_gs.vk.quad_vertex_buffer_memory) != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED, "Failed to create quad vertex buffer.");
        return false;
    }
    
    return true;
#endif
    return false; // Should not be reached
}

/**
 * @brief [INTERNAL] Destroys all backend-specific resources used by the internal quad renderer.
 * @details This helper function is called during the main shutdown sequence to clean up the dedicated resources created by `_SituationInitQuadRenderer`. It ensures that the internal shaders, pipelines, and vertex buffers used for drawing simple quads are properly released.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Deletes the quad renderer's shader program, its private Vertex Array Object (VAO), and its Vertex Buffer Object (VBO).
 * - **Vulkan:** Destroys the `VkPipeline`, `VkPipelineLayout`, and the vertex `VkBuffer` (along with its `VmaAllocation`) associated with the quad renderer. It assumes the device is idle before being called.
 *
 * @note This function is designed to be robust and will safely handle being called on a partially initialized state by checking if resource handles are valid before attempting destruction.
 * @warning This function is for internal use by the main cleanup routines (`_SituationCleanupOpenGL` or `_SituationCleanupVulkan`) only.
 *
 * @see _SituationInitQuadRenderer()
 */
static void _SituationCleanupQuadRenderer(void) {
#if defined(SITUATION_USE_OPENGL)
    if (sit_gs.quad_shader_program) { glDeleteProgram(sit_gs.quad_shader_program); sit_gs.quad_shader_program = 0; }
    if (sit_gs.quad_vao) { glDeleteVertexArrays(1, &sit_gs.quad_vao); sit_gs.quad_vao = 0; }
    if (sit_gs.quad_vbo) { glDeleteBuffers(1, &sit_gs.quad_vbo); sit_gs.quad_vbo = 0; }

#elif defined(SITUATION_USE_VULKAN)
    if (sit_gs.vk.device) {
        if (sit_gs.vk.quad_pipeline) vkDestroyPipeline(sit_gs.vk.device, sit_gs.vk.quad_pipeline, NULL);
        if (sit_gs.vk.quad_pipeline_layout) vkDestroyPipelineLayout(sit_gs.vk.device, sit_gs.vk.quad_pipeline_layout, NULL);
        if (sit_gs.vk.quad_vertex_buffer) vmaDestroyBuffer(sit_gs.vk.vma_allocator, sit_gs.vk.quad_vertex_buffer, sit_gs.vk.quad_vertex_buffer_memory);
    }
#endif
}

/**
 * @brief [INTERNAL] Destroys all OpenGL-specific resources created by the library.
 * @details This function is the backend-specific cleanup handler for OpenGL. It is responsible for deleting all globally managed OpenGL objects, such as internal shader programs, VAOs, VBOs, and UBOs.
 *          It assumes the OpenGL context is still active when it is called.
 *
 * @par Cleanup Process
 *   - Destroys the internal quad renderer's shader, VAO, and VBO.
 *   - Destroys the shader programs used for virtual display compositing.
 *   - Destroys the global VAO used for all user rendering.
 *   - Destroys the private VAO/VBO used for drawing virtual display quads.
 *   - Destroys any other global resources like the view data UBO.
 *
 * @note This function is designed to be robust and will not cause errors if called on a partially initialized state (i.e., it checks if object IDs are non-zero before attempting deletion).
 * @warning This function is for internal use by `_SituationCleanupRenderer` only.
 */
#if defined(SITUATION_USE_OPENGL)
static void _SituationCleanupOpenGL(void) {
    // The OpenGL context is still active here.
    // Clean up all library-managed GL objects.
    _SituationCleanupQuadRenderer();
    if (sit_gs.vd_shader_program_id != 0) glDeleteProgram(sit_gs.vd_shader_program_id);
    if (sit_gs.composite_shader_program_id != 0) glDeleteProgram(sit_gs.composite_shader_program_id);
    if (sit_gs.global_vao_id != 0) { glDeleteVertexArrays(1, &sit_gs.global_vao_id); sit_gs.global_vao_id = 0; }
    if (sit_gs.vd_quad_vao != 0) glDeleteVertexArrays(1, &sit_gs.vd_quad_vao);
    if (sit_gs.vd_quad_vbo != 0) glDeleteBuffers(1, &sit_gs.vd_quad_vbo);
    if (sit_gs.composite_copy_texture_id != 0) glDeleteTextures(1, &sit_gs.composite_copy_texture_id);
    if (sit_gs.view_data_ubo_id != 0) glDeleteBuffers(1, &sit_gs.view_data_ubo_id);
}
#endif // SITUATION_USE_OPENGL

/**
 * @brief [INTERNAL] Destroys all Vulkan-specific resources created by the library.
 * @details This is the comprehensive backend-specific cleanup handler for Vulkan. It is responsible for destroying all Vulkan objects in the precise reverse order of their creation to ensure compliance with the API's strict object lifetime rules.
 *
 * @par Cleanup Process
 *   The function systematically destroys all resources, from high-level objects down to the `VkInstance` itself. This includes:
 *   - Internal renderers (quad renderer).
 *   - The swapchain and all its dependent resources (`_SituationVulkanCleanupSwapchain`).
 *   - All per-frame synchronization objects (semaphores, fences) and UBOs.
 *   - The main command pool, render pass, and VMA allocator.
 *   - All descriptor set layouts and descriptor pools.
 *   - The `VkDevice` (logical device).
 *   - The debug messenger, `VkSurfaceKHR`, and finally the `VkInstance`.
 *
 * @note This function is designed to be robust. It checks if each handle is non-NULL before attempting to destroy it, making it safe to call even if the initialization process failed partway through.
 * @warning This function is for internal use by `_SituationCleanupRenderer` only.
 */
#if defined(SITUATION_USE_VULKAN)
static void _SituationCleanupVulkan(void) {
    _SituationCleanupQuadRenderer();
    _SituationVulkanCleanupSwapchain();
    for (uint32_t i = 0; i < sit_gs.vk.max_frames_in_flight; i++) {
        vkDestroySemaphore(sit_gs.vk.device, sit_gs.vk.render_finished_semaphores[i], NULL);
        vkDestroySemaphore(sit_gs.vk.device, sit_gs.vk.image_available_semaphores[i], NULL);
        vkDestroyFence(sit_gs.vk.device, sit_gs.vk.in_flight_fences[i], NULL);
        vmaDestroyBuffer(sit_gs.vk.vma_allocator, sit_gs.vk.view_proj_ubo_buffer[i], sit_gs.vk.view_proj_ubo_memory[i]);
    }
    // --- [NEW] Free the arrays themselves ---
    free(sit_gs.vk.command_buffers);
    free(sit_gs.vk.image_available_semaphores);
    free(sit_gs.vk.render_finished_semaphores);
    free(sit_gs.vk.in_flight_fences);
    free(sit_gs.vk.view_proj_ubo_buffer);
    free(sit_gs.vk.view_proj_ubo_memory);
    free(sit_gs.vk.view_proj_ubo_descriptor_set);

    for (int i = 0; i < sizeof(sit_gs.vk.compute_layouts) / sizeof(sit_gs.vk.compute_layouts[0]); ++i) {
        if (sit_gs.vk.compute_layouts[i] != VK_NULL_HANDLE) {
            vkDestroyPipelineLayout(sit_gs.vk.device, sit_gs.vk.compute_layouts[i], NULL);
        }
    }

    vkDestroyCommandPool(sit_gs.vk.device, sit_gs.vk.command_pool, NULL);
    vkDestroyRenderPass(sit_gs.vk.device, sit_gs.vk.main_window_render_pass, NULL);
    vmaDestroyAllocator(sit_gs.vk.vma_allocator);
    vkDestroyDescriptorSetLayout(sit_gs.vk.device, sit_gs.vk.ssbo_layout, NULL);
    vkDestroyDescriptorSetLayout(sit_gs.vk.device, sit_gs.vk.ubo_layout, NULL);
    vkDestroyDescriptorSetLayout(sit_gs.vk.device, sit_gs.vk.storage_buffer_layout, NULL);
    vkDestroyDescriptorSetLayout(sit_gs.vk.device, sit_gs.vk.image_sampler_layout, NULL);
    vkDestroyDescriptorSetLayout(sit_gs.vk.device, sit_gs.vk.view_data_ubo_layout, NULL);
    vkDestroyDescriptorPool(sit_gs.vk.device, sit_gs.vk.descriptor_pool, NULL);
    vkDestroyDescriptorPool(sit_gs.vk.device, sit_gs.vk.persistent_descriptor_pool, NULL);
    vkDestroyDevice(sit_gs.vk.device, NULL);
    if (sit_gs.vk.debug_messenger != VK_NULL_HANDLE) {
        PFN_vkDestroyDebugUtilsMessengerEXT func = (PFN_vkDestroyDebugUtilsMessengerEXT)vkGetInstanceProcAddr(sit_gs.vk.instance, "vkDestroyDebugUtilsMessengerEXT");
        if (func != NULL) {
            func(sit_gs.vk.instance, sit_gs.vk.debug_messenger, NULL);
        }
    }
    vkDestroySurfaceKHR(sit_gs.vk.instance, sit_gs.vk.surface, NULL);
    vkDestroyInstance(sit_gs.vk.instance, NULL);
}

/**
 * @brief [INTERNAL] Initializes all Vulkan resources for the internal 2D quad renderer.
 * @details This function is a critical part of the Vulkan initialization sequence. It creates the dedicated shaders, pipeline layout, graphics pipeline, and vertex buffer required by the high-level `SituationCmdDrawQuad` command.
 *          This renderer is a self-contained module designed for efficient, untextured, 2D quad rendering, which is essential for UI elements, debug overlays, and other simple geometry.
 *
 * @par Initialization Process
 *   1.  **Shader Compilation:** It compiles the internal, backend-agnostic GLSL sources (`SIT_QUAD_VERTEX_SHADER`, `SIT_QUAD_FRAGMENT_SHADER`) into SPIR-V bytecode using `shaderc`.
 *   2.  **Pipeline Layout:** It creates a `VkPipelineLayout` specifically for this renderer. This layout defines a descriptor set for the global projection UBO (at set 0) and a push constant range for passing the per-quad model matrix and color.
 *   3.  **Graphics Pipeline:** It calls the generic `_SituationVulkanCreateGraphicsPipeline` helper to build the final `VkPipeline` object. It configures the pipeline with the correct vertex input state for a 2-component vertex (`vec2`) and sets the primitive topology to `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP`.
 *   4.  **Vertex Buffer:** It creates a static, device-local `VkBuffer` and uploads the vertex data for a unit quad (4 vertices). This buffer is created once and reused for every quad drawn.
 *
 * All created resources are stored in the global state (`sit_gs.vk`) for use by `SituationCmdDrawQuad` and for cleanup during shutdown.
 *
 * @return `SITUATION_SUCCESS` on successful initialization of all required resources.
 * @return An appropriate `SituationError` code if any step fails (e.g., shader compilation, object creation). On failure, any partially created resources are cleaned up.
 *
 * @note This function is for internal use by `_SituationVulkanInitInternalRenderers` only.
 * @warning The success of this function is mandatory for `SituationCmdDrawQuad` to work.
 *
 * @see _SituationCleanupQuadRenderer(), SituationCmdDrawQuad(), _SituationVulkanCreateGraphicsPipeline()
 */
static SituationError _SituationVulkanInitQuadRenderer(void) {
    // --- 1. Create the Vertex Buffer for a Unit Quad ---
    // A simple quad with vertices at (0,0) and (1,1). We'll use a triangle strip.
    float quad_vertices[] = {
        0.0f, 0.0f, // Top-left
        1.0f, 0.0f, // Top-right
        0.0f, 1.0f, // Bottom-left
        1.0f, 1.0f  // Bottom-right
    };
    if (_SituationVulkanCreateAndUploadBuffer(quad_vertices, sizeof(quad_vertices), VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
        &sit_gs.vk.quad_vertex_buffer, &sit_gs.vk.quad_vertex_buffer_memory) != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED, "Failed to create quad vertex buffer.");
        return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED;
    }

    // --- 2. Create the Pipeline Layout with Push Constants ---
    // Push constants are a small, fast way to send data to shaders.
    VkPushConstantRange push_constant_range = {};
    push_constant_range.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT; // Accessible by both shaders
    push_constant_range.offset = 0;
    push_constant_range.size = sizeof(mat4) + sizeof(vec4); // Size of our model matrix + color

    VkPipelineLayoutCreateInfo pipeline_layout_info = {};
    pipeline_layout_info.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipeline_layout_info.setLayoutCount = 0; // No descriptor sets for this simple pipeline
    pipeline_layout_info.pushConstantRangeCount = 1;
    pipeline_layout_info.pPushConstantRanges = &push_constant_range;

    if (vkCreatePipelineLayout(sit_gs.vk.device, &pipeline_layout_info, NULL, &sit_gs.vk.quad_pipeline_layout) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_PIPELINE_FAILED, "Failed to create quad pipeline layout.");
        return SITUATION_ERROR_VULKAN_PIPELINE_FAILED;
    }

    // --- 3. Create the Graphics Pipeline ---
    // You would load your quad's SPIR-V shaders here. Let's assume you have them.
    // char* vs_code = SituationLoadFile... ; char* fs_code = ...;
    // For this example, we'll assume they are loaded.
    // shader = _SituationVulkanCreateGraphicsPipeline(vs_code, ..., fs_code, ...);
    //
    // The _SituationVulkanCreateGraphicsPipeline function needs to be slightly modified to accept a pipeline layout and vertex input info, instead of always using a global one.
    // For now, let's build the pipeline directly here for clarity.

    // This is a simplified pipeline creation for the quad.
    // A real implementation would generalize _SituationVulkanCreateGraphicsPipeline.

    // Load shaders (user must provide `quad.vert.spv` and `quad.frag.spv`)
    unsigned int vs_size = 0;
    unsigned char* vs_data = SituationLoadFileData("quad.vert.spv", &vs_size);
    unsigned int fs_size = 0;
    unsigned char* fs_data = SituationLoadFileData("quad.frag.spv", &fs_size);
    if (!vs_data || !fs_data) {
        _SituationSetErrorFromCode(SITUATION_ERROR_FILE_ACCESS, "Failed to load quad shader SPIR-V files.");
        return SITUATION_ERROR_FILE_ACCESS;
    }
    VkShaderModule vs_module = _SituationVulkanCreateShaderModule(vs_data, vs_size);
    VkShaderModule fs_module = _SituationVulkanCreateShaderModule(fs_data, fs_size);
    free(vs_data); free(fs_data);

    VkPipelineShaderStageCreateInfo vs_stage_info = { .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, .stage = VK_SHADER_STAGE_VERTEX_BIT, .module = vs_module, .pName = "main" };
    VkPipelineShaderStageCreateInfo fs_stage_info = { .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, .stage = VK_SHADER_STAGE_FRAGMENT_BIT, .module = fs_module, .pName = "main" };
    VkPipelineShaderStageCreateInfo shader_stages[] = {vs_stage_info, fs_stage_info};

    // Vertex input for the quad (just one Vector2 attribute)
    VkVertexInputBindingDescription binding_desc = { .binding = 0, .stride = 2 * sizeof(float), .inputRate = VK_VERTEX_INPUT_RATE_VERTEX };
    VkVertexInputAttributeDescription attr_desc = { .binding = 0, .location = 0, .format = VK_FORMAT_R32G32_SFLOAT, .offset = 0 };
    VkPipelineVertexInputStateCreateInfo vertex_input_info = { .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO, .vertexBindingDescriptionCount = 1, .pVertexBindingDescriptions = &binding_desc, .vertexAttributeDescriptionCount = 1, .pVertexAttributeDescriptions = &attr_desc };

    // Use the same fixed-function states as the main pipeline creator
    VkPipelineInputAssemblyStateCreateInfo input_assembly = { .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO, .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP, .primitiveRestartEnable = VK_FALSE };
    // ... (copy viewport_state, rasterizer, multisampling, depth_stencil, color_blending, dynamic_state from the other pipeline function) ...

    VkGraphicsPipelineCreateInfo pipeline_info = {};
    // ... (populate pipeline_info just like in _SituationVulkanCreateGraphicsPipeline) ...
    pipeline_info.layout = sit_gs.vk.quad_pipeline_layout; // Use our new layout

    if (vkCreateGraphicsPipelines(sit_gs.vk.device, VK_NULL_HANDLE, 1, &pipeline_info, NULL, &sit_gs.vk.quad_pipeline) != VK_SUCCESS) {
        // ... cleanup and error ...
    }

    vkDestroyShaderModule(sit_gs.vk.device, vs_module, NULL);
    vkDestroyShaderModule(sit_gs.vk.device, fs_module, NULL);

    return SITUATION_SUCCESS;
}

/**
 * @brief [INTERNAL] Creates all pre-defined VkPipelineLayouts for compute shaders.
 * @details This function is called once during Vulkan initialization. It builds a set of common pipeline layouts that users can select via the SituationComputeLayoutType enum, abstracting away the complexity of Vulkan layout creation.
 * @return SITUATION_SUCCESS on success, or an error code if any layout fails to create.
 */
 static SituationError _SituationVulkanInitComputeLayouts(void) {
    VkPipelineLayoutCreateInfo layout_info = { .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO };
    VkDescriptorSetLayout set_layouts[4]; // Max needed for our most complex layout
    VkPushConstantRange push_constant = { .stageFlags = VK_SHADER_STAGE_COMPUTE_BIT, .offset = 0, .size = 64 };

    // Layout 1: SIT_COMPUTE_LAYOUT_ONE_SSBO
    set_layouts[0] = sit_gs.vk.ssbo_layout;
    layout_info.setLayoutCount = 1;
    layout_info.pSetLayouts = set_layouts;
    layout_info.pushConstantRangeCount = 0;
    if (vkCreatePipelineLayout(sit_gs.vk.device, &layout_info, NULL, &sit_gs.vk.compute_layouts[SIT_COMPUTE_LAYOUT_ONE_SSBO]) != VK_SUCCESS) return SITUATION_ERROR_VULKAN_PIPELINE_FAILED;

    // Layout 2: SIT_COMPUTE_LAYOUT_TWO_SSBOS
    set_layouts[0] = sit_gs.vk.ssbo_layout;
    set_layouts[1] = sit_gs.vk.ssbo_layout; // Same layout used for two different sets
    layout_info.setLayoutCount = 2;
    if (vkCreatePipelineLayout(sit_gs.vk.device, &layout_info, NULL, &sit_gs.vk.compute_layouts[SIT_COMPUTE_LAYOUT_TWO_SSBOS]) != VK_SUCCESS) return SITUATION_ERROR_VULKAN_PIPELINE_FAILED;

    // Layout 3: SIT_COMPUTE_LAYOUT_IMAGE_AND_SSBO
    set_layouts[0] = sit_gs.vk.storage_image_layout;
    set_layouts[1] = sit_gs.vk.ssbo_layout;
    layout_info.setLayoutCount = 2;
    if (vkCreatePipelineLayout(sit_gs.vk.device, &layout_info, NULL, &sit_gs.vk.compute_layouts[SIT_COMPUTE_LAYOUT_IMAGE_AND_SSBO]) != VK_SUCCESS) return SITUATION_ERROR_VULKAN_PIPELINE_FAILED;

    // Layout 4: SIT_COMPUTE_LAYOUT_PUSH_CONSTANT
    layout_info.setLayoutCount = 0;
    layout_info.pushConstantRangeCount = 1;
    layout_info.pPushConstantRanges = &push_constant;
    if (vkCreatePipelineLayout(sit_gs.vk.device, &layout_info, NULL, &sit_gs.vk.compute_layouts[SIT_COMPUTE_LAYOUT_PUSH_CONSTANT]) != VK_SUCCESS) return SITUATION_ERROR_VULKAN_PIPELINE_FAILED;

    // Layout 5: SIT_COMPUTE_LAYOUT_EMPTY
    layout_info.setLayoutCount = 0;
    layout_info.pushConstantRangeCount = 0;
    if (vkCreatePipelineLayout(sit_gs.vk.device, &layout_info, NULL, &sit_gs.vk.compute_layouts[SIT_COMPUTE_LAYOUT_EMPTY]) != VK_SUCCESS) return SITUATION_ERROR_VULKAN_PIPELINE_FAILED;

    return SITUATION_SUCCESS;
}
 
/**
 * @brief [Internal] Creates a Vulkan compute pipeline from SPIR-V bytecode.
 *
 * @details This function takes pre-compiled SPIR-V bytecode for a compute shader, creates the necessary Vulkan objects (VkShaderModule, VkPipelineLayout, VkPipeline), and returns a `SituationComputePipeline` struct containing them.
 *          The caller is responsible for assigning a public `id` to the returned struct and for adding it to any resource tracking systems.
 *          The caller is also responsible for eventually destroying the pipeline using `_SituationVulkanDestroyComputePipeline` or `SituationDestroyComputePipeline`.
 *          Error handling is performed internally. If this function fails, it returns an invalid `SituationComputePipeline` (zero-initialized) and sets the library's last error state via `_SituationSetErrorFromCode`.
 *
 * @param cs_spirv_data Pointer to the compiled SPIR-V compute shader bytecode.
 *                      This data must be valid and correctly formatted SPIR-V.
 *                      Must not be NULL.
 * @param cs_spirv_size Size of the SPIR-V bytecode in bytes.
 *                      Must be greater than 0 and typically a multiple of 4.
 *                      Must not be 0.
 * @return A `SituationComputePipeline` struct.
 *         - On **success**: The struct contains valid Vulkan handles (`.vk_pipeline`, `.vk_pipeline_layout`) and should be used with Vulkan binding/execution functions. The caller must assign a public `.id`.
 *         - On **failure**: The struct is zero-initialized (`{0}`), indicating an invalid pipeline. The specific error can be retrieved using `SituationGetLastErrorMsg()`.
 *
 * @note This function requires the library to be initialized (`SituationInit` must have been called successfully).
 * @note This function creates a pipeline layout with **no descriptor set layouts** and **no push constant ranges**.
 *       If the compute shader requires descriptors or push constants, this function (or the logic calling it) must be modified to provide the appropriate `VkDescriptorSetLayout` objects and `VkPushConstantRange` definitions when creating the `VkPipelineLayout`.
 * @note The `VkShaderModule` created internally is destroyed immediately after the `VkPipeline` is successfully created, as per Vulkan specification.
 *       The `VkShaderModule` handle is **not** stored in the returned struct.
 * @warning The SPIR-V data pointed to by `cs_spirv_data` is not validated by this function for semantic correctness beyond basic Vulkan object creation. Passing invalid SPIR-V can lead to errors during pipeline creation or undefined behavior at runtime.
 * @see _SituationVulkanCreateShaderModule(), _SituationVulkanDestroyComputePipeline(), SituationCreateComputePipelineFromMemory(), SituationDestroyComputePipeline()
 */
static SituationComputePipeline _SituationVulkanCreateComputePipeline(const uint8_t* cs_spirv_data, size_t cs_spirv_size) {
    SituationComputePipeline pipeline = {0}; // Initialize to invalid state

    // --- 1. Pre-condition Checks ---
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "_SituationVulkanCreateComputePipeline: Library not initialized.");
        return pipeline; // Return invalid pipeline
    }

    if (!cs_spirv_data || cs_spirv_size == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "_SituationVulkanCreateComputePipeline: Invalid SPIR-V data (NULL pointer) or size (zero).");
        return pipeline; // Return invalid pipeline
    }

    // --- 2. Create VkShaderModule ---
    // This helper function handles VkShaderModuleCreateInfo setup and vkCreateShaderModule call.
    // It also performs input validation and sets errors.
    VkShaderModule cs_module = _SituationVulkanCreateShaderModule((const char*)cs_spirv_data, cs_spirv_size);
    if (cs_module == VK_NULL_HANDLE) {
        // Error message should already be set by _SituationVulkanCreateShaderModule.
        // Return the invalid pipeline struct.
        return pipeline;
    }
    // cs_module is now a valid VkShaderModule handle that needs to be destroyed later.

    // --- 3. Create VkPipelineLayout ---
    // Initializes to zero/default values.
    VkPipelineLayoutCreateInfo pipeline_layout_info = {0};
    pipeline_layout_info.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    // pNext = NULL by default
    // flags = 0 by default
    pipeline_layout_info.setLayoutCount = 0;         // No descriptor set layouts for basic pipeline
    pipeline_layout_info.pSetLayouts = NULL;         // No descriptor set layouts provided
    pipeline_layout_info.pushConstantRangeCount = 0; // No push constant ranges
    pipeline_layout_info.pPushConstantRanges = NULL; // No push constant ranges provided

    VkPipelineLayout pipeline_layout = VK_NULL_HANDLE;
    VkResult result = vkCreatePipelineLayout(sit_gs.vk.device, &pipeline_layout_info, NULL, &pipeline_layout);
    if (result != VK_SUCCESS) {
        char err_msg[256];
        snprintf(err_msg, sizeof(err_msg), "_SituationVulkanCreateComputePipeline: vkCreatePipelineLayout failed (VkResult = %d).", (int)result);
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_PIPELINE_LAYOUT_FAILED, err_msg);

        // --- Cleanup on Pipeline Layout Creation Failure ---
        // Destroy the shader module created successfully in step 2.
        vkDestroyShaderModule(sit_gs.vk.device, cs_module, NULL);
        cs_module = VK_NULL_HANDLE; // Defensive clear

        return pipeline; // Return invalid pipeline
    }
    // pipeline_layout is now a valid VkPipelineLayout handle that needs to be destroyed later.

    // --- 4. Create VkPipeline ---
    // Initializes to zero/default values.
    VkComputePipelineCreateInfo pipeline_info = {0};
    pipeline_info.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
    // pNext = NULL by default
    // flags = 0 by default
    pipeline_info.stage.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    // stage.pNext = NULL by default
    // stage.flags = 0 by default
    pipeline_info.stage.stage = VK_SHADER_STAGE_COMPUTE_BIT;
    pipeline_info.stage.module = cs_module; // Use the created shader module
    pipeline_info.stage.pName = "main";     // Standard entry point name
    // stage.pSpecializationInfo = NULL by default (No specialization constants)
    pipeline_info.layout = pipeline_layout; // Use the created pipeline layout
    // pipeline_info.basePipelineHandle = VK_NULL_HANDLE by default (Not deriving from another pipeline)
    // pipeline_info.basePipelineIndex = 0 by default

    VkPipeline vk_pipeline = VK_NULL_HANDLE;
    // Note: The first VK_NULL_HANDLE is the VkPipelineCache (optional, using NULL for default behavior).
    result = vkCreateComputePipelines(sit_gs.vk.device, VK_NULL_HANDLE, 1, &pipeline_info, NULL, &vk_pipeline);
    if (result != VK_SUCCESS) {
        char err_msg[256];
        snprintf(err_msg, sizeof(err_msg), "_SituationVulkanCreateComputePipeline: vkCreateComputePipelines failed (VkResult = %d).", (int)result);
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_PIPELINE_FAILED, err_msg);

        // --- Cleanup on Pipeline Creation Failure ---
        // Destroy the pipeline layout created successfully in step 3.
        vkDestroyPipelineLayout(sit_gs.vk.device, pipeline_layout, NULL);
        pipeline_layout = VK_NULL_HANDLE; // Defensive clear
        // Destroy the shader module created successfully in step 2.
        vkDestroyShaderModule(sit_gs.vk.device, cs_module, NULL);
        cs_module = VK_NULL_HANDLE; // Defensive clear

        return pipeline; // Return invalid pipeline
    }
    // vk_pipeline is now a valid VkPipeline handle.

    // --- 5. Post-Creation Cleanup ---
    // The VkShaderModule is baked into the VkPipeline.
    // As per Vulkan spec, we can destroy our reference to the module now.
    vkDestroyShaderModule(sit_gs.vk.device, cs_module, NULL);
    cs_module = VK_NULL_HANDLE; // Defensive clear (handle is no longer valid for this scope)

    // --- 6. Success: Populate and Return the Struct ---
    // Assign the successfully created Vulkan handles to the return struct.
    pipeline.vk_pipeline = vk_pipeline;
    pipeline.vk_pipeline_layout = pipeline_layout;

    // Important: The caller (e.g., SituationCreateComputePipelineFromMemory) is responsible for setting pipeline.id and adding it to resource tracking.
    // This function only sets the Vulkan-specific handles.

    return pipeline; // Return the valid pipeline struct
}

/**
 * @brief [INTERNAL] Destroys a Vulkan compute pipeline and its associated layout.
 * @details This helper function is the designated cleanup routine for a compute pipeline created by `_SituationVulkanCreateComputePipeline`. It ensures that all associated Vulkan objects are destroyed in the correct order to comply with API lifetime rules.
 *
 * @par Cleanup Process
 *   1.  **GPU Synchronization:** It begins by calling `vkDeviceWaitIdle` to ensure the GPU has finished executing any commands that might be using the pipeline. This is a critical step to prevent destroying a resource while it is still in use.
 *   2.  **Pipeline Destruction:** It destroys the `VkPipeline` object itself.
 *   3.  **Layout Destruction:** It then destroys the `VkPipelineLayout` that was created for and used by the pipeline.
 *
 * @param[in,out] pipeline A pointer to the `_SituationComputePipeline` struct containing the handles to the Vulkan resources to be destroyed. The contents of the struct are modified, setting handles to `VK_NULL_HANDLE` and the `id` to 0.
 *
 * @note This function is designed to be idempotent; it is safe to call on an already-destroyed or invalid pipeline handle.
 * @note The `VkShaderModule` is not destroyed here, as it is a temporary object that is destroyed immediately after the pipeline is created in `_SituationVulkanCreateComputePipeline`.
 * @warning The call to `vkDeviceWaitIdle` can introduce a significant GPU stall. This function should not be called frequently in performance-critical code paths.
 *
 * @see _SituationVulkanCreateComputePipeline(), SituationDestroyComputePipeline()
 */
static void _SituationVulkanDestroyComputePipeline(_SituationComputePipeline* pipeline) {
    // --- 1. Input Validation ---
    // Check if the pointer is valid and if the pipeline handle indicates a valid object.
    // Using vk_pipeline as the primary indicator based on library struct definition patterns.
    if (!pipeline || pipeline->vk_pipeline == VK_NULL_HANDLE) {
        // Silently return if the pipeline is invalid or already destroyed.
        // This is a common and safe pattern for destroy functions.
        return;
    }

    // --- 2. Ensure GPU is Finished ---
    // Wait for the device to be idle to guarantee no commands are using this pipeline.
    // This is the simplest and safest way, though it stalls the GPU pipeline.
    // A more advanced system might use fences associated with the last use of the pipeline.
    VkResult wait_result = vkDeviceWaitIdle(sit_gs.vk.device);
    if (wait_result != VK_SUCCESS) {
        // Log a warning, but proceed with destruction to avoid leaking resources.
        // The device might be in a bad state, but cleanup is still necessary.
        fprintf(stderr, "WARNING: vkDeviceWaitIdle failed (0x%x) in _SituationVulkanDestroyComputePipeline. Proceeding with destruction.\n", wait_result);
    }

    // --- 3. Destroy Vulkan Resources (Reverse Order of Creation) ---
    // 1. Destroy the main compute pipeline object.
    vkDestroyPipeline(sit_gs.vk.device, pipeline->vk_pipeline, NULL);
    pipeline->vk_pipeline = VK_NULL_HANDLE;

    // 2. Destroy the pipeline layout.
    // This layout was created specifically for this pipeline.
    vkDestroyPipelineLayout(sit_gs.vk.device, pipeline->vk_pipeline_layout, NULL);
    pipeline->vk_pipeline_layout = VK_NULL_HANDLE;

    // 3. Destroy the shader module.
    // Note: Based on library snippets (_SituationVulkanCreateComputePipeline), the VkShaderModule is often destroyed immediately after pipeline creation and not stored long-term in the _SituationComputePipeline struct.
    // If it *is* stored (e.g., in a member like `pipeline->vk_shader_module`), then this line should be uncommented and used.
    // ---
    // if (pipeline->vk_shader_module != VK_NULL_HANDLE) {
    //     vkDestroyShaderModule(sit_gs.vk.device, pipeline->vk_shader_module, NULL);
    //     pipeline->vk_shader_module = VK_NULL_HANDLE;
    // }
    // ---
    // If the shader module is NOT stored in the struct, this step is not needed here as it was already destroyed in _SituationVulkanCreateComputePipeline.
    // Double destruction is invalid, so we must be sure.
    // Assuming the common pattern where it's destroyed in Create and not stored:
    // (No action needed for shader module in this function based on typical patterns)

    // --- 4. Reset Public Identifier ---
    // Mark the struct as destroyed by resetting its public ID.
    pipeline->id = 0;
}

/**
 * @brief [INTERNAL] Records a command to transition the layout of a VkImage, inserting a memory barrier.
 * @details This is a critical Vulkan synchronization helper that wraps `vkCmdPipelineBarrier` specifically for image layout transitions.
 *          Changing an image's layout is the primary way in Vulkan to signal a change in how the image will be used, ensuring that writes from one pipeline stage are visible to reads in a subsequent stage.
 *
 * @par Synchronization Logic
 *   The function automatically determines the correct `srcStageMask`, `dstStageMask`, `srcAccessMask`, and `dstAccessMask` for a set of common, essential transitions:
 *   - `UNDEFINED` -> `TRANSFER_DST_OPTIMAL`: Prepares an image to be a destination for a copy operation.
 *   - `TRANSFER_DST_OPTIMAL` -> `SHADER_READ_ONLY_OPTIMAL`: Makes an image that has been written to available for sampling in a shader.
 *   - `PRESENT_SRC_KHR` -> `TRANSFER_SRC_OPTIMAL`: Prepares a swapchain image (that was ready for presentation) to be used as a source for a copy (e.g., for screenshots).
 *   - `TRANSFER_SRC_OPTIMAL` -> `PRESENT_SRC_KHR`: Transitions a swapchain image back to a presentable state after a copy.
 *
 * If an unsupported transition is requested, an error is set.
 *
 * @param cmd The `VkCommandBuffer` (which must be in the recording state) into which the pipeline barrier command will be recorded.
 * @param image The `VkImage` whose layout is to be transitioned.
 * @param mip_levels The number of mip levels in the image's subresource range to be transitioned.
 * @param old_layout The current `VkImageLayout` of the image.
 * @param new_layout The target `VkImageLayout` to transition the image to.
 *
 * @note This function is a fundamental building block for managing resource lifetimes and dependencies in the Vulkan backend.
 * @warning This is a low-level helper for internal use only. Incorrectly specifying `old_layout` can lead to validation errors or race conditions.
 *
 * @see _SituationVulkanCopyBufferToImage(), _SituationVulkanGenerateMipmaps(), vkCmdPipelineBarrier()
 */
static void _SituationVulkanTransitionImageLayout(VkCommandBuffer cmd, VkImage image, uint32_t mip_levels, VkImageLayout old_layout, VkImageLayout new_layout) {
    VkImageMemoryBarrier barrier = {};
    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    barrier.oldLayout = old_layout;
    barrier.newLayout = new_layout;
    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.image = image;
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    barrier.subresourceRange.baseMipLevel = 0;
    barrier.subresourceRange.levelCount = mip_levels;
    barrier.subresourceRange.baseArrayLayer = 0;
    barrier.subresourceRange.layerCount = 1;

    VkPipelineStageFlags source_stage;
    VkPipelineStageFlags destination_stage;

    // Determine pipeline stages and access masks based on the layouts
    if (old_layout == VK_IMAGE_LAYOUT_UNDEFINED && new_layout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) {
        barrier.srcAccessMask = 0;
        barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
        destination_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
    } else if (old_layout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL && new_layout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) {
        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
        source_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
        destination_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
    } else if (old_layout == VK_IMAGE_LAYOUT_PRESENT_SRC_KHR && new_layout == VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL) {
        barrier.srcAccessMask = VK_ACCESS_MEMORY_READ_BIT;
        barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
        source_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
        destination_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
    } else if (old_layout == VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL && new_layout == VK_IMAGE_LAYOUT_PRESENT_SRC_KHR) {
        barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
        barrier.dstAccessMask = VK_ACCESS_MEMORY_READ_BIT;
        source_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
        destination_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
    } else {
        // This is not an exhaustive list. Add other transitions as needed.
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Unsupported image layout transition specified in helper.");
        return;
    }

    vkCmdPipelineBarrier(cmd, source_stage, destination_stage, 0, 0, NULL, 0, NULL, 1, &barrier);
}

/**
 * @brief [INTERNAL] Records a command to copy data from a VkBuffer to a VkImage.
 * @details This is a fundamental Vulkan utility function that wraps `vkCmdCopyBufferToImage`. It is used to transfer raw pixel data from a staging buffer in CPU-accessible memory to a final, device-local image on the GPU.
 *          It configures a single `VkBufferImageCopy` region to copy the entire buffer to the base mip level (level 0) and base array layer (layer 0) of the destination image.
 *
 * @param cmd The `VkCommandBuffer` (which must be in the recording state) into which the copy command will be recorded.
 * @param buffer The source `VkBuffer` containing the pixel data to be copied.
 * @param image The destination `VkImage` that will receive the pixel data.
 * @param width The width of the image region to copy, in pixels.
 * @param height The height of the image region to copy, in pixels.
 *
 * @note This function assumes that the destination `image` has been previously transitioned to the `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` layout, making it ready to receive data.
 * @warning This is a low-level helper for internal use by functions like `SituationCreateTexture`. It does not perform any synchronization; the caller is responsible for ensuring the source buffer is ready and for transitioning the image layout after the copy is complete.
 *
 * @see SituationCreateTexture(), _SituationVulkanTransitionImageLayout(), vkCmdCopyBufferToImage()
 */
static void _SituationVulkanCopyBufferToImage(VkCommandBuffer cmd, VkBuffer buffer, VkImage image, uint32_t width, uint32_t height) {
    VkBufferImageCopy region = {};
    region.bufferOffset = 0;
    region.bufferRowLength = 0;
    region.bufferImageHeight = 0;
    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    region.imageSubresource.mipLevel = 0;
    region.imageSubresource.baseArrayLayer = 0;
    region.imageSubresource.layerCount = 1;
    region.imageOffset = (VkOffset3D){0, 0, 0};
    region.imageExtent = (VkExtent3D){width, height, 1};

    vkCmdCopyBufferToImage(cmd, buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);
}

/**
 * @brief [INTERNAL] Copies a device-local VkImage to a new, CPU-readable memory buffer.
 * @details This is the core of the Vulkan screenshot implementation. It performs these steps:
 *          1. Creates a temporary, host-visible VkBuffer to serve as the copy destination.
 *          2. Records and submits a one-shot command buffer to:
 *             a. Transition the source image layout from its current layout to VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL.
 *             b. Copy the image data into the temporary buffer using vkCmdCopyImageToBuffer.
 *             c. Transition the source image layout back to its original layout so it can be presented.
 *          3. Waits for the GPU to finish the copy operation.
 *          4. Maps the temporary buffer's memory so the CPU can read it.
 *          5. Allocates a final CPU-side buffer and copies the pixel data into it for the user.
 *          6. Cleans up all temporary Vulkan resources.
 *
 * @param srcImage The source VkImage to read from (must have VK_IMAGE_USAGE_TRANSFER_SRC_BIT).
 * @param srcImageLayout The current layout of the source image (e.g., VK_IMAGE_LAYOUT_PRESENT_SRC_KHR).
 * @param width The width of the image.
 * @param height The height of the image.
 * @return A `malloc`'d buffer containing the raw RGBA pixel data. The caller is responsible for `free()`ing this buffer. Returns NULL on failure.
 */
static void* _SituationVulkanBlitImageToHostVisibleBuffer(VkImage srcImage, VkImageLayout srcImageLayout, uint32_t width, uint32_t height) {
    VkBuffer dstBuffer;
    VmaAllocation dstAllocation;
    VkDeviceSize bufferSize = (VkDeviceSize)width * height * 4; // Assuming 4 bytes per pixel (RGBA)
    void* finalImageData = NULL; // The final buffer we will return to the user

    // --- Step 1: Create the destination buffer in host-visible memory ---
    VkBufferCreateInfo bufferInfo = { .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, .size = bufferSize, .usage = VK_BUFFER_USAGE_TRANSFER_DST_BIT };
    VmaAllocationCreateInfo allocInfo = { .flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT, .usage = VMA_MEMORY_USAGE_GPU_TO_CPU };

    if (vmaCreateBuffer(sit_gs.vk.vma_allocator, &bufferInfo, &allocInfo, &dstBuffer, &dstAllocation, NULL) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED, "Failed to create host-visible buffer for screenshot.");
        return NULL;
    }

    // --- Step 2: Record and submit commands for the copy ---
    VkCommandBuffer cmd = _SituationVulkanBeginSingleTimeCommands();

    // a. Transition source image to be ready for copy
    //    We need a new, more generic transition helper for this.
    _SituationVulkanTransitionImageLayout(cmd, srcImage, 1, srcImageLayout, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL);

    // b. Record the copy command
    VkBufferImageCopy region = {};
    region.bufferOffset = 0;
    region.bufferRowLength = 0;
    region.bufferImageHeight = 0;
    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    region.imageSubresource.mipLevel = 0;
    region.imageSubresource.baseArrayLayer = 0;
    region.imageSubresource.layerCount = 1;
    region.imageOffset = (VkOffset3D){0, 0, 0};
    region.imageExtent = (VkExtent3D){width, height, 1};
    vkCmdCopyImageToBuffer(cmd, srcImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, dstBuffer, 1, ®ion);

    // c. Transition source image back to its original layout so it can be presented
    _SituationVulkanTransitionImageLayout(cmd, srcImage, 1, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, srcImageLayout);

    // Submit and wait for completion
    _SituationVulkanEndSingleTimeCommands(cmd);

    // --- Step 3: Map the memory, copy it, and clean up ---
    void* mappedData;
    if (vmaMapMemory(sit_gs.vk.vma_allocator, dstAllocation, &mappedData) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_BUFFER_MAP_FAILED, "Failed to map screenshot buffer.");
        vmaDestroyBuffer(sit_gs.vk.vma_allocator, dstBuffer, dstAllocation);
        return NULL;
    }

    // Allocate the final buffer for the user and copy the data
    finalImageData = malloc(bufferSize);
    if (finalImageData) {
        memcpy(finalImageData, mappedData, bufferSize);
    } else {
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Final screenshot image buffer.");
    }

    vmaUnmapMemory(sit_gs.vk.vma_allocator, dstAllocation);
    vmaDestroyBuffer(sit_gs.vk.vma_allocator, dstBuffer, dstAllocation);

    return finalImageData;
}

/**
 * @brief [INTERNAL] Generates a complete mipmap chain for a Vulkan image using sequential blits.
 * @details This helper function is responsible for creating all mipmap levels for a given texture, from the base level (mip 0) down to the final 1x1 level. It performs this by iteratively blitting from each mip level `i` to the next level `i+1`, which has half the dimensions.
 *          This process is essential for high-quality texture rendering, as it provides pre-filtered, lower-resolution versions of the texture for the GPU to sample from when the object is far from the camera, significantly reducing aliasing and shimmering artifacts.
 *
 * @par Synchronization and Workflow
 *   The function executes a precise, looped sequence of commands for each new mip level:
 *   1.  **Barrier:** It first records a `VkImageMemoryBarrier` to transition the layout of the *source* mip level (e.g., mip `i-1`) from `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` to `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`.
 *       This ensures that the previous write operation (either the initial data copy or the previous blit) is complete and the memory is visible for reading.
 *   2.  **Blit:** It records a `vkCmdBlitImage` command. This command performs the downscaling operation, copying from the source mip level to the destination mip level (e.g., from mip `i-1` to mip `i`). Linear filtering is used to ensure a smooth, high-quality downsample.
 *   3.  **Barrier:** Immediately after the blit command, it records another barrier to transition the layout of the *source* mip level (`i-1`) from `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` to `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`.
 *       This makes the now-finalized mip level available for sampling by shaders.
 *
 * After the loop finishes, a final barrier is issued to transition the very last mip level to `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`.
 *
 * @param cmd The `VkCommandBuffer` (which must be in the recording state) into which the barrier and blit commands will be recorded.
 * @param image The `VkImage` for which to generate mipmaps. This image must have been created with `VK_IMAGE_USAGE_TRANSFER_SRC_BIT` and `VK_IMAGE_USAGE_TRANSFER_DST_BIT` usage flags.
 * @param width The width of the base mip level (level 0).
 * @param height The height of the base mip level (level 0).
 * @param mip_levels The total number of mip levels in the image, including the base level.
 *
 * @note This function assumes that the base mip level (level 0) has already been populated with data and that all mip levels are currently in the `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` layout.
 * @warning This function is for internal use by `SituationCreateTexture` only and should not be called directly.
 *
 * @see SituationCreateTexture(), vkCmdBlitImage(), vkCmdPipelineBarrier()
 */
static void _SituationVulkanGenerateMipmaps(VkCommandBuffer cmd, VkImage image, int32_t width, int32_t height, uint32_t mip_levels) {
    // This barrier will be reused to transition each mip level
    VkImageMemoryBarrier barrier = {};
    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    barrier.image = image;
    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    barrier.subresourceRange.baseArrayLayer = 0;
    barrier.subresourceRange.layerCount = 1;
    barrier.subresourceRange.levelCount = 1;

    int32_t mip_width = width;
    int32_t mip_height = height;

    for (uint32_t i = 1; i < mip_levels; i++) {
        // 1. Transition the previous mip level (i-1) to be a transfer source.
        barrier.subresourceRange.baseMipLevel = i - 1;
        barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
        barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
        vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, NULL, 0, NULL, 1, &barrier);

        // 2. Perform the blit from the previous level to the current level.
        VkImageBlit blit = {};
        blit.srcOffsets[0] = (VkOffset3D){0, 0, 0};
        blit.srcOffsets[1] = (VkOffset3D){mip_width, mip_height, 1};
        blit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        blit.srcSubresource.mipLevel = i - 1;
        blit.srcSubresource.baseArrayLayer = 0;
        blit.srcSubresource.layerCount = 1;
        blit.dstOffsets[0] = (VkOffset3D){0, 0, 0};
        blit.dstOffsets[1] = (VkOffset3D){ mip_width > 1 ? mip_width / 2 : 1, mip_height > 1 ? mip_height / 2 : 1, 1 };
        blit.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        blit.dstSubresource.mipLevel = i;
        blit.dstSubresource.baseArrayLayer = 0;
        blit.dstSubresource.layerCount = 1;
        vkCmdBlitImage(cmd, image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &blit, VK_FILTER_LINEAR);

        // 3. Transition the previous mip level (i-1) to be shader-readable.
        barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
        barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
        barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
        vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0, NULL, 0, NULL, 1, &barrier);

        // Update dimensions for the next iteration
        if (mip_width > 1) mip_width /= 2;
        if (mip_height > 1) mip_height /= 2;
    }

    // Finally, transition the very last mip level to be shader-readable.
    barrier.subresourceRange.baseMipLevel = mip_levels - 1;
    barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
    vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0, NULL, 0, NULL, 1, &barrier);
}

#endif // SITUATION_USE_VULKAN

/**
 * @brief [INTERNAL] Performs a comprehensive, robust cleanup of all library components in response to an initialization failure.
 * @details This is the primary error handling routine for the `SituationInit` function. It is designed to be called from any point during the initialization sequence if a critical failure occurs.
 *          Its purpose is to safely unwind the initialization process, releasing any resources that were successfully allocated before the point of failure to prevent leaks.
 *
 * @par Cleanup Strategy
 *   The function executes the main cleanup routines in the **exact reverse order of initialization** to respect dependencies (e.g., the Vulkan surface must be destroyed before the GLFW window).
 *   1.  **GPU Synchronization:** It first attempts to wait for the GPU to go idle (`vkDeviceWaitIdle` or `glFinish`). This is a critical step to ensure that no resources are in use by the GPU when destruction begins, preventing validation errors or crashes.
 *   2.  **Subsystem Teardown:** Calls `_SituationCleanupSubsystems` to release audio, input, and timer resources.
 *   3.  **Renderer Teardown:** Calls `_SituationCleanupRenderer` to dispatch to the backend-specific cleanup (`_SituationCleanupOpenGL` or `_SituationCleanupVulkan`).
 *   4.  **Platform Teardown:** Calls `_SituationCleanupPlatform` to destroy the window and terminate GLFW.
 *
 * The robustness of this function relies on the fact that each individual cleanup helper is idempotent and safely handles being called on a partially initialized state (i.e., by checking if resource handles are `NULL` before attempting to destroy them).
 *
 * @note This function is for internal use by `SituationInit` only and should never be called directly.
 * @warning After this function completes, the library is in a fully uninitialized state.
 *
 * @see SituationInit(), _SituationCleanupSubsystems(), _SituationCleanupRenderer(), _SituationCleanupPlatform()
 */
static void _SituationFullCleanupOnError(void) {
    #if defined(SITUATION_USE_VULKAN)
    if (sit_gs.vk.device) vkDeviceWaitIdle(sit_gs.vk.device);
    #elif defined(SITUATION_USE_OPENGL)
    if (sit_gs.sit_glfw_window) glFinish();
    #endif

    // Cleanup in reverse order of initialization
    _SituationCleanupSubsystems();
    _SituationCleanupRenderer();
    _SituationCleanupPlatform();
}

/**
 * @brief Gets the graphics backend renderer type that the library was compiled with.
 * @details This function allows the application to query which rendering backend (OpenGL or Vulkan) is currently active.
 *          This is useful for writing backend-specific code paths, such as loading pre-compiled SPIR-V shaders for Vulkan or providing raw GLSL for OpenGL, or for displaying renderer information to the user.
 *
 * The active renderer is determined at compile-time by the `SITUATION_USE_OPENGL` or `SITUATION_USE_VULKAN` preprocessor defines.
 *
 * @return An enum `SituationRendererType` indicating the active backend (`SIT_RENDERER_OPENGL` or `SIT_RENDERER_VULKAN`).
 * @return An undefined or default value if the library is not initialized.
 *
 * @note This function requires the library to be initialized to return a meaningful value.
 *
 * @see SituationGetVulkanInstance(), SituationGetGLFWwindow()
 */
SITAPI SituationRendererType SituationGetRendererType(void) {
    return sit_gs.renderer_type;
}

// --- Callbacks and Event Handling ---
/**
 * @brief Sets a user-defined callback function to be executed just before the library shuts down.
 * @details This function registers a callback that will be invoked at the very beginning of the `SituationShutdown` process.
 *          It provides a final opportunity for the application to perform its own cleanup tasks, such as saving state to a file, closing network connections, or freeing application-specific memory, while the library's subsystems are still active.
 *
 * @param callback A function pointer to the callback to be executed. The callback receives the `user_data` pointer as its only argument. Pass `NULL` to clear a previously set callback.
 * @param user_data A custom, user-defined pointer that will be passed to the callback function. This can be used to provide context or state to the callback without using global variables.
 *
 * @note Only one exit callback can be registered at a time. A new call to this function will overwrite any previously set callback.
 *
 * @see SituationShutdown()
 */
SITAPI void SituationSetExitCallback(void (*callback)(void* user_data), void* user_data) {
    if (!sit_gs.is_initialized) return;
    sit_gs.exit_callback = callback;
    sit_gs.exit_callback_user_data = user_data;
}

/**
 * @brief Sets a user-defined callback function to be executed when the window's framebuffer is resized.
 * @details This function registers a callback that is invoked whenever the pixel dimensions of the main window's rendering area change. This can happen when the user manually resizes the window or when the window is moved between displays with different DPI scaling factors.
 *          This callback is the primary mechanism for handling resolution-dependent updates, such as:
 * - Adjusting the graphics viewport (`glViewport` or `vkCmdSetViewport`).
 * - Recalculating projection matrices for cameras.
 * - Resizing off-screen framebuffers (`SituationVirtualDisplay`) that should match the window size.
 *
 * @param callback A function pointer to the callback to be executed. The callback receives the new `width` and `height` in pixels, along with the `user_data` pointer. Pass `NULL` to clear a previously set callback.
 * @param user_data A custom, user-defined pointer that will be passed to the callback function.
 *
 * @note The library's internal `_SituationGLFWFramebufferSizeCallback` is always called first to update internal state (like viewport for OpenGL and the resize flag for Vulkan). The user's callback is invoked immediately after.
 * @warning The callback is executed in the same thread that calls `SituationPollInputEvents`. It is not asynchronous and will block the main loop until it returns.
 *
 * @see SituationGetRenderWidth(), SituationGetRenderHeight()
 */
SITAPI void SituationSetResizeCallback(void (*callback)(int width, int height, void* user_data), void* user_data) {
    if (!sit_gs.is_initialized) return;
    sit_gs.resize_callback = callback;
    sit_gs.resize_callback_user_data = user_data;
}

// --- Command-Line Argument Queries ---
/**
 * @brief Checks if a command-line argument flag exists.
 * @details Searches for an exact match (e.g., "-server", "--fullscreen"). Case-sensitive.
 * @param arg_name The argument to search for.
 * @return True if the argument was present at launch.
 */
SITAPI bool SituationIsArgumentPresent(const char* arg_name) {
    if (!sit_gs.is_initialized || !arg_name) return false;
    for (int i = 1; i < sit_gs.argc; i++) { // Start at 1 to skip the program name
        if (strcmp(sit_gs.argv[i], arg_name) == 0) {
            return true;
        }
    }
    return false;
}

/**
 * @brief Gets the value of a command-line argument.
 * @details Supports two formats: "-key:value" or "-key value".
 *          For "-key:value", it returns a pointer to the character after the colon.
 *          For "-key value", it returns the next argument in the list.
 * @param arg_name The key of the argument to look for (e.g., "-level").
 * @return A const string with the value, or NULL if the argument is not found.
 */
SITAPI const char* SituationGetArgumentValue(const char* arg_name) {
    if (!sit_gs.is_initialized || !arg_name) return NULL;
    size_t arg_len = strlen(arg_name);

    for (int i = 1; i < sit_gs.argc; i++) {
        // Check for "-key:value" format
        if (strncmp(sit_gs.argv[i], arg_name, arg_len) == 0 && sit_gs.argv[i][arg_len] == ':') {
            return sit_gs.argv[i] + arg_len + 1;
        }
        // Check for "-key value" format
        if (strcmp(sit_gs.argv[i], arg_name) == 0) {
            // Ensure there is a next argument to be the value
            if (i + 1 < sit_gs.argc) {
                return sit_gs.argv[i + 1];
            }
        }
    }
    return NULL;
}

/**
 * @brief Prepares the rendering context for a new frame.
 *
 * @details This function must be called at the beginning of each application framebefore any rendering commands are recorded or executed. It performs backend-specific setup necessary to acquire the next rendering target (e.g., the next swapchain image in Vulkan) and prepare command buffers.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:**
 *   - Makes the main GLFW window's OpenGL context current for the calling thread.
 *   - Binds the default framebuffer (the main window's backbuffer).
 *   - Sets the viewport to cover the entire window area.
 *   - This function typically always succeeds if the library is initialized and the OpenGL context is valid, returning `true`.
 * - **Vulkan:**
 *   - Waits for the GPU to finish processing the commands associated with the frame identified by `sit_gs.vk.current_frame_index`.
 *   - Attempts to acquire the next image from the swapchain. This image will be the target for rendering this frame.
 *   - If the swapchain is out of date (e.g., due to a window resize), this function internally calls `_SituationVulkanRecreateSwapchain` to handle the recreation process. In this specific case, it returns `false` to signal that the frame setup was interrupted and should be retried.
 *   - Resets the fence associated with the current frame index to the unsignaled state.
 *   - Resets the primary command buffer for the current frame.
 *   - Begins recording commands into the primary command buffer.
 *
 * @return `true` if the frame was successfully prepared and rendering can proceed.
 *         This is the standard return value for both OpenGL and Vulkan under normal conditions.
 * @return `false` (Vulkan only) if the swapchain was out of date and was automatically recreated. The caller should typically call `SituationAcquireFrameCommandBuffer()` again in the next iteration of their main loop to proceed with the new swapchain.
 * @return `false` if the library is not initialized.
 * @return `false` (Vulkan) if acquiring the swapchain image fails for reasons other than `VK_ERROR_OUT_OF_DATE_KHR` or `VK_SUBOPTIMAL_KHR`.
 * @return `false` (Vulkan) if resetting or beginning the command buffer fails.
 *
 * @note It is the caller's responsibility to ensure that:
 *       1. The library is initialized before calling this function.
 *       2. This function is called once per frame, before any rendering commands.
 *       3. (Vulkan) The application loop handles the `false` return value correctly, especially when it indicates swapchain recreation.
 *
 * @warning This function is not thread-safe and must be called from the thread that initialized the library.
 */
SITAPI bool SituationAcquireFrameCommandBuffer(void) {
    // --- 1. Library Initialization Check ---
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot begin frame before library initialization.");
        return false;
    }

#if defined(SITUATION_USE_OPENGL)
    {
        // --- 2. OpenGL Frame Setup ---
        // Make the context current for this thread (often a no-op if already current).
        glfwMakeContextCurrent(sit_gs.sit_glfw_window);
        // Bind the default framebuffer (main window backbuffer).
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
        // Set the viewport to the full window size.
        glViewport(0, 0, sit_gs.main_window_width, sit_gs.main_window_height);
        // OpenGL setup is generally straightforward and assumed to succeed
        // if the context is valid.
        return true;
    }

#elif defined(SITUATION_USE_VULKAN)
    {
        // --- 2. Vulkan Frame Setup ---

        // 2.1. Wait for the previous frame (using this frame's fence) to finish.
        // This ensures the command buffer and swapchain image are free to be reused.
        VkResult wait_result = vkWaitForFences(
            sit_gs.vk.device,
            1,
            &sit_gs.vk.in_flight_fences[sit_gs.vk.current_frame_index],
            VK_TRUE,           // waitAll
            UINT64_MAX         // timeout
        );
        if (wait_result != VK_SUCCESS) {
             _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_SYNC_OBJECT_FAILED, "Failed to wait for frame fence in SituationAcquireFrameCommandBuffer.");
             return false; // Indicate failure
        }

        // 2.2. Acquire the next swapchain image.
        uint32_t image_index;
        VkResult acquire_result = vkAcquireNextImageKHR(
            sit_gs.vk.device,
            sit_gs.vk.swapchain,
            UINT64_MAX, // timeout
            sit_gs.vk.image_available_semaphores[sit_gs.vk.current_frame_index], // Signal this semaphore when the image is acquired
            VK_NULL_HANDLE,                                                     // No fence to signal
            &image_index                                                        // Output: index of the acquired image
        );

        // 2.3. Handle Swapchain State.
        if (acquire_result == VK_ERROR_OUT_OF_DATE_KHR) {
            // The swapchain is incompatible (e.g., window resized) and must be recreated.
            // This function handles the recreation internally.
            _SituationVulkanRecreateSwapchain();
            // Return false to signal that the frame setup was interrupted.
            // The caller should retry SituationAcquireFrameCommandBuffer next frame.
            return false;
        } else if (acquire_result == VK_SUBOPTIMAL_KHR) {
             // The swapchain can still be used, but surface properties have changed.
             // It's often recommended to recreate for optimal presentation.
             // For now, we proceed but log it. A more robust system might trigger a recreate flag.
             // fprintf(stderr, "WARNING: Vulkan swapchain is suboptimal.\n");
             // Proceeding is generally safe, but performance/quality might be affected.
        } else if (acquire_result != VK_SUCCESS) {
            // An unexpected error occurred during image acquisition.
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED, "Failed to acquire swap chain image in SituationAcquireFrameCommandBuffer!");
            return false; // Indicate failure
        }

        // 2.4. Update Global State.
        // Store the index of the swapchain image we will render to this frame.
        sit_gs.vk.current_image_index = image_index;

        // 2.5. Prepare Command Buffer for Recording.
        // Reset the fence to the unsignaled state *before* resetting the command buffer.
        VkResult reset_fence_result = vkResetFences(
            sit_gs.vk.device,
            1,
            &sit_gs.vk.in_flight_fences[sit_gs.vk.current_frame_index]
        );
        if (reset_fence_result != VK_SUCCESS) {
             _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_SYNC_OBJECT_FAILED, "Failed to reset frame fence in SituationAcquireFrameCommandBuffer.");
             return false; // Indicate failure
        }

        // Get the command buffer for this frame (assuming this helper function exists and returns the correct buffer from sit_gs.vk.command_buffers).
        VkCommandBuffer cmd = SituationGetMainCommandBuffer(); // Or directly access: sit_gs.vk.command_buffers[sit_gs.vk.current_frame_index]
        if (cmd == VK_NULL_HANDLE) {
             _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to get main command buffer for frame in SituationAcquireFrameCommandBuffer.");
             return false; // Indicate failure
        }

        // Reset the command buffer to ensure it's ready for new commands.
        VkResult reset_cmd_result = vkResetCommandBuffer(cmd, 0); // VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT is 0
        if (reset_cmd_result != VK_SUCCESS) {
             _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to reset command buffer in SituationAcquireFrameCommandBuffer.");
             return false; // Indicate failure
        }

        // Begin recording commands into the command buffer.
        VkCommandBufferBeginInfo begin_info = {0};
        begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        // Flags = 0 means "one time submit" implicitly, and no inheritance.
        VkResult begin_result = vkBeginCommandBuffer(cmd, &begin_info);
        if (begin_result != VK_SUCCESS) {
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to begin recording command buffer in SituationAcquireFrameCommandBuffer!");
            return false; // Indicate failure
        }

        // If we reached here, Vulkan frame setup was successful (excluding OOD/K recreate).
        return true;
    }
#endif

    // Should not be reached if SITUATION_USE_OPENGL or SITUATION_USE_VULKAN is defined,
    // but included for theoretical completeness if neither backend is selected.
    _SituationSetErrorFromCode(SITUATION_ERROR_NOT_IMPLEMENTED, "No graphics backend defined for SituationAcquireFrameCommandBuffer.");
    return false;
}

/**
 * @brief Submits all recorded commands for the current frame and presents the result.
 *
 * @details This function finalizes the rendering for the frame started by `SituationAcquireFrameCommandBuffer`.
 *          It submits the recorded commands to the GPU, waits for the GPU to finish rendering to the swapchain image, and then presents that image to the screen. It also handles frame rate limiting (if configured) and updates internal timing statistics like FPS.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:**
 *   - Calls `glfwSwapBuffers` to swap the front and back framebuffers, making the rendered image visible on the screen.
 *   - Implicitly waits for the GPU to finish rendering the previous frame before swapping (this behavior can depend on VSync settings).
 * - **Vulkan:**
 *   - Ends the recording of the primary command buffer for the current frame.
 *   - Submits the command buffer to the graphics queue. This submission waits on the `image_available_semaphore` for the swapchain image to be acquired and signals the `render_finished_semaphore` when rendering is complete.
 *   - Presents the rendered swapchain image to the screen using `vkQueuePresentKHR`, waiting on the `render_finished_semaphore`.
 *   - Handles swapchain recreation if the presentation surface becomes outdated (`VK_ERROR_OUT_OF_DATE_KHR`, `VK_SUBOPTIMAL_KHR`, or window resize).
 *   - Advances the `current_frame_index` for the next frame's synchronization objects.
 *
 * @return SITUATION_SUCCESS on successful completion of the frame.
 * @return SITUATION_ERROR_NOT_INITIALIZED if the library is not initialized.
 * @return SITUATION_ERROR_VULKAN_COMMAND_FAILED (Vulkan) if ending the command buffer or submitting it to the queue fails.
 * @return SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED (Vulkan) if presenting the image fails for reasons other than out-of-date/suboptimal swapchain.
 *
 * @note It is the caller's responsibility to ensure that:
 *       1. The library is initialized.
 *       2. `SituationAcquireFrameCommandBuffer` was called successfully for this frame.
 *       3. All rendering commands for the frame have been recorded.
 * @warning This function is not thread-safe and must be called from the thread that initialized the library and is managing the rendering loop.
 *
 * @see SituationAcquireFrameCommandBuffer()
 */
SITAPI SituationError SituationEndFrame(void) {
    // --- 1. Library Initialization Check ---
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot end frame.");
        return SITUATION_ERROR_NOT_INITIALIZED;
    }

    // --- 2. Backend-Specific Frame End ---
#if defined(SITUATION_USE_OPENGL)
    {
        // --- 2a. OpenGL Frame End ---
        // Swap the front and back buffers to display the rendered frame.
        glfwSwapBuffers(sit_gs.sit_glfw_window);
        // Note: glfwSwapBuffers typically doesn't return an error code.
        // Context loss or other severe issues would usually be caught elsewhere.
        // For maximum robustness, one could check glfwGetError() here, but it's often omitted.

        // OpenGL path implicitly succeeds if glfwSwapBuffers doesn't crash.
        // Return success.
    }

#elif defined(SITUATION_USE_VULKAN)
    {
        // --- 2b. Vulkan Frame End ---

        // 1. End recording the primary command buffer for this frame.
        // Get the command buffer first and validate it.
        VkCommandBuffer cmd = (VkCommandBuffer)SituationGetMainCommandBuffer();
        if (cmd == VK_NULL_HANDLE) { // Check if SituationGetMainCommandBuffer returned NULL
             _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to get main command buffer for ending frame.");
             return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
        }

        if (vkEndCommandBuffer(cmd) != VK_SUCCESS) {
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to end recording command buffer!");
            return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
        }

        // 2. Submit the command buffer to the graphics queue.
        VkSubmitInfo submit_info = {0};
        submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

        VkSemaphore wait_semaphores[] = { sit_gs.vk.image_available_semaphores[sit_gs.vk.current_frame_index] };
        VkPipelineStageFlags wait_stages[] = { VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT };
        submit_info.waitSemaphoreCount = 1;
        submit_info.pWaitSemaphores = wait_semaphores;
        submit_info.pWaitDstStageMask = wait_stages;

        submit_info.commandBufferCount = 1;
        submit_info.pCommandBuffers = &cmd;

        VkSemaphore signal_semaphores[] = { sit_gs.vk.render_finished_semaphores[sit_gs.vk.current_frame_index] };
        submit_info.signalSemaphoreCount = 1;
        submit_info.pSignalSemaphores = signal_semaphores;

        // Submit the command buffer, waiting on the acquire semaphore and signaling the render finish semaphore.
        // The fence associated with this frame is signaled when the submission completes.
        if (vkQueueSubmit(sit_gs.vk.graphics_queue, 1, &submit_info, sit_gs.vk.in_flight_fences[sit_gs.vk.current_frame_index]) != VK_SUCCESS) {
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to submit draw command buffer!");
            return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
        }

        // 3. Present the rendered image to the screen.
        VkPresentInfoKHR present_info = {0};
        present_info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
        present_info.waitSemaphoreCount = 1;
        present_info.pWaitSemaphores = signal_semaphores; // Wait for rendering to finish
        VkSwapchainKHR swapchains[] = { sit_gs.vk.swapchain };
        present_info.swapchainCount = 1;
        present_info.pSwapchains = swapchains;
        present_info.pImageIndices = &sit_gs.vk.current_image_index; // Present the image we acquired/used this frame

        // Perform the presentation.
        VkResult result = vkQueuePresentKHR(sit_gs.vk.present_queue, &present_info);

        // 4. Handle Presentation Result & Swapchain State.
        if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || sit_gs.vk.framebuffer_resized) {
            // The swapchain is out of date or not optimal. Recreate it.
            // Reset the resize flag if it was set.
            sit_gs.vk.framebuffer_resized = false;
            _SituationVulkanRecreateSwapchain();
            // Note: We don't return an error here. Recreating the swapchain is handled internally.
            // The application should check for swapchain recreation needs in SituationAcquireFrameCommandBuffer.
        } else if (result != VK_SUCCESS) {
            // An unexpected error occurred during presentation.
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED, "Failed to present swap chain image!");
            return SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED;
        }

        // Store the index of the image we just submitted for presentation.
        sit_gs.vk.last_presented_image_index = sit_gs.vk.current_image_index;

        // 5. Advance Frame Index for Next Frame's Synchronization.
        // Use the dynamically determined max frames in flight, not a compile-time constant.
        sit_gs.vk.current_frame_index = (sit_gs.vk.current_frame_index + 1) % sit_gs.vk.max_frames_in_flight;
    }
#endif // SITUATION_USE_VULKAN

    // --- 3. Post-Frame Logic (Timing, FPS) ---
    // Update timing and FPS counter. This happens regardless of the backend.
    // It includes the time taken by buffer swapping/presentation.

    // Frame Rate Limiting (if a target time is set).
    if (sit_gs.target_frame_time > 0.0) {
        double next_frame_start_time = sit_gs.current_time + sit_gs.target_frame_time;
        double current_time = glfwGetTime(); // Get current time for comparison
        while (current_time < next_frame_start_time) {
            // Yield control to the OS briefly to avoid consuming 100% CPU.
            #if defined(_WIN32)
                Sleep(0); // Yield the rest of the time slice
            #elif defined(__linux__) || defined(__APPLE__)
                // usleep can be less precise. Consider nanosleep for better control.
                // 100 microseconds is 0.1ms. Adjust or make dynamic based on remaining time if needed.
                usleep(100); // Sleep for 100 microseconds
            #endif
            current_time = glfwGetTime(); // Update current time for the next check
        }
    }

    // FPS Calculation Update.
    sit_gs.fps_frame_counter++;
    double time_since_last_fps_update = glfwGetTime() - sit_gs.fps_last_update_time;
    if (time_since_last_fps_update >= 1.0) {
        // Calculate average FPS over the last second (or so).
        sit_gs.current_fps = (int)((double)sit_gs.fps_frame_counter / time_since_last_fps_update);
        sit_gs.fps_frame_counter = 0; // Reset the counter
        sit_gs.fps_last_update_time = glfwGetTime(); // Reset the timer
    }

    // --- 4. Success ---
#if defined(SITUATION_USE_OPENGL) || defined(SITUATION_USE_VULKAN)
    // Explicitly return success if the backend-specific code completed without error return.
    return SITUATION_SUCCESS;
#else
    // Fallback if neither backend is defined (should be caught by compiler flags usually).
    return SITUATION_ERROR_NOT_IMPLEMENTED;
#endif
}

/**
 * @brief Gets the primary command buffer for the current frame.
 *
 * @details This function retrieves the main `SituationCommandBuffer` handle that should be used for recording rendering and compute commands for the frame currently being prepared or rendered.
 *          This handle is typically obtained *after* a successful call to `SituationAcquireFrameCommandBuffer` and is valid until `SituationEndFrame` is called.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** OpenGL operates in immediate mode and does not use explicit command buffers in the same way Vulkan does. Therefore, this function returns `NULL`.
 * - **Vulkan:** Returns the `VkCommandBuffer` associated with the current frame index (`sit_gs.vk.current_frame_index`). This buffer is managed internally by the library and is reset and begun at the start of the frame by `SituationAcquireFrameCommandBuffer`.
 *
 * @return A `SituationCommandBuffer` handle.
 *         - In Vulkan, this is a valid handle for the current frame's primary command buffer.
 *         - In OpenGL, this function returns `NULL`.
 * @return `NULL` if the library is not initialized, or if called at an inappropriate time (e.g., before `SituationAcquireFrameCommandBuffer` or after `SituationEndFrame` in Vulkan, if `sit_gs.vk.current_frame_index` is invalid).
 *
 * @note It is the caller's responsibility to ensure that:
 *       1. The library is initialized.
 *       2. (Vulkan) This function is called between `SituationAcquireFrameCommandBuffer` and `SituationEndFrame`.
 *       3. The returned handle is only used for recording commands and not stored persistently across frames without re-querying.
 *
 * @see SituationAcquireFrameCommandBuffer(), SituationEndFrame()
 */
SITAPI SituationCommandBuffer SituationGetMainCommandBuffer(void) {
    // --- 1. Library Initialization Check ---
    if (!sit_gs.is_initialized) {
        // Returning NULL is a safe default for an invalid/uninitialized state.
        // Could also set an error, but often just returning NULL is sufficient for a getter.
        // _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot get command buffer before library initialization.");
        return NULL;
    }

#if defined(SITUATION_USE_OPENGL)
    {
        // --- 2. OpenGL Path ---
        // OpenGL uses immediate mode. There isn't a user-facing "command buffer" object
        // in the same sense as Vulkan. Return NULL to indicate inapplicability.
        return NULL;
    }

#elif defined(SITUATION_USE_VULKAN)
    {
        // --- 2. Vulkan Path ---
        // Retrieve the command buffer for the current frame index.
        // This assumes sit_gs.vk.current_frame_index is valid (set by SituationAcquireFrameCommandBuffer).

        // Optional: Add a bounds check for robustness, though SituationAcquireFrameCommandBuffer should manage this.
        if (sit_gs.vk.current_frame_index >= sit_gs.vk.max_frames_in_flight) {
            // This indicates a potential logic error or state issue.
            _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Current frame index is out of bounds for command buffer access.");
            return NULL;
        }

        // Get the VkCommandBuffer from the internal array.
        VkCommandBuffer vk_cmd = sit_gs.vk.command_buffers[sit_gs.vk.current_frame_index];

        // Optional: Check if vk_cmd is VK_NULL_HANDLE, though SituationAcquireFrameCommandBuffer should provide a valid one.
        if (vk_cmd == VK_NULL_HANDLE) {
             _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Current frame's command buffer is unexpectedly NULL.");
             return NULL;
        }

        // Cast the VkCommandBuffer to the opaque SituationCommandBuffer type.
        // This relies on the definition: typedef struct SituationCommandBuffer_t* SituationCommandBuffer;
        // and assumes VkCommandBuffer can be cast to this pointer type or that SituationCommandBuffer is internally defined as (void*) or similar.
        // The safest way is often just a direct cast if they are pointer-sized.
        return (SituationCommandBuffer)(uintptr_t)vk_cmd;
        // Alternative casting if SituationCommandBuffer is a wrapper struct (less likely for opaque):
        // SituationCommandBuffer cmd_wrapper = { .internal_handle = vk_cmd };
        // return cmd_wrapper; // If it were a struct, but it's defined as a pointer.
    }
#endif

    // --- 3. Fallback (Should not be reached if backends are defined) ---
    // If neither SITUATION_USE_OPENGL nor SITUATION_USE_VULKAN is defined.
    return NULL;
}

SITAPI SituationError SituationCmdBeginRenderPass(SituationCommandBuffer cmd, const SituationRenderPassInfo* info) {
    if (!sit_gs.is_initialized) return SITUATION_ERROR_NOT_INITIALIZED;
    if (!info) return SITUATION_ERROR_INVALID_PARAM;

#if defined(SITUATION_USE_OPENGL)
    (void)cmd;
    GLbitfield clear_mask = 0;

    // 1. Bind the correct framebuffer
    if (info->display_id < 0) {
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
        glViewport(0, 0, sit_gs.main_window_width, sit_gs.main_window_height);
    } else {
        // ... (virtual display FBO binding logic) ...
    }

    // 2. Set clear values and determine clear mask
    if (info->color_attachment.loadOp == SIT_LOAD_OP_CLEAR) {
        glClearColor(info->color_attachment.clear.color.r / 255.0f, ...);
        clear_mask |= GL_COLOR_BUFFER_BIT;
    }
    if (info->depth_attachment.loadOp == SIT_LOAD_OP_CLEAR) {
        glClearDepth(info->depth_attachment.clear.depth);
        clear_mask |= GL_DEPTH_BUFFER_BIT;
        // NOTE: Does not handle stencil clear, but can be added.
    }

    // 3. Perform the clear
    if (clear_mask != 0) {
        glClear(clear_mask);
    }
    
    // NOTE: storeOp is a hint for tile-based renderers and is not explicitly handled in core OpenGL.
    return SITUATION_SUCCESS;

#elif defined(SITUATION_USE_VULKAN)
    // ... (This would require a more complex system of creating compatible VkRenderPass objects on the fly
    // or having a cache of them. For now, we'll implement the most common paths.)

    VkRenderPassBeginInfo rp_info = { .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO };
    VkClearValue clear_values[2];
    uint32_t clear_count = 0;

    // This is a simplified implementation. A real one would select a pre-created VkRenderPass
    // that matches the load/store ops. Here, we just map the clear ops.
    if (info->color_attachment.loadOp == SIT_LOAD_OP_CLEAR) {
        clear_values[clear_count++].color = (VkClearColorValue){{info->color_attachment.clear.color.r / 255.0f, ...}};
    }
    if (info->depth_attachment.loadOp == SIT_LOAD_OP_CLEAR) {
        clear_values[clear_count++].depthStencil = (VkClearDepthStencilValue){info->depth_attachment.clear.depth, info->depth_attachment.clear.stencil};
    }
    
    // ... (rest of the logic to select framebuffer and render pass, then call vkCmdBeginRenderPass) ...
    // This highlights that a full fix is architecturally very deep for Vulkan.
    // The provided implementation is a conceptual fix.

    // For this example, let's just use the old logic but respect the loadOp:
    if (info->color_attachment.loadOp == SIT_LOAD_OP_CLEAR) {
        return SituationCmdBeginRenderToDisplay((VkCommandBuffer)cmd, info->display_id, info->color_attachment.clear.color);
    } else {
        // Here you would begin a render pass with VK_ATTACHMENT_LOAD_OP_LOAD
        _SituationSetError("Non-clearing render passes not fully implemented for Vulkan yet.");
        return SITUATION_ERROR_NOT_IMPLEMENTED;
    }
#endif
}

SITAPI void SituationCmdEndRenderPass(SituationCommandBuffer cmd) {
#if defined(SITUATION_USE_OPENGL)
    (void)cmd;
    // Unbinding the FBO is often sufficient.
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
#elif defined(SITUATION_USE_VULKAN)
    vkCmdEndRenderPass((VkCommandBuffer)cmd);
#endif
}

/**
 * @brief Begins a render pass on a specific display target.
 * @details For OpenGL, this binds the appropriate framebuffer (0 for the main window, or an FBO for a virtual display), sets the viewport to the target's dimensions, and clears the color and depth buffers.
 *          For Vulkan, this begins a formal VkRenderPass on the command buffer.
 *
 * @param cmd The command buffer to record to. (Ignored in the immediate-mode OpenGL backend).
 * @param display_id The ID of the target. Use -1 for the main window/swapchain.
 * @param clear_color The color to clear the target with.
 */
SITAPI SituationError SituationCmdBeginRenderToDisplay(SituationCommandBuffer cmd, int display_id, ColorRGBA clear_color) {
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "CmdBeginRenderToDisplay");
        return SITUATION_ERROR_NOT_INITIALIZED;
    }

#if defined(SITUATION_USE_OPENGL)
    (void)cmd;

    if (display_id < 0) {
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
        glViewport(0, 0, sit_gs.main_window_width, sit_gs.main_window_height);
    } else {
        if (display_id >= SITUATION_MAX_VIRTUAL_DISPLAYS || !sit_gs.virtual_display_slots_used[display_id]) {
            _SituationSetErrorFromCode(SITUATION_ERROR_VIRTUAL_DISPLAY_INVALID_ID, "CmdBeginRenderToDisplay");
            return SITUATION_ERROR_VIRTUAL_DISPLAY_INVALID_ID;
        }
        SituationVirtualDisplay* vd = &sit_gs.virtual_display_slots[display_id];
        glBindFramebuffer(GL_FRAMEBUFFER, vd->gl.fbo_id);
        glViewport(0, 0, (GLsizei)vd->resolution[0], (GLsizei)vd->resolution[1]);
    }

    glClearColor(clear_color.r / 255.0f, clear_color.g / 255.0f, clear_color.b / 255.0f, clear_color.a / 255.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glEnable(GL_DEPTH_TEST);

#elif defined(SITUATION_USE_VULKAN)
    VkRenderPassBeginInfo render_pass_info = {};
    render_pass_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;

    VkClearValue clear_values[2];
    clear_values[0].color = (VkClearColorValue){{clear_color.r / 255.0f, clear_color.g / 255.0f, clear_color.b / 255.0f, clear_color.a / 255.0f}};
    clear_values[1].depthStencil = (VkClearDepthStencilValue){1.0f, 0};

    render_pass_info.clearValueCount = 2;
    render_pass_info.pClearValues = clear_values;

    if (display_id < 0) {
        render_pass_info.renderPass = sit_gs.vk.main_window_render_pass;
        render_pass_info.framebuffer = sit_gs.vk.main_window_framebuffers[sit_gs.vk.current_image_index];
        render_pass_info.renderArea.offset = (VkOffset2D){0, 0};
        render_pass_info.renderArea.extent = sit_gs.vk.swapchain_extent;
    } else {
        if (display_id >= SITUATION_MAX_VIRTUAL_DISPLAYS || !sit_gs.virtual_display_slots_used[display_id]) {
            _SituationSetErrorFromCode(SITUATION_ERROR_VIRTUAL_DISPLAY_INVALID_ID, "CmdBeginRenderToDisplay");
            return SITUATION_ERROR_VIRTUAL_DISPLAY_INVALID_ID;
        }
        SituationVirtualDisplay* vd = &sit_gs.virtual_display_slots[display_id];
        render_pass_info.renderPass = vd->vk.render_pass;
        render_pass_info.framebuffer = vd->vk.framebuffer;
        render_pass_info.renderArea.offset = (VkOffset2D){0, 0};
        render_pass_info.renderArea.extent = (VkExtent2D){(uint32_t)vd->resolution[0], (uint32_t)vd->resolution[1]};
    }
    
    vkCmdBeginRenderPass((VkCommandBuffer)cmd, &render_pass_info, VK_SUBPASS_CONTENTS_INLINE);
#endif
}

/**
 * @brief Ends the current render pass.
 *
 * @details This function signals the end of a rendering phase that was started with `SituationCmdBeginRenderToDisplay`. It performs backend-specific cleanup to finalize the rendering commands recorded for the current target.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Unbinds the currently bound Framebuffer Object (FBO), returning rendering control to the main window's default framebuffer (backbuffer).
 *   It also resets some common OpenGL state to default values:
 *   - Unbinds the current shader program (`glUseProgram(0)`).
 *   - Unbinds the current Vertex Array Object (`glBindVertexArray(0)`).
 *   - Re-enables `GL_BLEND` and sets the blend function to `SRC_ALPHA/ONE_MINUS_SRC_ALPHA`.
 *   - Re-enables `GL_DEPTH_TEST` and sets the depth function to `GL_LESS`.
 *   These state resets aim to provide a predictable state for subsequent rendering commands directed at the main window, but may interfere with custom state management. The command buffer parameter `cmd` is ignored.
 * - **Vulkan:** Formally ends the `VkRenderPass` that was begun by `SituationCmdBeginRenderToDisplay` by recording a `vkCmdEndRenderPass` command into the provided command buffer. This requires the command buffer to be in the recording state and inside a render pass.
 *
 * @param cmd The command buffer the pass was recorded on (Vulkan) or ignored (OpenGL).
 *
 * @return SITUATION_SUCCESS on successful ending of the render pass.
 * @return SITUATION_ERROR_NOT_INITIALIZED if the library is not initialized.
 * @return SITUATION_ERROR_INVALID_PARAM (Vulkan) if the provided command buffer handle is invalid.
 * @return SITUATION_ERROR_OPENGL_GENERAL (OpenGL) if an OpenGL error occurs
 *         during state changes (e.g., context issues).
 *
 * @note It is the caller's responsibility to ensure that:
 *       1. A render pass was successfully begun before calling this function.
 *       2. (Vulkan) The command buffer `cmd` is valid and in the recording state within the corresponding render pass.
 * @warning The OpenGL implementation includes state resets that might override application-managed state. Review the documentation for specific resets.
 */
SITAPI SituationError SituationCmdEndRender(SituationCommandBuffer cmd) {
    // --- 1. Input Validation ---
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "CmdEndRender");
        return SITUATION_ERROR_NOT_INITIALIZED;
    }

#if defined(SITUATION_USE_OPENGL)
    {
        (void)cmd; // OpenGL uses global state, command buffer not needed for this call.

        // --- 2. OpenGL End Render Pass & State Reset ---
        // Unbind any custom FBO, return to default framebuffer.
        glBindFramebuffer(GL_FRAMEBUFFER, 0);

        // --- State Resets (as per original snippet, noted as potentially intrusive) ---
        // Unbind current shader program.
        glUseProgram(0);
        // Unbind current VAO.
        glBindVertexArray(0);
        // Reset common blending state.
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        // Reset common depth test state.
        glEnable(GL_DEPTH_TEST);
        glDepthFunc(GL_LESS);
        // --- End State Resets ---

        // --- 3. OpenGL Error Checking ---
        SIT_CHECK_GL_ERROR();
        if (sit_gs.gl.last_error != GL_NO_ERROR) {
            // Error message likely set by SIT_CHECK_GL_ERROR
            return SITUATION_ERROR_OPENGL_GENERAL; // Or a more specific error if possible
        }

        return SITUATION_SUCCESS;
    }

#elif defined(SITUATION_USE_VULKAN)
    {
        // --- 2. Vulkan Input Validation ---
        if (cmd == 0 || (VkCommandBuffer)cmd == VK_NULL_HANDLE) {
            _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Invalid command buffer for ending render pass.");
            return SITUATION_ERROR_INVALID_PARAM;
        }
        VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;

        // --- 3. Vulkan End Render Pass ---
        // Formally end the VkRenderPass begun by SituationCmdBeginRenderToDisplay.
        vkCmdEndRenderPass(vk_cmd);

        // Note: vkCmdEndRenderPass itself doesn't return VkResult.
        // Errors would be validation layer reports or occur during command buffer submission.

        return SITUATION_SUCCESS;
    }
#endif

    // Should not be reached, but included for completeness.
    return SITUATION_ERROR_NOT_IMPLEMENTED;
}

/**
 * @brief Sets the viewport and scissor rectangle for subsequent drawing commands.
 *
 * @details The viewport defines the rectangular area of the current render target that primitives will be rasterized to. The coordinates are in framebuffer/pixel space.
 *          In Vulkan, this function also sets the scissor rectangle to match the viewport dimensions, enforcing that rendering is clipped to this area. In OpenGL, the scissor test is not modified by this function; use `SituationCmdSetScissor` if explicit scissor control is needed.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Calls `glViewport` to set the viewport transformation.
 *   The command buffer parameter `cmd` is ignored as OpenGL uses global state.
 *   Note that OpenGL does not implicitly change the scissor state.
 * - **Vulkan:** Records `vkCmdSetViewport` and `vkCmdSetScissor` commands into the provided command buffer. Both the viewport and scissor are set to the specified rectangle.
 *   This requires the command buffer to be in the recording state and the bound graphics pipeline to have been created with `VK_DYNAMIC_STATE_VIEWPORT` and `VK_DYNAMIC_STATE_SCISSOR` enabled.
 *
 * @param cmd The command buffer into which the commands will be recorded (Vulkan)
 *            or ignored (OpenGL).
 * @param x The top-left x-coordinate of the viewport/scissor (in pixels).
 * @param y The top-left y-coordinate of the viewport/scissor (in pixels).
 *         Note: In Vulkan, the Y axis origin is typically the top-left.
 *         In OpenGL, it's the bottom-left, but `glViewport` handles this.
 * @param width The width of the viewport/scissor (in pixels). Must be positive.
 * @param height The height of the viewport/scissor (in pixels). Must be positive.
 *
 * @note It is the caller's responsibility to ensure that:
 *       1. (Vulkan) The command buffer `cmd` is valid and in the recording state.
 *       2. (Vulkan) The bound graphics pipeline supports dynamic viewport and scissor.
 *       3. The specified `width` and `height` are greater than zero.
 * @warning Providing a `width` or `height` of zero or negative values results in undefined behavior or errors, depending on the backend and driver.
 */
SITAPI void SituationCmdSetViewport(SituationCommandBuffer cmd, float x, float y, float width, float height) {
    // --- 1. Input Validation ---
    if (!sit_gs.is_initialized) {
        // Silently return if not initialized, consistent with snippet behavior.
        // Alternatively, could set an error: _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "...");
        return;
    }

    // While viewport dimensions *can* technically be negative in OpenGL spec,
    // it's highly unusual and often indicates an error.
    // Width and Height should almost always be positive.
    if (width <= 0.0f || height <= 0.0f) {
        // Even though function is void, setting an error state can be useful for debugging.
        char error_msg[128];
        snprintf(error_msg, sizeof(error_msg),
                 "Invalid viewport dimensions: width=%.2f, height=%.2f. Dimensions must be positive.", width, height);
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, error_msg);
        return;
    }

#if defined(SITUATION_USE_OPENGL)
    {
        (void)cmd; // OpenGL uses global state, command buffer not needed.

        // --- 2. OpenGL Implementation ---
        // Note: glViewport expects integer parameters for x,y,width,height.
        // Casting float to int truncates towards zero.
        // If precise sub-pixel viewport placement is needed, more care is required.
        glViewport((GLint)x, (GLint)y, (GLsizei)width, (GLsizei)height);
        // glViewport itself rarely generates errors for these inputs according to spec,
        // but invalid context state might.
        SIT_CHECK_GL_ERROR();
        // Note: SIT_CHECK_GL_ERROR sets global error state, but function remains void.
    }

#elif defined(SITUATION_USE_VULKAN)
    {
        // --- 2. Vulkan Input Validation ---
        if (cmd == 0 || (VkCommandBuffer)cmd == VK_NULL_HANDLE) {
            _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Invalid command buffer for setting viewport.");
            return; // Even though void, we can return early on critical error.
        }
        VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;

        // --- 3. Vulkan Implementation ---
        // Define the VkViewport structure.
        VkViewport viewport = {0}; // Explicitly zero-initialize padding
        viewport.x = x;
        viewport.y = y; // Vulkan Y=0 is top
        viewport.width = width;
        viewport.height = height;
        viewport.minDepth = 0.0f; // Standard near plane depth
        viewport.maxDepth = 1.0f; // Standard far plane depth

        // Record the command to set the viewport.
        // Assumes the pipeline has VK_DYNAMIC_STATE_VIEWPORT enabled.
        vkCmdSetViewport(vk_cmd, 0, 1, &viewport);

        // Define the VkRect2D structure for the scissor.
        // It's common practice to set scissor to match the viewport.
        VkRect2D scissor = {0}; // Explicitly zero-initialize
        scissor.offset.x = (int32_t)x;
        scissor.offset.y = (int32_t)y;
        // VkExtent2D uses uint32_t, so width/height are cast.
        // Negative width/height were checked earlier.
        scissor.extent.width = (uint32_t)width;
        scissor.extent.height = (uint32_t)height;

        // Record the command to set the scissor.
        // Assumes the pipeline has VK_DYNAMIC_STATE_SCISSOR enabled.
        vkCmdSetScissor(vk_cmd, 0, 1, &scissor);

        // Note: vkCmdSetViewport/vkCmdSetScissor don't return VkResult.
        // Errors are validation layer reports or submission issues.
    }
#endif
    // --- 4. Post-Operation ---
    // No general post-operation actions are required here.
}

/**
 * @brief Sets the dynamic scissor rectangle for the render target.
 * @details The scissor test is a hardware-level optimization that discards any pixel fragments outside of this defined rectangle, preventing the fragment shader from running on them. This should be called after binding a pipeline that was created with VK_DYNAMIC_STATE_SCISSOR enabled.
 * @param cmd The command buffer to record the command into.
 * @param x, y The top-left corner of the scissor rectangle, in pixel coordinates.
 * @param width, height The dimensions of the scissor rectangle, in pixels.
 */
SITAPI void SituationCmdSetScissor(SituationCommandBuffer cmd, int x, int y, int width, int height) {
    // Basic validation: A scissor rectangle cannot have a negative size.
    if (!sit_gs.is_initialized || width < 0 || height < 0) {
        return;
    }

#if defined(SITUATION_USE_OPENGL)
    // In OpenGL, scissor is a global state, so the command buffer is not used.
    (void)cmd;

    // OpenGL's glScissor applies the test to all subsequent drawing commands until changed.
    // It's a simple, direct mapping.
    glEnable(GL_SCISSOR_TEST);
    glScissor(x, y, width, height);

    // Check for errors, especially if the context is in a bad state.
    SIT_CHECK_GL_ERROR();

#elif defined(SITUATION_USE_VULKAN)
    // In Vulkan, this is a command recorded into the command buffer.

    // 1. Create the VkRect2D structure that Vulkan expects.
    VkRect2D scissor = {};
    scissor.offset.x = x;
    scissor.offset.y = y;
    scissor.extent.width = (uint32_t)width;
    scissor.extent.height = (uint32_t)height;

    // 2. Record the command.
    // vkCmdSetScissor takes an array of scissor rectangles. We are only setting the
    // first one (at index 0).
    vkCmdSetScissor((VkCommandBuffer)cmd, 0, 1, &scissor);

#endif
}

/**
 * @brief [Core] Binds a vertex buffer for subsequent draw calls.
 * @details Records a command to set the active vertex buffer. All subsequent draw calls will source their vertex data from this buffer, starting from binding point 0.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Binds the buffer to the `GL_ARRAY_BUFFER` target. This is associated with the globally active VAO, making it the source for vertex attributes.
 * - **Vulkan:** Records a `vkCmdBindVertexBuffers` command for binding point 0.
 *
 * @param cmd The command buffer to record the command into. (Ignored in OpenGL).
 * @param buffer The `SituationBuffer` handle of the vertex buffer to bind.
 */
SITAPI void SituationCmdBindVertexBuffer(SituationCommandBuffer cmd, SituationBuffer buffer) {
    if (!sit_gs.is_initialized || buffer.id == 0) { return; }

#if defined(SITUATION_USE_OPENGL)
    (void)cmd; // Ignore cmd for OpenGL
    if (buffer.gl_buffer_id == 0) {
        // Handle invalid buffer
        _SituationSetErrorFromCode(SITUATION_ERROR_RESOURCE_INVALID, "SituationCmdBindVertexBuffer: Invalid buffer provided.");
        return;
    }
    if (binding > some_reasonable_max_bindings) { // Define a reasonable limit
         _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "SituationCmdBindVertexBuffer: Binding index too high.");
         return;
    }
    // glVertexArrayVertexBuffer modifies the state of the VAO that is *currently bound*.
    // Because sit_gs.gl.global_vao_id is bound, this configures the user's VAO.
    glVertexArrayVertexBuffer(sit_gs.gl.global_vao_id, binding, buffer.gl_buffer_id, (GLintptr)offset, (GLsizei)stride);
    SIT_CHECK_GL_ERROR();
    // You might also store this binding info internally if needed for validation/debugging

#elif defined(SITUATION_USE_VULKAN)
    VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;
    if (vk_cmd == VK_NULL_HANDLE) return;

    VkBuffer vertex_buffers[] = { buffer.vk_buffer };
    VkDeviceSize offsets[] = { 0 };
    // Bind the buffer to the first vertex input binding point (index 0).
    vkCmdBindVertexBuffers(vk_cmd, 0, 1, vertex_buffers, offsets);
#endif
}

/**
 * @brief [Core] Binds an index buffer for subsequent indexed draw calls.
 * @details Records a command to set the active index buffer. Subsequent indexed draw calls (`SituationCmdDrawIndexed`) will use this buffer.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Binds the buffer to the `GL_ELEMENT_ARRAY_BUFFER` target, associating it with the globally active VAO.
 * - **Vulkan:** Records a `vkCmdBindIndexBuffer` command. Assumes 32-bit unsigned integer indices.
 *
 * @param cmd The command buffer to record the command into. (Ignored in OpenGL).
 * @param buffer The `SituationBuffer` handle of the index buffer to bind.
 */
SITAPI void SituationCmdBindIndexBuffer(SituationCommandBuffer cmd, SituationBuffer buffer) {
    if (!sit_gs.is_initialized || buffer.id == 0) {
        return;
    }

#if defined(SITUATION_USE_OPENGL)
    (void)cmd;
    // Binds the buffer to the GL_ELEMENT_ARRAY_BUFFER target of the global VAO.
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buffer.gl_buffer_id);
    SIT_CHECK_GL_ERROR();

#elif defined(SITUATION_USE_VULKAN)
    VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;
    if (vk_cmd == VK_NULL_HANDLE) return;

    // Bind the buffer for indexed drawing, specifying 32-bit unsigned integers as the index type.
    vkCmdBindIndexBuffer(vk_cmd, buffer.vk_buffer, 0, VK_INDEX_TYPE_UINT32);
#endif
}

/**
 * @brief Binds a texture as a storage image to a specific binding point for a compute shader.
 * @details This function is used to make a texture available for reading and writing (via imageLoad/imageStore in GLSL) within a compute shader.
 * @param cmd The command buffer to record the command into.
 * @param binding The binding point index within the compute shader's descriptor set.
 * @param texture The SituationTexture to bind. It must have been created with the SITUATION_TEXTURE_USAGE_STORAGE flag.
 */
SITAPI SituationError SituationCmdBindComputeTexture(SituationCommandBuffer cmd, uint32_t binding, SituationTexture texture) {
    if (!sit_gs.is_initialized) return SITUATION_ERROR_NOT_INITIALIZED;
    if (texture.id == 0) return SITUATION_ERROR_RESOURCE_INVALID;

#if defined(SITUATION_USE_OPENGL)
    // The format must be specified for image load/store. Assuming RGBA8.
    glBindImageTexture(binding, texture.gl_texture_id, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA8);
    SIT_CHECK_GL_ERROR();
    return SITUATION_SUCCESS;

#elif defined(SITUATION_USE_VULKAN)
    if (cmd == 0 || (VkCommandBuffer)cmd == VK_NULL_HANDLE) return SITUATION_ERROR_INVALID_PARAM;
    if (texture.descriptor_set == VK_NULL_HANDLE) {
        _SituationSetErrorFromCode(SITUATION_ERROR_RESOURCE_INVALID, "Texture is missing its persistent descriptor set.");
        return SITUATION_ERROR_RESOURCE_INVALID;
    }

    // Bind the pre-cached descriptor set.
    // NOTE/BUG: The 'binding' parameter is intended to be the binding point within a set,
    // but the current architecture pre-caches descriptor sets with a fixed binding of 0.
    // This function is temporarily corrected to assume resources are in set 0, but a
    // larger refactor of descriptor set management is needed to correctly use the 'binding' parameter.
    vkCmdBindDescriptorSets(
        (VkCommandBuffer)cmd,
        VK_PIPELINE_BIND_POINT_COMPUTE, // Bind for compute pipeline
        sit_gs.vk.current_compute_pipeline_layout,
        0,  // Assume compute resources are in set 0.
        1,
        &texture.descriptor_set, // Use the pre-cached set from the texture struct.
        0, NULL
    );
    return SITUATION_SUCCESS;
#endif
}

/**
 * @brief [Core] Records a non-indexed drawing command.
 * @details Renders primitives sequentially from the currently bound vertex buffer.
 *
 * @param cmd The command buffer to record the command into.
 * @param vertex_count The number of vertices to draw.
 * @param instance_count The number of instances to draw (for instanced rendering).
 * @param first_vertex The index of the first vertex to draw.
 * @param first_instance The instance ID of the first instance to draw.
 */
SITAPI void SituationCmdDraw(SituationCommandBuffer cmd, uint32_t vertex_count, uint32_t instance_count, uint32_t first_vertex, uint32_t first_instance) {
    if (!sit_gs.is_initialized || vertex_count == 0 || instance_count == 0) {
        return;
    }

#if defined(SITUATION_USE_OPENGL)
    (void)cmd;
    glDrawArraysInstanced(GL_TRIANGLES, first_vertex, vertex_count, instance_count);
    SIT_CHECK_GL_ERROR();

#elif defined(SITUATION_USE_VULKAN)
    VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;
    if (vk_cmd == VK_NULL_HANDLE) return;
    vkCmdDraw(vk_cmd, vertex_count, instance_count, first_vertex, first_instance);
#endif
}

/**
 * @brief [Core] Records an indexed drawing command.
 * @details Renders primitives using indices from the currently bound index buffer to look up vertices from the currently bound vertex buffer.
 *
 * @param cmd The command buffer to record the command into.
 * @param index_count The number of indices to draw.
 * @param instance_count The number of instances to draw (for instanced rendering).
 * @param first_index The offset into the index buffer to start reading indices from.
 * @param vertex_offset A value added to each index before looking up a vertex.
 * @param first_instance The instance ID of the first instance to draw.
 */
SITAPI void SituationCmdDrawIndexed(SituationCommandBuffer cmd, uint32_t index_count, uint32_t instance_count, uint32_t first_index, int32_t vertex_offset, uint32_t first_instance) {
    if (!sit_gs.is_initialized || index_count == 0 || instance_count == 0) {
        return;
    }

#if defined(SITUATION_USE_OPENGL)
    (void)cmd;
    // glDrawElementsBaseVertex uses the *currently bound* VAO (global_vao_id).
    // It also uses the currently bound index buffer from that VAO.
    glDrawElementsInstancedBaseVertexBaseInstance(GL_TRIANGLES, index_count, GL_UNSIGNED_INT, (void*)(first_index * sizeof(uint32_t)), instance_count, vertex_offset, first_instance);
    SIT_CHECK_GL_ERROR();
    return SITUATION_SUCCESS; // Or appropriate error code if SIT_CHECK_GL_ERROR detected something

#elif defined(SITUATION_USE_VULKAN)
    VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;
    if (vk_cmd == VK_NULL_HANDLE) return;
    vkCmdDrawIndexed(vk_cmd, index_count, instance_count, first_index, vertex_offset, first_instance);
#endif
}

// function to set vertex attribute format
SITAPI void SituationCmdSetVertexAttribute(SituationCommandBuffer cmd, uint32_t location, int size, SituationDataType type, bool normalized, size_t offset) {
#if defined(SITUATION_USE_OPENGL)
    (void)cmd;
    GLenum gl_type = _SituationMapDataTypeToGL(type); // You need this helper
    if (gl_type == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "SituationCmdSetVertexAttribute: Unsupported data type.");
        return;
    }
    // glVertexArrayAttribFormat modifies the state of the *currently bound* VAO.
    glVertexArrayAttribFormat(sit_gs.gl.global_vao_id, location, size, gl_type, normalized ? GL_TRUE : GL_FALSE, (GLuint)offset);
    SIT_CHECK_GL_ERROR();
    // You still need glVertexArrayAttribBinding to link the attrib to a buffer binding point
    // This example assumes attrib location == buffer binding index for simplicity.
    glVertexArrayAttribBinding(sit_gs.gl.global_vao_id, location, location);
    SIT_CHECK_GL_ERROR();
    glEnableVertexArrayAttrib(sit_gs.gl.global_vao_id, location); // Enable the attribute
    SIT_CHECK_GL_ERROR();
#elif defined(SITUATION_USE_VULKAN)
    // ... Vulkan implementation (likely recorded into command buffer) ...
#endif
}

/**
 * @brief Binds a graphics pipeline (shader program) for subsequent drawing commands.
 *
 * @details This function activates the specified graphics pipeline, making its shader program (and associated fixed-function state, in Vulkan) active for subsequent draw calls recorded in the command buffer. Any previously bound graphics pipeline is replaced.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** This function is a wrapper around `glUseProgram`. It activates the shader program associated with the `SituationShader` handle. The command buffer parameter `cmd` is ignored as OpenGL uses global state.
 *               In debug builds (`NDEBUG` not defined), it validates the program ID using `glIsProgram` to catch potential errors early.
 * - **Vulkan:** Records a `vkCmdBindPipeline` command into the provided command buffer for the `VK_PIPELINE_BIND_POINT_GRAPHICS` bind point.
 *               It also updates the internal global state `sit_gs.vk.current_pipeline_layout_for_push_constants` with the pipeline's layout, which is essential for subsequent `SituationCmdSetPushConstant` and descriptor set binding operations.
 *
 * @param cmd The command buffer into which the bind command will be recorded (Vulkan) or ignored (OpenGL).
 * @param shader The `SituationShader` handle representing the graphics pipeline to bind.
 *
 * @return SITUATION_SUCCESS on successful binding of the pipeline.
 * @return SITUATION_ERROR_NOT_INITIALIZED if the library is not initialized.
 * @return SITUATION_ERROR_RESOURCE_INVALID if the shader handle is invalid (e.g., `id` is 0).
 * @return SITUATION_ERROR_INVALID_PARAM (OpenGL, Debug) if the shader's program ID is not a valid OpenGL name.
 * @return SITUATION_ERROR_INVALID_PARAM (Vulkan) if the provided command buffer handle is invalid.
 * @return SITUATION_ERROR_OPENGL_GENERAL (OpenGL) if an OpenGL error occurs during the `glUseProgram` call (e.g., program linking issues made runtime detectable, context problems).
 *
 * @note It is the caller's responsibility to ensure that:
 *       1. (Vulkan) The command buffer `cmd` is valid and in the recording state.
 *       2. The shader pipeline represented by `shader` was created successfully.
 */
SITAPI SituationError SituationCmdBindPipeline(SituationCommandBuffer cmd, SituationShader shader) {
    // --- 1. Input Validation ---
    if (!sit_gs.is_initialized) {
        return SITUATION_ERROR_NOT_INITIALIZED;
    }
    if (shader.id == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_RESOURCE_INVALID, "Attempted to bind an invalid shader handle.");
        return SITUATION_ERROR_RESOURCE_INVALID;
    }

#if defined(SITUATION_USE_OPENGL)
    {
        (void)cmd; // OpenGL uses global state, command buffer not needed for this call.

#ifndef NDEBUG
        // --- 2. OpenGL Debug Validation ---
        // In debug builds, verify the Program ID is valid before using it.
        if (!glIsProgram(shader.id)) {
            char detail[128];
            snprintf(detail, sizeof(detail), "Attempted to bind an invalid shader program (ID: %u)", shader.id);
            _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, detail);
            // SIT_CHECK_GL_ERROR(); // Can check for unrelated errors, but not necessary here.
            return SITUATION_ERROR_RESOURCE_INVALID; // Or SITUATION_ERROR_INVALID_PARAM
        }
#endif

        // --- 3. OpenGL Bind Execution ---
        glUseProgram(shader.id);

        // --- 4. OpenGL Error Checking ---
        SIT_CHECK_GL_ERROR();
        if (sit_gs.gl.last_error != GL_NO_ERROR) {
            // Error message likely set by SIT_CHECK_GL_ERROR
            return SITUATION_ERROR_OPENGL_GENERAL; // Or a more specific error if possible
        }

        return SITUATION_SUCCESS;
    }

#elif defined(SITUATION_USE_VULKAN)
    {
        // --- 2. Vulkan Input Validation ---
        if (cmd == 0 || (VkCommandBuffer)cmd == VK_NULL_HANDLE) {
            _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Invalid command buffer for binding graphics pipeline.");
            return SITUATION_ERROR_INVALID_PARAM;
        }
        VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;

        // --- 3. Vulkan Bind Execution ---
        // Record the command to bind the graphics pipeline.
        vkCmdBindPipeline(vk_cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, shader.vk_pipeline);

        // Update the global state so subsequent commands (Push Constants, Descriptor Sets)
        // know which pipeline layout to use.
        sit_gs.vk.current_pipeline_layout_for_push_constants = shader.vk_pipeline_layout;

        // Note: vkCmdBindPipeline itself doesn't return VkResult.
        // Errors would be validation layer reports or occur during command buffer submission.

        return SITUATION_SUCCESS;
    }
#endif

    // Should not be reached, but included for completeness.
    return SITUATION_ERROR_NOT_IMPLEMENTED;
}

/**
 * @brief Records a command to draw a mesh using the currently bound graphics pipeline.
 *
 * @details This function instructs the GPU to render the geometry defined by the provided `SituationMesh`. It requires that a graphics pipeline (shader, potentially state) has been previously bound using `SituationCmdBindPipeline`.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Binds the mesh's Vertex Array Object (VAO) using `glBindVertexArray`.
 *   The VAO encapsulates the vertex buffer, index buffer, and vertex attribute configurations. It then calls `glDrawElements` to render the indexed geometry.
 *   In debug builds (`NDEBUG` not defined), it validates the VAO ID using `glIsVertexArray` to catch potential errors early.
 * - **Vulkan:** Explicitly binds the mesh's `vertex_buffer` and `index_buffer` to the command buffer using `vkCmdBindVertexBuffers` and `vkCmdBindIndexBuffer`.
 *   It then records a `vkCmdDrawIndexed` command. This requires the command buffer to be in the recording state and a compatible graphics pipeline to be bound.
 *
 * @param cmd The command buffer into which the draw command will be recorded.
 *            In OpenGL, this parameter is typically ignored as it uses global state.
 * @param mesh The `SituationMesh` handle containing the geometry data (vertices, indices) to be drawn.
 *
 * @return SITUATION_SUCCESS on successful recording of the draw command.
 * @return SITUATION_ERROR_NOT_INITIALIZED if the library is not initialized.
 * @return SITUATION_ERROR_RESOURCE_INVALID if the mesh handle is invalid (e.g., `id` is 0) or if the mesh contains no indices (`index_count` is 0).
 * @return SITUATION_ERROR_INVALID_PARAM (OpenGL, Debug) if the mesh's VAO ID is not a valid OpenGL name.
 * @return SITUATION_ERROR_INVALID_PARAM (Vulkan) if the provided command buffer handle is invalid.
 * @return SITUATION_ERROR_OPENGL_GENERAL (OpenGL) if an OpenGL error occurs during the draw process (e.g., invalid VAO state, context issues).
 *
 * @note It is the caller's responsibility to ensure that:
 *       1. A compatible graphics pipeline is bound before calling this function.
 *       2. (Vulkan) The command buffer `cmd` is valid and in the recording state.
 *       3. The mesh data (vertex/index buffers) is valid and accessible by the GPU.
 */
SITAPI SituationError SituationCmdDrawMesh(SituationCommandBuffer cmd, SituationMesh mesh) {
    // --- 1. Input Validation ---
    if (!sit_gs.is_initialized) {
        return SITUATION_ERROR_NOT_INITIALIZED;
    }
    if (mesh.id == 0 || mesh.index_count == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_RESOURCE_INVALID, "Attempted to draw an invalid or empty mesh.");
        return SITUATION_ERROR_RESOURCE_INVALID;
    }

#if defined(SITUATION_USE_OPENGL)
    (void)cmd;
    if (mesh.id == 0) return SITUATION_ERROR_RESOURCE_INVALID;

    // 1. Bind the mesh's own private, pre-configured VAO.
    // This single call restores its VBO, EBO, and vertex attribute layout.
    glBindVertexArray(mesh.vao_id);

    // 2. Issue the draw call.
    glDrawElements(GL_TRIANGLES, mesh.index_count, GL_UNSIGNED_INT, (void*)0);

    // 3. Unbind the VAO to be tidy (optional but good practice).
    glBindVertexArray(0);
    
    SIT_CHECK_GL_ERROR();
    return SITUATION_SUCCESS;
#elif defined(SITUATION_USE_VULKAN)
    {
        // --- 2. Vulkan Input Validation ---
        if (cmd == 0 || (VkCommandBuffer)cmd == VK_NULL_HANDLE) {
            _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Invalid command buffer for drawing mesh.");
            return SITUATION_ERROR_INVALID_PARAM;
        }
        VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;

        // --- 3. Vulkan Draw Execution ---
        // 1. Bind the vertex buffer for this mesh to binding point 0.
        // Assumes the bound pipeline expects vertex data at binding 0.
        VkBuffer vertex_buffers[] = { mesh.vertex_buffer };
        VkDeviceSize offsets[] = { 0 };
        vkCmdBindVertexBuffers(vk_cmd, 0, 1, vertex_buffers, offsets);

        // 2. Bind the index buffer for this mesh.
        // Assumes 32-bit indices (uint32_t) as defined/used in SituationCreateMesh.
        vkCmdBindIndexBuffer(vk_cmd, mesh.index_buffer, 0, VK_INDEX_TYPE_UINT32);

        // 3. Record the indexed draw call.
        //   - indexCount:    How many indices to draw (mesh.index_count).
        //   - instanceCount: 1, for single draw (not instanced).
        //   - firstIndex:    0, start from the beginning of the index buffer.
        //   - vertexOffset:  0, no additional offset to vertex indices.
        //   - firstInstance: 0, starting instance ID for instanced rendering.
        vkCmdDrawIndexed(vk_cmd, mesh.index_count, 1, 0, 0, 0);

        // Note: vkCmd* functions don't return VkResult. Errors are typically
        // validation layer reports or occur during command buffer submission.

        return SITUATION_SUCCESS;
    }
#endif

    // Should not be reached, but included for completeness if neither backend is defined.
    return SITUATION_ERROR_NOT_IMPLEMENTED;
}

/**
 * @brief Draws a colored, transformed quad.
 * @details This is a high-level helper command that uses the library's internal quad renderer.
 *          It is intended for simple 2D or debug rendering.
 * @param cmd The command buffer. (Ignored in OpenGL).
 * @param model The 4x4 model matrix (position, rotation, scale) for the quad.
 * @param color The color of the quad as a normalized vec4 (r, g, b, a).
 */
SITAPI void SituationCmdDrawQuad(SituationCommandBuffer cmd, mat4 model, vec4 color) {
    if (!sit_gs.is_initialized) return;

#if defined(SITUATION_USE_OPENGL)
    (void)cmd; // Unused

    if (sit_gs.quad_shader_program == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Quad renderer not initialized");
        return;
    }

    glUseProgram(sit_gs.quad_shader_program);

    // CORRECT: Use the locations defined in the shader contract.
    glUniformMatrix4fv(SIT_UNIFORM_LOC_MODEL_MATRIX, 1, GL_FALSE, (const GLfloat*)model);
    glUniform4fv(SIT_UNIFORM_LOC_OBJECT_COLOR, 1, (const GLfloat*)color);

    glBindVertexArray(sit_gs.quad_vao);
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    glBindVertexArray(0);
    glUseProgram(0);
    
#elif defined(SITUATION_USE_VULKAN)
    VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;

    vkCmdBindPipeline(vk_cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, sit_gs.vk.quad_pipeline);

    VkBuffer vertex_buffers[] = { sit_gs.vk.quad_vertex_buffer };
    VkDeviceSize offsets[] = { 0 };
    vkCmdBindVertexBuffers(vk_cmd, 0, 1, vertex_buffers, offsets);

    struct {
        mat4 model;
        vec4 color;
    } push_data;
    glm_mat4_copy(model, push_data.model);
    glm_vec4_copy(color, push_data.color);

    vkCmdPushConstants(vk_cmd, sit_gs.vk.quad_pipeline_layout, VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0, sizeof(push_data), &push_data);
    vkCmdDraw(vk_cmd, 4, 1, 0, 0);
#endif
}

/**
 * @brief Sets a small amount of per-draw data (push constants) for the currently bound pipeline.
 *
 * @details This function provides an efficient way to send small, frequently changing data (e.g., transformation matrices, color vectors, material properties) to shaders. It replaces slower methods like individual `glUniform*` calls or updating UBOs for tiny data changes.
 *          The `contract_id` specifies the location/offset within the shader's defined push constant block.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Uses `glProgramUniform*` functions as a direct and efficient equivalent.
 *               It queries the currently bound program (`glGetCurrentProgram`) and updates the uniform  at the location specified by `contract_id`. Supported data types are limited to common cases (`mat4`, `vec4`, `vec3`, `vec2`, `float`, `int`) based on `size`. Other sizes will trigger an error message.
 * - **Vulkan:** Records a `vkCmdPushConstants` command into the provided command buffer.
 *   The data is written to the push constant block of the pipeline layout last bound via `vkCmdPushConstants` or assumed to be correctly set in `sit_gs.vk.current_pipeline_layout_for_push_constants`. The data is made available to all graphics shader stages (`VK_SHADER_STAGE_ALL_GRAPHICS`).
 *   The pipeline *must* have been created with a push constant range that includes the specified `contract_id` (offset) and `size`.
 *
 * @param cmd The command buffer for the current frame (Vulkan) or ignored (OpenGL).
 * @param contract_id The location/offset within the shader's push constant block.
 *                    In OpenGL, this corresponds to the `location` layout qualifier.
 *                    In Vulkan, this is the byte offset.
 * @param data A pointer to the raw data to send. Must not be NULL.
 * @param size The size of the data in bytes (e.g., `sizeof(mat4)`, `sizeof(vec4)`).
 *
 * @note It is the caller's responsibility to ensure that:
 *       1. A valid shader/pipeline is bound before calling this function.
 *       2. (Vulkan) The bound pipeline's layout includes a push constant range covering `contract_id` to `contract_id + size`.
 *       3. The `size` and `contract_id` match the shader's expectations.
 * @warning Calling this in OpenGL when no program is bound (`glUseProgram(0)`) will result in no action being taken.
 */
SITAPI void SituationCmdSetPushConstant(SituationCommandBuffer cmd, uint32_t contract_id, const void* data, size_t size) {
    // --- 1. Input Validation ---
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot set push constant.");
        return;
    }
    if (!data) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Push constant data pointer is NULL.");
        return;
    }
    if (size == 0) {
        // Setting 0 bytes is likely an error.
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Push constant size is 0.");
        return;
    }
    // Optionally, add a maximum size check based on API limits if known.

#if defined(SITUATION_USE_OPENGL)
    {
        (void)cmd; // OpenGL uses global state, command buffer not needed for this call.
        GLuint current_program = 0;
        glGetIntegerv(GL_CURRENT_PROGRAM, (GLint*)&current_program);
        if (current_program == 0) {
            // No program is bound. This is not necessarily an error, but worth noting.
            // The call will be a no-op, which is valid OpenGL behavior.
            // Optionally log this in debug builds.
            // fprintf(stderr, "WARNING: SituationCmdSetPushConstant called with no program bound (glUseProgram(0)).\n");
            return;
        }

        // --- 2. OpenGL Implementation (glProgramUniform*) ---
        // Determine the correct glUniform* function based on size.
        // This is a simplified mapping for common types.
        GLenum error_code = GL_NO_ERROR;
        if (size == sizeof(mat4)) {
            glProgramUniformMatrix4fv(current_program, (GLint)contract_id, 1, GL_FALSE, (const GLfloat*)data);
        } else if (size == sizeof(vec4)) {
            glProgramUniform4fv(current_program, (GLint)contract_id, 1, (const GLfloat*)data);
        } else if (size == sizeof(vec3)) { // Add vec3 support
            glProgramUniform3fv(current_program, (GLint)contract_id, 1, (const GLfloat*)data);
        } else if (size == sizeof(vec2)) { // Add vec2 support
            glProgramUniform2fv(current_program, (GLint)contract_id, 1, (const GLfloat*)data);
        } else if (size == sizeof(float)) {
            glProgramUniform1fv(current_program, (GLint)contract_id, 1, (const GLfloat*)data);
        } else if (size == sizeof(int)) {
            glProgramUniform1iv(current_program, (GLint)contract_id, 1, (const GLint*)data);
        } else {
            // Unsupported size/type. This is a potential logic error by the caller.
            char error_msg[256];
            snprintf(error_msg, sizeof(error_msg),
                     "Unsupported push constant size (%zu bytes) for contract_id %u in OpenGL path.",
                     size, contract_id);
            _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, error_msg);
            // Cannot proceed with glUniform call.
            return;
        }

        // Check for OpenGL errors after the call.
        SIT_CHECK_GL_ERROR();
        // Note: SIT_CHECK_GL_ERROR sets the global error state if glGetError() is not GL_NO_ERROR.
        // The function itself (SituationCmdSetPushConstant) remains void.
    }

#elif defined(SITUATION_USE_VULKAN)
    {
        // --- 2. Vulkan Input Validation ---
        if (cmd == 0 || (VkCommandBuffer)cmd == VK_NULL_HANDLE) {
            _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Invalid command buffer for push constant update.");
            return;
        }
        VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;

        // --- 3. Vulkan Implementation (vkCmdPushConstants) ---
        // Assumes sit_gs.vk.current_pipeline_layout_for_push_constants is valid and corresponds to the currently bound pipeline that uses these push constants.
        // Uses VK_SHADER_STAGE_ALL_GRAPHICS for broad compatibility, though specifying exact stages is more optimal.
        vkCmdPushConstants(
            vk_cmd,
            sit_gs.vk.current_pipeline_layout_for_push_constants, // Pipeline Layout
            VK_SHADER_STAGE_ALL_GRAPHICS,                         // Shader Stages (Consider making this more specific)
            contract_id,                                          // Offset
            (uint32_t)size,                                       // Size
            data                                                  // Data
        );
        // Note: vkCmdPushConstants itself doesn't return VkResult.
        // Errors would be validation layer reports or device lost states during submission.
    }
#endif
    // --- 4. Post-Operation ---
    // No general post-operation actions are required here.
}

//==================================================================================
// --- [NEW UNIFIED API] Resource Binding ---
//==================================================================================

/**
 * @brief Binds a buffer's pre-packaged descriptor set to a specific set index in the currently bound pipeline.
 * @details This is the primary, unified function for making a GPU buffer's data (UBO or SSBO) available to a shader.
 *          It associates a `SituationBuffer` with a descriptor set slot declared in the shader code (e.g., `layout(set = X, binding = 0) uniform MyUBO` in GLSL).
 *
 * @par Backend-Specific Behavior & Performance
 * - **OpenGL:** Maps the `set_index` to an indexed binding point (`GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`) and calls `glBindBufferBase`. This is a direct and efficient binding operation.
 * - **Vulkan:** This function leverages the library's high-performance persistent descriptor set model. When the `SituationBuffer` was created, a dedicated `VkDescriptorSet` was allocated and populated for it.
 *               This function records a fast `vkCmdBindDescriptorSets` command using this pre-cached set, avoiding any runtime allocation or update overhead.
 *
 * @param cmd The command buffer to record the command into. (Ignored in OpenGL).
 * @param set_index The descriptor set index in the pipeline layout to bind to. This must match the `set = X` value in the shader's layout qualifier.
 * @param buffer The `SituationBuffer` handle to bind.
 *
 * @return SITUATION_SUCCESS on successful binding.
 * @return SITUATION_ERROR_RESOURCE_INVALID if the buffer handle is invalid or lacks the required internal resources.
 * @return SITUATION_ERROR_RENDER_COMMAND_FAILED if no pipeline is currently bound.
 *
 * @see SituationCreateBuffer(), SituationCmdBindTextureSet()
 */
SITAPI SituationError SituationCmdBindDescriptorSet(SituationCommandBuffer cmd, uint32_t set_index, SituationBuffer buffer) {
    if (!sit_gs.is_initialized) {
        // No error message set here as this is a common check.
        return SITUATION_ERROR_NOT_INITIALIZED;
    }
    if (buffer.id == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_RESOURCE_INVALID, "Attempted to bind an invalid buffer handle.");
        return SITUATION_ERROR_RESOURCE_INVALID;
    }

#if defined(SITUATION_USE_OPENGL)
    (void)cmd; // Command buffer is unused in OpenGL for this operation.
    GLenum target;
    
    // Determine the correct buffer target based on the usage flags it was created with.
    // This requires that the usage flags are stored in the buffer handle.
    if (buffer.abstract_usage_flags & SITUATION_BUFFER_USAGE_STORAGE_BUFFER) {
        target = GL_SHADER_STORAGE_BUFFER;
    } else {
        // Default to uniform buffer if not explicitly a storage buffer.
        target = GL_UNIFORM_BUFFER;
    }
    
    // In OpenGL, the descriptor set index maps directly to an indexed binding point.
    glBindBufferBase(target, set_index, buffer.gl_buffer_id);
    SIT_CHECK_GL_ERROR();
    
    return SITUATION_SUCCESS;

#elif defined(SITUATION_USE_VULKAN)
    VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;
    if (vk_cmd == VK_NULL_HANDLE) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Invalid command buffer for binding descriptor set.");
        return SITUATION_ERROR_INVALID_PARAM;
    }
    if (buffer.descriptor_set == VK_NULL_HANDLE) {
        _SituationSetErrorFromCode(SITUATION_ERROR_RESOURCE_INVALID, "Buffer is missing its pre-cached descriptor set. Was it created with UBO/SSBO usage flags?");
        return SITUATION_ERROR_RESOURCE_INVALID;
    }

    // Determine which pipeline (graphics or compute) is currently active to get the correct layout.
    VkPipelineBindPoint bind_point;
    VkPipelineLayout layout;

    if (sit_gs.vk.current_compute_pipeline_layout != VK_NULL_HANDLE) {
        bind_point = VK_PIPELINE_BIND_POINT_COMPUTE;
        layout = sit_gs.vk.current_compute_pipeline_layout;
    } else if (sit_gs.vk.current_pipeline_layout_for_push_constants != VK_NULL_HANDLE) {
        bind_point = VK_PIPELINE_BIND_POINT_GRAPHICS;
        layout = sit_gs.vk.current_pipeline_layout_for_push_constants;
    } else {
        _SituationSetErrorFromCode(SITUATION_ERROR_RENDER_COMMAND_FAILED, "Cannot bind descriptor set; no pipeline is currently bound.");
        return SITUATION_ERROR_RENDER_COMMAND_FAILED;
    }

    // Record the command to bind the buffer's pre-packaged descriptor set.
    vkCmdBindDescriptorSets(vk_cmd, bind_point, layout, set_index, 1, &buffer.descriptor_set, 0, NULL);
    
    return SITUATION_SUCCESS;
#endif
}

/**
 * @brief Binds a texture's pre-packaged descriptor set to a specific set index in the currently bound pipeline.
 * @details This is the primary, unified function for making a texture available for sampling or image load/store operations in a shader. It associates a `SituationTexture` with a descriptor set slot declared in the shader code (e.g., `layout(set = X, binding = 0) uniform sampler2D myTexture`).
 *
 * @par Backend-Specific Behavior & Performance
 * - **OpenGL:** Maps the `set_index` to a texture unit and calls `glBindTextureUnit`.
 * - **Vulkan:** Uses the texture's pre-cached, persistent `VkDescriptorSet` to record a fast `vkCmdBindDescriptorSets` command, avoiding runtime overhead.
 *
 * @param cmd The command buffer to record the command into. (Ignored in OpenGL).
 * @param set_index The descriptor set index in the pipeline layout to bind to.
 * @param texture The `SituationTexture` handle to bind.
 *
 * @return SITUATION_SUCCESS on successful binding.
 * @return SITUATION_ERROR_RESOURCE_INVALID if the texture handle is invalid.
 *
 * @see SituationCreateTexture(), SituationCmdBindDescriptorSet()
 */
SITAPI SituationError SituationCmdBindTextureSet(SituationCommandBuffer cmd, uint32_t set_index, SituationTexture texture) {
    if (!sit_gs.is_initialized) return SITUATION_ERROR_NOT_INITIALIZED;
    if (texture.id == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_RESOURCE_INVALID, "Attempted to bind an invalid texture handle.");
        return SITUATION_ERROR_RESOURCE_INVALID;
    }

#if defined(SITUATION_USE_OPENGL)
    (void)cmd;
    // In OpenGL, the descriptor set index maps to the texture image unit.
    glBindTextureUnit(set_index, texture.gl_texture_id);
    SIT_CHECK_GL_ERROR();
    return SITUATION_SUCCESS;

#elif defined(SITUATION_USE_VULKAN)
    VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;
    if (vk_cmd == VK_NULL_HANDLE) return SITUATION_ERROR_INVALID_PARAM;
    if (texture.descriptor_set == VK_NULL_HANDLE) {
        _SituationSetErrorFromCode(SITUATION_ERROR_RESOURCE_INVALID, "Texture is missing its pre-cached descriptor set.");
        return SITUATION_ERROR_RESOURCE_INVALID;
    }
    
    // Determine the active pipeline (graphics or compute).
    VkPipelineBindPoint bind_point;
    VkPipelineLayout layout;
    if (sit_gs.vk.current_compute_pipeline_layout != VK_NULL_HANDLE) {
        bind_point = VK_PIPELINE_BIND_POINT_COMPUTE;
        layout = sit_gs.vk.current_compute_pipeline_layout;
    } else if (sit_gs.vk.current_pipeline_layout_for_push_constants != VK_NULL_HANDLE) {
        bind_point = VK_PIPELINE_BIND_POINT_GRAPHICS;
        layout = sit_gs.vk.current_pipeline_layout_for_push_constants;
    } else {
        _SituationSetErrorFromCode(SITUATION_ERROR_RENDER_COMMAND_FAILED, "Cannot bind texture set; no pipeline is currently bound.");
        return SITUATION_ERROR_RENDER_COMMAND_FAILED;
    }

    // Record the command to bind the texture's pre-packaged descriptor set.
    vkCmdBindDescriptorSets(vk_cmd, bind_point, layout, set_index, 1, &texture.descriptor_set, 0, NULL);

    return SITUATION_SUCCESS;
#endif
}

/**
 * @brief Binds a GPU buffer (typically a UBO) for use by the currently bound graphics pipeline.
 * @details Associates a `SituationBuffer` with a uniform block declared in the vertex or fragment shader code (e.g., `layout(location = X) uniform ...` in OpenGL, or `layout(set = ..., binding = X) uniform ...` in Vulkan/GLSL).
 *          This allows the shader to access the buffer's uniform data (e.g., view/projection matrices).
 *
 * @par Backend-Specific Behavior & Performance
 * - **OpenGL:** Calls `glBindBufferBase(GL_UNIFORM_BUFFER, contract_id, buffer.gl_buffer_id)`.
 *   This efficiently binds the buffer to the specified uniform block binding point.
 * - **Vulkan:** This function also implements the high-performance, persistent descriptor set model.
 *   When the `SituationBuffer` was created (via `SituationCreateBuffer`), the Vulkan backend allocated a `VkDescriptorSet` (specifically for UBOs) and populated it with the buffer's `VkBuffer` handle. This function records a
 *  `vkCmdBindDescriptorSets` command using this pre-cached descriptor set from `buffer.descriptor_set`, ensuring a very fast operation.
 *
 * @param cmd The command buffer into which the bind command will be recorded (Vulkan) or ignored (OpenGL).
 * @param contract_id The binding point ID within the shader.
 *                    In OpenGL, this corresponds directly to the `location` or binding index specified in the shader (e.g., `glUniformBlockBinding` or `layout(location=X)`).
 *                    In Vulkan, this corresponds to the `dstBinding` used when the buffer's internal descriptor set was populated.
 * @param buffer The `SituationBuffer` handle to bind. The buffer should have been created with usage flags indicating it will be used as a uniform buffer (e.g., `SITUATION_BUFFER_USAGE_UNIFORM_BUFFER`).
 *
 * @return SITUATION_SUCCESS on successful recording of the bind command.
 * @return SITUATION_ERROR_NOT_INITIALIZED if the library is not initialized.
 * @return SITUATION_ERROR_RESOURCE_INVALID if the buffer handle is invalid (e.g., `id` is 0).
 * @return SITUATION_ERROR_INVALID_PARAM (Vulkan) if the provided command buffer handle is invalid.
 * @return SITUATION_ERROR_RESOURCE_INVALID (Vulkan) if the buffer's internal pre-cached descriptor set is invalid or missing.
 *
 * @note It is the caller's responsibility to ensure that:
 *       1. A compatible graphics pipeline is bound before calling this function.
 *       2. (Vulkan) The command buffer `cmd` is valid and in the recording state.
 *       3. The `contract_id` matches the binding point defined in the shader.
 * @warning Binding a buffer that was not created with appropriate usage flags (like `SITUATION_BUFFER_USAGE_UNIFORM_BUFFER`) may lead to undefined behavior.
 */
SITAPI SituationError SituationCmdBindUniformBuffer(SituationCommandBuffer cmd, uint32_t binding, SituationBuffer buffer) {
    // The old 'binding' parameter directly maps to the new 'set_index' parameter.
    return SituationCmdBindDescriptorSet(cmd, binding, buffer);
}

/**
 * @brief Binds a texture to a specific binding point for use by the currently bound pipeline.
 * @details Associates a `SituationTexture` with a sampler or image unit declared in the shader code (e.g., `layout(binding = X) uniform sampler2D ...`).
 *          This allows the shader to sample or read from the texture.
 *
 * @par Backend-Specific Behavior & Performance
 * - **OpenGL:** Calls `glBindTextureUnit(contract_id, texture.gl_texture_id)`.
 *   This efficiently binds the texture to the specified texture unit.
 * - **Vulkan:** This function leverages the persistent descriptor set model for textures.
 *   When the `SituationTexture` was created (e.g., via `SituationLoadTextureFromFile`), the Vulkan backend allocated a `VkDescriptorSet` (for combined image samplers) and
 *   populated it with the texture's `VkImageView` and `VkSampler`. This function records a `vkCmdBindDescriptorSets` command using this pre-cached descriptor set stored in `texture.descriptor_set`. This is a very fast operation, avoiding runtime allocation and updates of descriptor sets.
 *
 * @param cmd The command buffer into which the bind command will be recorded (Vulkan) or ignored (OpenGL).
 * @param contract_id The binding point ID within the shader.
 *                    In OpenGL, this corresponds to the texture unit index.
 *                    In Vulkan, this corresponds to the `dstBinding` used when the
 *                    texture's internal descriptor set was populated.
 * @param texture The `SituationTexture` handle to bind.
 *
 * @return SITUATION_SUCCESS on successful recording of the bind command.
 * @return SITUATION_ERROR_NOT_INITIALIZED if the library is not initialized.
 * @return SITUATION_ERROR_RESOURCE_INVALID if the texture handle is invalid (e.g., `id` is 0).
 * @return SITUATION_ERROR_INVALID_PARAM (Vulkan) if the provided command buffer handle is invalid.
 * @return SITUATION_ERROR_RESOURCE_INVALID (Vulkan) if the texture's internal pre-cached descriptor set is invalid or missing.
 *
 * @note It is the caller's responsibility to ensure that:
 *       1. A compatible pipeline is bound before calling this function.
 *       2. (Vulkan) The command buffer `cmd` is valid and in the recording state.
 *       3. The `contract_id` matches the binding point defined in the shader.
 */
SITAPI SituationError SituationCmdBindTexture(SituationCommandBuffer cmd, uint32_t set_index, SituationTexture texture) {
    // This function was already correctly named, so it's a simple wrapper.
    return SituationCmdBindTextureSet(cmd, set_index, texture);
}

/**
 * @brief Creates a GPU texture from image data in memory.
 *
 * @details This function uploads image data provided in a `SituationImage` struct to the GPU, creating a `SituationTexture` handle that can be used for rendering.
 *          It handles the necessary steps for both OpenGL and Vulkan, including memory allocation, data transfer, and (optionally) mipmap generation.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:**
 *   - Calls `glCreateTextures` to generate a texture name.
 *   - Uses `glTextureStorage2D` to allocate immutable storage for the texture, including space for mipmap levels if `generate_mipmaps` is true.
 *   - Uses `glTextureSubImage2D` to upload the base mipmap level (level 0) data from `image.data`.
 *   - If `generate_mipmaps` is true, calls `glGenerateTextureMipmap` to create the full mipmap chain on the GPU.
 * - **Vulkan:**
 *   - Creates a staging `VkBuffer` and uploads the `image.data` to it.
 *   - Creates the final `VkImage` with `VK_IMAGE_USAGE_TRANSFER_DST_BIT`, `VK_IMAGE_USAGE_SAMPLED_BIT`, and potentially `VK_IMAGE_USAGE_TRANSFER_SRC_BIT` (if mipmaps are generated).
 *   - Records and submits a command to copy the data from the staging buffer to the `VkImage`.
 *   - If `generate_mipmaps` is true, it generates the mipmap chain (e.g., using `vkCmdBlitImage`).
 *   - Creates a `VkImageView` for the image.
 *   - Creates a `VkSampler` with appropriate filtering (linear) and mipmap settings.
 *   - **Crucially:** Allocates a persistent `VkDescriptorSet` from a dedicated pool (`sit_gs.vk.persistent_descriptor_pool`) using a pre-created layout for combined image samplers (`sit_gs.vk.image_sampler_layout`).
 *   - Immediately populates this descriptor set with the newly created `imageView` and `sampler`.
 *   - Stores the `descriptor_set` handle within the returned `SituationTexture` struct.
 *     This cached set is used by `SituationCmdBindTexture` for fast binding.
 *
 * @param image A `SituationImage` struct containing the pixel data, width, and height.
 *              The `data` member must point to a valid block of memory containing `width * height * 4` bytes of RGBA data. The library takes ownership of allocating and freeing the `image.data` memory, but the caller must ensure the memory is valid for the duration of this function call.
 *              Use helper functions like `SituationLoadImage` to load image files into a `SituationImage`.
 * @param generate_mipmaps A boolean flag. If `true`, the function will generate a full mipmap chain for the texture, which is beneficial for rendering textures at various distances (reduces aliasing).
 *                         If `false`, only the base level (level 0) is created.
 *
 * @return A `SituationTexture` handle.
 *         - On success, `texture.id` will be a non-zero value unique to this texture.
 *           The texture is ready to be used with functions like `SituationCmdBindTexture`.
 *         - On failure, `texture.id` will be 0. Use `SituationGetLastErrorMsg()` to retrieve a detailed error message. Failure reasons can include invalid input image, memory allocation failure, or graphics API errors.
 *
 * @note The caller is responsible for eventually destroying the created texture using `SituationDestroyTexture()` to free the associated GPU resources and prevent memory leaks.
 * @note The input `image.data` is expected to be in RGBA format (8 bits per channel).
 * @note The created texture will use `GL_RGBA8` (OpenGL) or `VK_FORMAT_R8G8B8A8_SRGB` (Vulkan) format.
 * @warning This function must be called after the library has been successfully initialized with `SituationInit()`.
 * @warning The function may modify the internal state of the `image` struct during the upload process (e.g., temporary state changes for Vulkan staging), although the original `data`, `width`, and `height` should remain logically consistent from the caller's perspective for the duration of the call.
 *
 * @see SituationLoadTextureFromFile(), SituationDestroyTexture(), SituationCmdBindTexture(), SituationImage, SituationLoadImage()
 */
SITAPI SituationTexture SituationCreateTexture(SituationImage image, bool generate_mipmaps) {
    SituationTexture texture = {0};
    if (!SituationIsImageValid(image)) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Cannot create texture from invalid image.");
        return texture;
    }

    texture.width = image.width;
    texture.height = image.height;
    
#if defined(SITUATION_USE_OPENGL)
    glCreateTextures(GL_TEXTURE_2D, 1, &texture.gl_texture_id);
    SIT_CHECK_GL_ERROR(); // Check after object creation.

    // If the texture ID is 0 here, it means the context is likely invalid.
    if (texture.gl_texture_id == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_GENERAL, "glCreateTextures failed, context may be invalid.");
        return (SituationTexture){0};
    }

    int levels = 1;
    if (generate_mipmaps) {
        levels = (int)floor(log2(fmax(image.width, image.height))) + 1;
    }

    // Allocate immutable storage. This can fail if texture is too large.
    glTextureStorage2D(texture.gl_texture_id, levels, GL_RGBA8, image.width, image.height);
    SIT_CHECK_GL_ERROR();

    // Upload the base level pixel data.
    glTextureSubImage2D(texture.gl_texture_id, 0, 0, 0, image.width, image.height, GL_RGBA, GL_UNSIGNED_BYTE, image.data);
    SIT_CHECK_GL_ERROR();

    if (generate_mipmaps) {
        glGenerateTextureMipmap(texture.gl_texture_id);
        SIT_CHECK_GL_ERROR();
    }
    
    // Set texture parameters.
    glTextureParameteri(texture.gl_texture_id, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTextureParameteri(texture.gl_texture_id, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTextureParameteri(texture.gl_texture_id, GL_TEXTURE_MIN_FILTER, generate_mipmaps ? GL_LINEAR_MIPMAP_LINEAR : GL_LINEAR);
    glTextureParameteri(texture.gl_texture_id, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    SIT_CHECK_GL_ERROR();

    texture.id = texture.gl_texture_id;


#elif defined(SITUATION_USE_VULKAN)
    // --- Step 0: Calculate Mipmap Levels ---
    uint32_t mip_levels = 1;
    if (generate_mipmaps) {
        // Calculate the number of levels needed to go down to a 1x1 texture.
        mip_levels = (uint32_t)floor(log2(fmax(image.width, image.height))) + 1;
    }

    VkDeviceSize image_size = (VkDeviceSize)image.width * image.height * 4;
    VkBuffer staging_buffer;
    VmaAllocation staging_allocation;

    // --- Step 1: Create Staging Buffer and Upload Image Data ---
    // (This part is unchanged)
    if (_SituationVulkanCreateAndUploadBuffer(image.data, image_size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, &staging_buffer, &staging_allocation) != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED, "Failed to create staging buffer for texture.");
        return texture;
    }

    // --- Step 2: Create the Final GPU Image ---
    // The image must be created with the correct number of mip levels and usage flags that allow it to be both a source and destination for blit/transfer operations.
    VkImageUsageFlags vk_usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT;  // Needed for copying to it

    if (usage_flags & SITUATION_TEXTURE_USAGE_SAMPLED) {
        vk_usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
    }
    if (usage_flags & SITUATION_TEXTURE_USAGE_STORAGE) {
        vk_usage |= VK_IMAGE_USAGE_STORAGE_BIT;
    }
    if (usage_flags & SITUATION_TEXTURE_USAGE_COLOR_ATTACHMENT) {
        vk_usage |= VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
    }
    if (generate_mipmaps) {
        vk_usage |= VK_IMAGE_USAGE_TRANSFER_SRC_BIT; // Needed for blitting
    }
    
    // We need to create a new helper that can create an image with mip levels.
    // Let's assume _SituationVulkanCreateImage is modified to take mip_levels.
    if (_SituationVulkanCreateImage(image.width, image.height, mip_levels, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL,
                                  usage, VMA_MEMORY_USAGE_GPU_ONLY,
                                  &texture.image, &texture.allocation) != SITUATION_SUCCESS) {
        vmaDestroyBuffer(sit_gs.vk.vma_allocator, staging_buffer, staging_allocation);
        return texture;
    }

    // --- Step 3: Copy and Generate Mipmaps ---
    VkCommandBuffer command_buffer = _SituationVulkanBeginSingleTimeCommands();

    // a. Transition the entire image (all mip levels) to be ready for writing.
    _SituationVulkanTransitionImageLayout(command_buffer, texture.image, mip_levels, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);

    // b. Copy the staging buffer to the first mip level (level 0).
    _SituationVulkanCopyBufferToImage(command_buffer, staging_buffer, texture.image, (uint32_t)image.width, (uint32_t)image.height);
    
    // c. Generate the mipmaps by blitting from one level to the next.
    if (generate_mipmaps) {
        _SituationVulkanGenerateMipmaps(command_buffer, texture.image, image.width, image.height, mip_levels);
    } else {
        // If not generating mipmaps, we still need to transition the single level to be shader-readable.
        _SituationVulkanTransitionImageLayout(command_buffer, texture.image, 1, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);
    }
    
    _SituationVulkanEndSingleTimeCommands(command_buffer);

    // --- Step 4: Cleanup Staging Buffer ---
    vmaDestroyBuffer(sit_gs.vk.vma_allocator, staging_buffer, staging_allocation);

    // --- Step 5: Create Image View and Sampler ---
    // The image view must now be aware of all the mip levels.
    texture.image_view = _SituationVulkanCreateImageView(texture.image, VK_FORMAT_R8G8B8A8_SRGB, mip_levels, VK_IMAGE_ASPECT_COLOR_BIT);
    
    VkSamplerCreateInfo sampler_info = {};
    sampler_info.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    sampler_info.magFilter = VK_FILTER_LINEAR;
    sampler_info.minFilter = VK_FILTER_LINEAR;
    sampler_info.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    sampler_info.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    sampler_info.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    sampler_info.anisotropyEnable = VK_FALSE;
    sampler_info.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
    sampler_info.unnormalizedCoordinates = VK_FALSE;
    sampler_info.compareEnable = VK_FALSE;
    // CRITICAL: Set the mipmap mode and LOD bias for the sampler.
    sampler_info.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
    sampler_info.mipLodBias = 0.0f;
    sampler_info.minLod = 0.0f;
    sampler_info.maxLod = (float)mip_levels; // Use all available mip levels

    if (vkCreateSampler(sit_gs.vk.device, &sampler_info, NULL, &texture.sampler) != VK_SUCCESS) {
        // ... cleanup ...
        return (SituationTexture){0};
    }

    // --- Step 6: Create and Cache the Persistent Descriptor Set ---
    VkDescriptorSetAllocateInfo alloc_info = {};
    alloc_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    alloc_info.descriptorPool = sit_gs.vk.descriptor_pool;
    alloc_info.descriptorSetCount = 1;

    // Choose the correct layout and descriptor type based on primary usage
    VkDescriptorType descriptor_type;
    if (usage_flags & SITUATION_TEXTURE_USAGE_STORAGE) {
        alloc_info.pSetLayouts = &sit_gs.vk.storage_image_layout;
        descriptor_type = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
    } else { // Default to sampled
        alloc_info.pSetLayouts = &sit_gs.vk.image_sampler_layout;
        descriptor_type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    }

    if (vkAllocateDescriptorSets(sit_gs.vk.device, &alloc_info, &texture.descriptor_set) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED, "Failed to allocate persistent descriptor set for texture.");
        if (texture.sampler != VK_NULL_HANDLE) { vkDestroySampler(sit_gs.vk.device, texture.sampler, NULL); }
        if (texture.image_view != VK_NULL_HANDLE) { vkDestroyImageView(sit_gs.vk.device, texture.image_view, NULL); }
        //    (This handles both the VkImage and the VmaAllocation).
        if (texture.image != VK_NULL_HANDLE) { vmaDestroyImage(sit_gs.vk.vma_allocator, texture.image, texture.allocation); }
        // Note: The staging buffer was already destroyed earlier in the function, so we don't need to worry about it here.
        // Finally, return a zero-initialized (invalid) texture handle.
        return (SituationTexture){0};
    }

    VkDescriptorImageInfo image_info = {};
    // The layout for storage images is different. It's often GENERAL or TRANSFER_DST_OPTIMAL before the compute shader runs, and the shader itself might transition it.
    // For simplicity, let's assume it should be in GENERAL layout for read/write access.
    if (usage_flags & SITUATION_TEXTURE_USAGE_STORAGE) {
        image_info.imageLayout = VK_IMAGE_LAYOUT_GENERAL;
    } else {
        image_info.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    }
    image_info.imageView = texture.image_view;
    image_info.sampler = (descriptor_type == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER) ? texture.sampler : VK_NULL_HANDLE;

    VkWriteDescriptorSet write = {};
    write.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    write.dstSet = texture.descriptor_set;
    write.dstBinding = 0;
    write.dstArrayElement = 0;
    write.descriptorType = descriptor_type; // Use the chosen type
    write.descriptorCount = 1;
    write.pImageInfo = &image_info;

    vkUpdateDescriptorSets(sit_gs.vk.device, 1, &write, 0, NULL);
    
    // --- Final ---
    texture.id = (uint32_t)(uintptr_t)texture.image;
#endif

    // --- Resource Manager Hook ---
    if (texture.id != 0) {
        // We must check if an error occurred during the GL calls above.
        // If it did, we should not add it to the tracking list.
        if (strcmp(sit_gs.last_error_msg, "No error") == 0) {
            _SituationTextureNode* node = (_SituationTextureNode*)malloc(sizeof(_SituationTextureNode));
            if (node) {
                node->texture = texture;
                node->next = sit_gs.all_textures;
                sit_gs.all_textures = node;
            } else {
                _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Resource tracking node for texture");
                SituationDestroyTexture(&texture);
                return (SituationTexture){0};
            }
        } else {
             // An error was logged by SIT_CHECK_GL_ERROR.
             // Destroy the partially created GPU object and return an invalid handle.
             // We don't need to call the full SituationDestroyTexture here because the resource is not yet in the tracking list.
#if defined(SITUATION_USE_OPENGL)
             // --- This is now correctly isolated. ---
             glDeleteTextures(1, &texture.gl_texture_id);
#elif defined(SITUATION_USE_VULKAN)
             // Vulkan path has its own error checking and cleanup. This path is for GL.
#endif
             return (SituationTexture){0};
        }
    }
    
    return texture;
}

/**
 * @brief Destroys a GPU texture and frees its associated resources.
 *
 * @details Cleans up all backend-specific resources associated with the texture (e.g., OpenGL texture name, Vulkan image, view, sampler, VMA allocation, cached descriptor set). The texture handle is invalidated after this call.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Calls `glDeleteTextures` to delete the texture name. The OpenGL driver manages the underlying memory and GPU resource lifecycle.
 * - **Vulkan:** Waits for the device to be idle to ensure the texture is no longer in use. Then, it destroys the `VkSampler`, `VkImageView`, and uses `vmaDestroyImage` for the `VkImage` and `VmaAllocation`.
 *   Crucially, if a persistent descriptor set was allocated for this texture during creation, it is also freed back to the dedicated persistent descriptor pool.
 *   This function uses the internal `_SituationVulkanDestroyTexture` helper if available for centralized Vulkan cleanup logic.
 *
 * @param[in,out] texture A pointer to the `SituationTexture` handle to destroy.
 *                        The `texture->id` field will be set to 0 upon successful destruction. The contents of the struct pointed to by `texture` will be zeroed.
 *
 * @note It's safe to call this function on an already destroyed or invalid texture (where `texture->id` is 0); it will simply do nothing.
 * @note This function internally removes the texture from the library's resource tracking list.
 */
SITAPI void SituationDestroyTexture(SituationTexture* texture) {
    // --- 1. Input Validation ---
    if (!texture || texture->id == 0) {
        // Silently succeed if trying to destroy an invalid/null texture.
        // This is a common and safe pattern.
        return;
    }

    // --- 2. Resource Manager: Remove from tracking list ---
    _SituationTextureNode* current = sit_gs.all_textures;
    _SituationTextureNode* prev = NULL;

    while (current != NULL) {
        if (current->texture.id == texture->id) {
            if (prev) {
                prev->next = current->next;
            } else {
                sit_gs.all_textures = current->next;
            }
            free(current);
            break; // Found and removed, stop searching
        }
        prev = current;
        current = current->next;
    }
    // If the texture wasn't found in the list, it's an inconsistency, but proceeding with backend destruction is still the correct action for the resource itself.

#if defined(SITUATION_USE_OPENGL)
    {
        // --- 3. OpenGL Destruction ---
        glDeleteTextures(1, &texture->gl_texture_id);
        SIT_CHECK_GL_ERROR();
        // Note: OpenGL driver handles resource lifecycle.
    }

#elif defined(SITUATION_USE_VULKAN)
    {
        // --- 3. Vulkan Destruction ---
        // Critical: Ensure the GPU is finished using the texture before destroying it.
        // Waiting for the entire device to be idle is the simplest and safest way.
        VkResult wait_result = vkDeviceWaitIdle(sit_gs.vk.device);
        if (wait_result != VK_SUCCESS) {
             fprintf(stderr, "WARNING: vkDeviceWaitIdle failed (0x%x) during texture destruction.\n", wait_result);
             // Proceeding to destroy resources to prevent leaks, despite potential issues.
        }

        // --- NEW (if descriptor sets are cached): Free the persistent descriptor set ---
        // This step is crucial if descriptor sets are pre-allocated for textures.
        // It assumes the descriptor set was allocated from `sit_gs.vk.persistent_descriptor_pool`.
        // (The exact pool might vary based on your implementation details).
        if (texture->descriptor_set != VK_NULL_HANDLE) {
             // It's crucial that the pool used for allocation supports freeing individual sets
             // (VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT).
             VkResult free_result = vkFreeDescriptorSets(
                 sit_gs.vk.device,
                 sit_gs.vk.persistent_descriptor_pool, // Or the specific pool used for textures
                 1,
                 &texture->descriptor_set
             );
             if (free_result != VK_SUCCESS) {
                 fprintf(stderr, "WARNING: vkFreeDescriptorSets failed (0x%x) for texture's descriptor set.\n", free_result);
                 // This might indicate a pool problem.
             }
             texture->descriptor_set = VK_NULL_HANDLE; // Optional, as struct is zeroed later
        }
        // --- END NEW ---

        // --- Use Internal Helper (if it exists and handles sampler/view/image/alloc) ---
        // Check if there's a specific helper like `_SituationVulkanDestroyTexture`.
        // If it exists and is designed to handle all texture resources including the descriptor set (which we just freed above, so the helper shouldn't try to free it again), then call it. Otherwise, perform the destruction steps directly as below.
        //
        // IF SUCH A HELPER EXISTS AND IS SUITABLE:
        // _SituationVulkanDestroyTexture(texture->image, texture->image_view, texture->sampler, texture->allocation);
        //
        // IF NO SUCH HELPER EXISTS OR IT'S INCOMPLETE, USE DIRECT CALLS:
        // ---------------------------------------------------------------------
        // Destroy the Vulkan objects directly.
        vkDestroySampler(sit_gs.vk.device, texture->sampler, NULL);
        vkDestroyImageView(sit_gs.vk.device, texture->image_view, NULL);
        vmaDestroyImage(sit_gs.vk.vma_allocator, texture->image, texture->allocation);
        // VkImage, VkImageView, VkSampler, VmaAllocation handles are now invalid.
        texture->image = VK_NULL_HANDLE;
        texture->image_view = VK_NULL_HANDLE;
        texture->sampler = VK_NULL_HANDLE;
        texture->allocation = VK_NULL_HANDLE;
        // ---------------------------------------------------------------------
    }
#endif

    // --- 4. Invalidate the User-Facing Handle ---
    // Zero out the entire user-facing struct to invalidate it and prevent accidental reuse.
    memset(texture, 0, sizeof(SituationTexture));
    // After this call, texture->id is 0, indicating it's no longer valid.
}


#if defined(SITUATION_USE_VULKAN)
/**
 * @brief [INTERNAL] Creates a GPU buffer, uploads data to it via a staging buffer, and allocates memory.
 *
 * @details This is a fundamental helper function for Vulkan. It encapsulates the process of:
 * 1. Creating a CPU-visible staging buffer.
 * 2. Uploading user data to the staging buffer.
 * 3. Creating a GPU-local (device-memory) destination buffer with specified usage flags.
 * 4. Recording and submitting a command to copy data from the staging buffer to the destination buffer.
 * 5. Cleaning up the staging buffer.
 *
 * @param data Pointer to the data to upload. Must not be NULL.
 * @param size The size of the data in bytes. Must be > 0.
 * @param usage The Vulkan usage flags for the final GPU buffer (e.g., VK_BUFFER_USAGE_VERTEX_BUFFER_BIT).
 *              VK_BUFFER_USAGE_TRANSFER_DST_BIT is automatically added.
 * @param out_buffer Pointer to a VkBuffer handle to store the created GPU buffer. Must not be NULL.
 * @param out_allocation Pointer to a VmaAllocation handle to store the memory allocation info. Must not be NULL.
 * @return SITUATION_SUCCESS on successful creation and data upload.
 * @return SITUATION_ERROR_INVALID_PARAM if input parameters are invalid.
 * @return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED if staging or final buffer allocation fails.
 * @return SITUATION_ERROR_BUFFER_MAP_FAILED if mapping the staging buffer fails.
 * @return SITUATION_ERROR_VULKAN_COMMAND_FAILED if recording or executing the copy command fails.
 */
static SituationError _SituationVulkanCreateAndUploadBuffer(const void* data, VkDeviceSize size, VkBufferUsageFlags usage, VkBuffer* out_buffer, VmaAllocation* out_allocation) {
    // --- 1. Input Validation ---
    // As an internal helper, basic checks prevent internal errors.
    if (!data || size == 0 || !out_buffer || !out_allocation) {
        return SITUATION_ERROR_INVALID_PARAM;
    }
    // Initialize outputs to safe/invalid values in case of early return.
    *out_buffer = VK_NULL_HANDLE;
    *out_allocation = VK_NULL_HANDLE;

    // --- 2. Create Staging Buffer ---
    VkBuffer staging_buffer = VK_NULL_HANDLE;
    VmaAllocation staging_allocation = VK_NULL_HANDLE;

    VkBufferCreateInfo staging_buffer_info = {0};
    staging_buffer_info.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    staging_buffer_info.size = size;
    staging_buffer_info.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;

    VmaAllocationCreateInfo staging_alloc_info = {0};
    staging_alloc_info.usage = VMA_MEMORY_USAGE_CPU_TO_GPU; // Suitable for uploads from CPU

    VkResult result = vmaCreateBuffer(sit_gs.vk.vma_allocator, &staging_buffer_info, &staging_alloc_info, &staging_buffer, &staging_allocation, NULL);
    if (result != VK_SUCCESS) {
        // _SituationSetErrorFromCode should ideally be called by the caller for context,
        // or this function could set a generic message.
        return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED;
    }

    // --- 3. Upload Data to Staging Buffer ---
    void* mapped_data = NULL;
    result = vmaMapMemory(sit_gs.vk.vma_allocator, staging_allocation, &mapped_data);
    if (result != VK_SUCCESS) {
        vmaDestroyBuffer(sit_gs.vk.vma_allocator, staging_buffer, staging_allocation);
        return SITUATION_ERROR_BUFFER_MAP_FAILED;
    }
    memcpy(mapped_data, data, (size_t)size);
    vmaUnmapMemory(sit_gs.vk.vma_allocator, staging_allocation);

    // --- 4. Create Final GPU-Local Buffer ---
    VkBufferCreateInfo buffer_info = {0};
    buffer_info.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    buffer_info.size = size;
    // Crucially, add TRANSFER_DST_BIT to the requested usage for the copy operation.
    buffer_info.usage = VK_BUFFER_USAGE_TRANSFER_DST_BIT | usage;

    VmaAllocationCreateInfo alloc_info = {0};
    alloc_info.usage = VMA_MEMORY_USAGE_GPU_ONLY; // High-performance device-local memory

    result = vmaCreateBuffer(sit_gs.vk.vma_allocator, &buffer_info, &alloc_info, out_buffer, out_allocation, NULL);
    if (result != VK_SUCCESS) {
        vmaDestroyBuffer(sit_gs.vk.vma_allocator, staging_buffer, staging_allocation);
        return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED;
    }

    // --- 5. Copy Data from Staging to Final Buffer ---
    VkCommandBuffer command_buffer = _SituationVulkanBeginSingleTimeCommands();
    if (command_buffer == VK_NULL_HANDLE) {
        // Cleanup already created final buffer
        vmaDestroyBuffer(sit_gs.vk.vma_allocator, *out_buffer, *out_allocation);
        *out_buffer = VK_NULL_HANDLE;
        *out_allocation = VK_NULL_HANDLE;
        vmaDestroyBuffer(sit_gs.vk.vma_allocator, staging_buffer, staging_allocation);
        return SITUATION_ERROR_VULKAN_COMMAND_FAILED; // Assume _SituationVulkanBeginSingleTimeCommands sets a specific error
    }

    VkBufferCopy copy_region = {0}; // Explicitly zero-initialize
    copy_region.size = size;
    // Note: srcOffset and dstOffset default to 0, which is correct for full buffer copy.
    vkCmdCopyBuffer(command_buffer, staging_buffer, *out_buffer, 1, &copy_region);
    // Note: vkCmdCopyBuffer itself doesn't return VkResult. Errors would be caught during command buffer submission.

    // _SituationVulkanEndSingleTimeCommands submits the command buffer and waits for completion.
    SituationError cmd_result = _SituationVulkanEndSingleTimeCommands(command_buffer);
    if (cmd_result != SITUATION_SUCCESS) {
        // If the copy failed, we still need to clean up the successfully created resources.
        // The command buffer itself is freed by _SituationVulkanEndSingleTimeCommands on failure path.
        vmaDestroyBuffer(sit_gs.vk.vma_allocator, *out_buffer, *out_allocation);
        *out_buffer = VK_NULL_HANDLE;
        *out_allocation = VK_NULL_HANDLE;
        vmaDestroyBuffer(sit_gs.vk.vma_allocator, staging_buffer, staging_allocation);
        return cmd_result; // Propagate the specific command error
    }

    // --- 6. Cleanup Staging Buffer ---
    // This must happen *after* the copy command has finished executing (ensured by _SituationVulkanEndSingleTimeCommands).
    vmaDestroyBuffer(sit_gs.vk.vma_allocator, staging_buffer, staging_allocation);

    // --- 7. Success ---
    // Outputs (*out_buffer, *out_allocation) are already set by vmaCreateBuffer on success.
    return SITUATION_SUCCESS;
}
#endif

// ============================================================================
// Buffer Implementation
// ============================================================================

/**
 * @brief Creates a general-purpose GPU data buffer for storing vertices, indices, uniforms (UBOs), or shader storage data (SSBOs).
 * @details This is the primary function for allocating memory on the GPU. It abstracts the backend-specific complexities, such as OpenGL's buffer storage mechanisms or Vulkan's staging buffer transfers, into a single, unified call.
 *          The `usage_flags` parameter is critical, as it provides a hint to the driver about how the buffer will be used, which heavily influences performance and memory placement.
 *
 * @par Backend-Specific Behavior & Performance
 * - **OpenGL:** Uses modern Direct State Access (`glCreateBuffers`, `glNamedBufferStorage`). Buffers intended for updates (e.g., UBOs, SSBOs) are automatically created with `GL_DYNAMIC_STORAGE_BIT` to allow modification via `SituationUpdateBuffer`.
 * - **Vulkan:** This function implements a high-performance workflow.
 *   - If `initial_data` is provided, it automatically creates a temporary staging buffer, copies the data to it, and then records a GPU command to transfer the data to a fast, device-local (`VMA_MEMORY_USAGE_GPU_ONLY`) final buffer.
 *   - If the buffer is created with `SITUATION_BUFFER_USAGE_UNIFORM_BUFFER` or `SITUATION_BUFFER_USAGE_STORAGE_BUFFER`, it also **pre-allocates and caches a persistent `VkDescriptorSet`** within the `SituationBuffer` handle. This
 *     makes subsequent binding with `SituationCmdBindUniformBuffer` or `SituationCmdBindComputeBuffer` an extremely fast operation, avoiding runtime descriptor allocation overhead.
 *
 * @param size The total size of the buffer to allocate, in bytes. Must be greater than zero.
 * @param initial_data A pointer to the initial data to upload to the buffer. If `NULL`, the buffer is allocated, but its contents are undefined until written to.
 * @param usage_flags A bitmask of `SituationBufferUsageFlags` that tells the driver how the buffer will be used.
 *                    This is a critical performance hint. Flags can be combined using the bitwise OR operator (e.g., `SITUATION_BUFFER_USAGE_VERTEX_BUFFER | SITUATION_BUFFER_USAGE_TRANSFER_SRC`).
 *
 * @return A `SituationBuffer` handle.
 *         - On success, the `id` member of the returned struct will be non-zero, and the handle is ready for use.
 *         - On failure, the `id` member will be 0. Use `SituationGetLastErrorMsg()` to get a detailed error description.
 *           Failure can occur due to invalid parameters, running out of GPU memory, or other API errors.
 *
 * @note The caller is **responsible** for destroying the buffer using `SituationDestroyBuffer()` to prevent GPU memory leaks.
 *
 * @warning Providing incorrect or overly broad `usage_flags` can lead to suboptimal performance. For example, creating a static vertex buffer without `SITUATION_BUFFER_USAGE_TRANSFER_DST` might prevent it from being updated efficiently later.
 * @warning This function is not thread-safe and must be called from the main thread that initialized the library.
 *
 * @see SituationDestroyBuffer()
 * @see SituationUpdateBuffer()
 * @see SituationGetBufferData()
 * @see SituationBufferUsageFlags
 */
SITAPI SituationBuffer SituationCreateBuffer(size_t size, const void* initial_data, SituationBufferUsageFlags usage_flags) {
    SituationBuffer buffer = {0};
    SituationError local_err = SITUATION_SUCCESS;

    // --- 1. Pre-initialization Validation ---
    if (!sit_gs.is_initialized) { _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot create buffer before library initialization."); return buffer; } // Return zeroed/invalid buffer
    if (size == 0) { _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Cannot create buffer of size 0."); return buffer; }
    // Ensure at least one usage flag is specified to guide creation and memory allocation.
    if (usage_flags == 0) { _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "SituationCreateBuffer: No usage flags specified."); return buffer; }

    buffer.size_in_bytes = size;
    // Store the abstract flags for potential internal use or debugging
    //buffer.abstract_usage_flags = usage_flags;

    // --- 2. Backend-Specific Creation ---
#if defined(SITUATION_USE_OPENGL)
    {
        // --- OpenGL Implementation ---
        glCreateBuffers(1, &buffer.gl_buffer_id);
        if (buffer.gl_buffer_id == 0) { _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_GENERAL, "glCreateBuffers failed."); return buffer; }

        // Determine appropriate OpenGL storage flags.
        // GL_DYNAMIC_STORAGE_BIT allows the buffer's contents to be updated via glNamedBufferSubData.
        GLbitfield gl_storage_flags = 0;

        // If the buffer is likely to be updated from the CPU (e.g., SSBO, UBO for dynamic data, or a destination for transfers), we need DYNAMIC_STORAGE.
        // The provided usage_flags are assumed to be OpenGL flags or a compatible abstract set.
        // If they are abstract, a mapping function should be used here.
        // For now, we pass them directly, assuming they are either 0 or contain GL_*_STORAGE_BIT flags.
        // A safer approach is to ensure DYNAMIC_STORAGE is set if initial_data is NULL or if common mutable usage flags are present.
        gl_storage_flags = (GLbitfield)usage_flags; // Direct cast, assuming compatibility

        // Ensure DYNAMIC_STORAGE if needed for future updates
        if (!initial_data || (usage_flags & (SITUATION_BUFFER_USAGE_STORAGE_BUFFER | SITUATION_BUFFER_USAGE_UNIFORM_BUFFER | SITUATION_BUFFER_USAGE_TRANSFER_DST))) { gl_storage_flags |= GL_DYNAMIC_STORAGE_BIT; }
        glNamedBufferStorage(buffer.gl_buffer_id, size, initial_data, gl_storage_flags);

        SIT_CHECK_GL_ERROR();
        if (sit_gs.gl.last_error != GL_NO_ERROR) {
            // Error message should be set by SIT_CHECK_GL_ERROR
            local_err = SITUATION_ERROR_OPENGL_GENERAL;
            glDeleteBuffers(1, &buffer.gl_buffer_id);
            buffer.gl_buffer_id = 0;
            memset(&buffer, 0, sizeof(buffer));
            return buffer; // Return invalid buffer
        }

        // Use the OpenGL buffer name as the public ID.
        buffer.id = buffer.gl_buffer_id;
    }
#elif defined(SITUATION_USE_VULKAN)
    {
        // --- Vulkan Implementation ---
        // --- 2.1. Map abstract usage flags to Vulkan VkBufferUsageFlags ---
        VkBufferUsageFlags vk_usage_flags = 0;
        if (usage_flags & SITUATION_BUFFER_USAGE_VERTEX_BUFFER)   vk_usage_flags |= VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
        if (usage_flags & SITUATION_BUFFER_USAGE_INDEX_BUFFER)    vk_usage_flags |= VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
        if (usage_flags & SITUATION_BUFFER_USAGE_UNIFORM_BUFFER)  vk_usage_flags |= VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
        if (usage_flags & SITUATION_BUFFER_USAGE_STORAGE_BUFFER)  vk_usage_flags |= VK_BUFFER_USAGE_STORAGE_BUFFER_BIT;
        if (usage_flags & SITUATION_BUFFER_USAGE_INDIRECT_BUFFER) vk_usage_flags |= VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT;
        if (usage_flags & SITUATION_BUFFER_USAGE_TRANSFER_SRC)    vk_usage_flags |= VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
        if (usage_flags & SITUATION_BUFFER_USAGE_TRANSFER_DST)    vk_usage_flags |= VK_BUFFER_USAGE_TRANSFER_DST_BIT;

        // Ensure at least one flag is set
        if (vk_usage_flags == 0) { _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "SituationCreateBuffer: Mapped Vulkan usage flags are invalid (all zero)."); return buffer; }

        // Store the mapped Vulkan flags for internal use (e.g., in UpdateBuffer, GetBufferData, Descriptor Set creation)
        buffer.vk_usage_flags = vk_usage_flags;
        buffer.descriptor_set = VK_NULL_HANDLE; // Initialize descriptor set member

        // --- 2.2. Create the buffer using the mapped flags ---
        if (initial_data) {
            // Use helper that creates staging buffer and uploads data.
            local_err = _SituationVulkanCreateAndUploadBuffer(
                initial_data,
                size,
                vk_usage_flags, // Pass the correctly mapped flags
                &buffer.vk_buffer,
                &buffer.vma_allocation
            );
            if (local_err != SITUATION_SUCCESS) {
                // Error message should be set by _SituationVulkanCreateAndUploadBuffer
                memset(&buffer, 0, sizeof(buffer));
                return buffer; // Return invalid buffer
            }
        } else {
            // Create an empty buffer directly on GPU memory.
            VkBufferCreateInfo buffer_info = {0};
            buffer_info.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
            buffer_info.size = size;
            buffer_info.usage = vk_usage_flags; // --- Use the mapped flags ---

            // Determine memory usage based on flags for VMA.
            VmaAllocationCreateInfo alloc_info = {0};
            // --- Heuristic for Memory Usage ---
            // Prioritize GPU-local memory for performance if it's primarily a GPU resource.
            if ((vk_usage_flags & (VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT | VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT)) &&
                !(vk_usage_flags & (VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT))) {
                // If it's used by GPU stages and not explicitly for CPU transfer, prefer GPU local.
                alloc_info.usage = VMA_MEMORY_USAGE_GPU_ONLY;
            } else if (vk_usage_flags & (VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_TRANSFER_SRC_BIT)) {
                 // If it's for transfer, it might be filled by GPU or CPU. GPU_ONLY is often fine
                 // if filled via staging buffer (which _SituationVulkanCreateAndUploadBuffer handles).
                 // For CPU writes, CPU_TO_GPU might be more direct, but staging is common.
                 // Let's default to GPU_ONLY for transfer buffers assuming staging usage.
                alloc_info.usage = VMA_MEMORY_USAGE_GPU_ONLY;
            } else {
                // Default/fallback: GPU local memory.
                alloc_info.usage = VMA_MEMORY_USAGE_GPU_ONLY;
            }

            VkResult result = vmaCreateBuffer(
                sit_gs.vk.vma_allocator,
                &buffer_info,
                &alloc_info,
                &buffer.vk_buffer,
                &buffer.vma_allocation,
                NULL // Optional pAllocationInfo
            );

            if (result != VK_SUCCESS) {
                _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED, "Failed to create empty Vulkan buffer.");
                local_err = SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED;
                memset(&buffer, 0, sizeof(buffer));
                return buffer; // Return invalid buffer
            }
        }

        // --- 2.3. NEW: Pre-allocate and populate the persistent descriptor set ---
        // Determine the correct descriptor type based on primary usage.
        // A buffer might have multiple usage flags, but we typically bind it as one type.
        VkDescriptorType descriptor_type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER; // Default
        VkDescriptorSetLayout layout_to_use = sit_gs.vk.ubo_layout; // Default layout

        // Prioritize Storage Buffer if flagged as such, as it's more general.
        if (usage_flags & SITUATION_BUFFER_USAGE_STORAGE_BUFFER) {
            descriptor_type = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
            layout_to_use = sit_gs.vk.ssbo_layout;
        } else if (usage_flags & SITUATION_BUFFER_USAGE_UNIFORM_BUFFER) {
            // UBO flag takes precedence if SSBO isn't set
            descriptor_type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
            layout_to_use = sit_gs.vk.ubo_layout;
        }
        // Add logic for other types if needed (e.g., using SSBO layout for UBO if that's preferred)

        // Allocate the descriptor set from the dedicated persistent pool
        VkDescriptorSetAllocateInfo alloc_info = {0};
        alloc_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
        alloc_info.descriptorPool = sit_gs.vk.persistent_descriptor_pool; // --- Use persistent pool ---
        alloc_info.descriptorSetCount = 1;
        alloc_info.pSetLayouts = &layout_to_use;

        VkResult result = vkAllocateDescriptorSets(sit_gs.vk.device, &alloc_info, &buffer.descriptor_set);
        if (result != VK_SUCCESS) {
            _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED, "Failed to allocate persistent descriptor set for buffer.");
            local_err = SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED;
            // Clean up buffer...
            vmaDestroyBuffer(sit_gs.vk.vma_allocator, buffer.vk_buffer, buffer.vma_allocation);
            buffer.vk_buffer = VK_NULL_HANDLE;
            buffer.vma_allocation = VK_NULL_HANDLE;
            memset(&buffer, 0, sizeof(buffer));
            return buffer; // Return invalid buffer
        }

        // Populate the descriptor set with this buffer's info
        VkDescriptorBufferInfo buffer_info = {0};
        buffer_info.buffer = buffer.vk_buffer;
        buffer_info.offset = 0;
        buffer_info.range = VK_WHOLE_SIZE; // Or specific range if needed

        VkWriteDescriptorSet descriptor_write = {0};
        descriptor_write.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        descriptor_write.dstSet = buffer.descriptor_set; // The set we just allocated
        descriptor_write.dstBinding = 0; // Binding point within the set (0 for our standard layouts)
        descriptor_write.dstArrayElement = 0;
        descriptor_write.descriptorType = descriptor_type; // Use the determined type
        descriptor_write.descriptorCount = 1;
        descriptor_write.pBufferInfo = &buffer_info;

        vkUpdateDescriptorSets(sit_gs.vk.device, 1, &descriptor_write, 0, NULL);
        // --- END NEW ---

        // --- 2.4. Assign ID (using VkBuffer handle as unique ID) ---
        buffer.id = (uint64_t)(uintptr_t)buffer.vk_buffer;
    }
#endif // SITUATION_USE_VULKAN

    // --- 3. Resource Tracking (Add to internal linked list) ---
    if (buffer.id != 0) {
        _SituationBufferNode* node = (_SituationBufferNode*)malloc(sizeof(_SituationBufferNode));
        if (node) {
            node->buffer = buffer;
            node->next = sit_gs.all_buffers;
            sit_gs.all_buffers = node;
        } else {
            _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Resource tracking node for buffer");
            local_err = SITUATION_ERROR_MEMORY_ALLOCATION;
            // Need to destroy the successfully created backend buffer before returning
#if defined(SITUATION_USE_OPENGL)
            glDeleteBuffers(1, &buffer.gl_buffer_id);
            buffer.gl_buffer_id = 0;
#elif defined(SITUATION_USE_VULKAN)
            // Free the descriptor set if it was allocated
            if (buffer.descriptor_set != VK_NULL_HANDLE) {
                vkFreeDescriptorSets(sit_gs.vk.device, sit_gs.vk.persistent_descriptor_pool, 1, &buffer.descriptor_set);
                buffer.descriptor_set = VK_NULL_HANDLE;
            }
            vmaDestroyBuffer(sit_gs.vk.vma_allocator, buffer.vk_buffer, buffer.vma_allocation);
            buffer.vk_buffer = VK_NULL_HANDLE;
            buffer.vma_allocation = VK_NULL_HANDLE;
#endif
            memset(&buffer, 0, sizeof(buffer));
            return buffer; // Return invalid buffer
        }
    }

    // If any error occurred during backend creation or tracking, it should have been handled and buffer.id set to 0.
    if (local_err != SITUATION_SUCCESS) {
        // Error state should already be set by the specific error handling code above.
        // Returning the zeroed buffer is sufficient.
    }
    return buffer; // Return the (potentially valid) buffer handle
}

/**
 * @brief Destroys a GPU buffer and frees all associated resources.
 * @details This is the only correct way to release a buffer created with SituationCreateBuffer.
 *          It handles backend-specific cleanup (OpenGL buffer names, Vulkan buffers, VMA allocations, and cached descriptor sets) and removes the buffer from the library's internal resource tracking list to prevent shutdown warnings.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Calls `glDeleteBuffers` to release the buffer object.
 * - **Vulkan:** Waits for the GPU to become idle to ensure the buffer is not in use, then frees the pre-allocated persistent descriptor set, and finally destroys the `VkBuffer` and its `VmaAllocation`.
 *
 * @param[in,out] buffer A pointer to the `SituationBuffer` handle to destroy. The handle is invalidated (zeroed out) after this call.
 *
 * @note It is safe to call this function on a NULL pointer or an already-destroyed (zeroed) buffer handle; it will simply do nothing.
 * @warning This function can cause a GPU stall on the Vulkan backend due to `vkDeviceWaitIdle`.
 *          Avoid destroying buffers frequently in performance-critical loops.
 */
SITAPI void SituationDestroyBuffer(SituationBuffer* buffer) {
    // --- 1. Input Validation ---
    // Silently succeed if trying to destroy a NULL pointer or an already-invalid handle.
    // This is a robust pattern that simplifies user code, preventing crashes from double-frees.
    if (!buffer || buffer->id == 0) {
        return;
    }

    // --- 2. Resource Manager: Remove from internal tracking list ---
    // This prevents the shutdown sequence from reporting this buffer as a leak.
    _SituationBufferNode* current = sit_gs.all_buffers;
    _SituationBufferNode* prev = NULL;

    while (current != NULL) {
        if (current->buffer.id == buffer->id) {
            if (prev) {
                prev->next = current->next; // Unlink from middle/end of the list
            } else {
                sit_gs.all_buffers = current->next; // Unlink from the head of the list
            }
            free(current); // Free the tracking node itself
            break; // Found and removed, can exit the loop
        }
        prev = current;
        current = current->next;
    }

    // --- 3. Backend-Specific Destruction ---
#if defined(SITUATION_USE_OPENGL)
    {
        // For OpenGL, we simply delete the buffer name. The driver manages the memory.
        glDeleteBuffers(1, &buffer->gl_buffer_id);
        SIT_CHECK_GL_ERROR(); // Check for errors, e.g., if the context was lost.
    }
#elif defined(SITUATION_USE_VULKAN)
    {
        // For Vulkan, we must ensure the GPU is finished before destroying resources.
        // Waiting for the device to be idle is the simplest and safest synchronization method.
        if (sit_gs.vk.device) {
            vkDeviceWaitIdle(sit_gs.vk.device);
        }

        // 1. Free the persistent descriptor set associated with this buffer.
        // This is crucial to return the descriptor to the pool.
        if (buffer->descriptor_set != VK_NULL_HANDLE) {
            // We must use the pool it was allocated from, which we've designated as the persistent one.
            vkFreeDescriptorSets(sit_gs.vk.device, sit_gs.vk.persistent_descriptor_pool, 1, &buffer->descriptor_set);
        }

        // 2. Destroy the buffer and its memory allocation.
        // Use the Vulkan Memory Allocator (VMA) to destroy the VkBuffer and free its VmaAllocation.
        // This handles both the Vulkan object and its underlying memory in one call.
        if (buffer->vk_buffer != VK_NULL_HANDLE && sit_gs.vk.vma_allocator) {
            vmaDestroyBuffer(sit_gs.vk.vma_allocator, buffer->vk_buffer, buffer->vma_allocation);
        }
    }
#endif

    // --- 4. Invalidate the User-Facing Handle ---
    // Zero out the entire struct to prevent accidental use of dangling pointers or stale handles.
    // This correctly sets buffer->id to 0, marking it as invalid for future calls.
    memset(buffer, 0, sizeof(SituationBuffer));
}

/**
 * @brief Creates a self-contained GPU mesh from vertex and index data.
 * @details This function allocates all necessary GPU resources for a renderable mesh and configures its vertex attribute layout according to the library's shader contract.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Creates a dedicated Vertex Array Object (VAO) for this mesh. It also creates a Vertex Buffer Object (VBO) and an Element Buffer Object (EBO), uploads the provided data,
 *   and configures the VAO's vertex attributes (position, normal, texcoord) to point to the correct data within the VBO. The mesh is a fully self-contained, ready-to-draw object.
 * - **Vulkan:** Creates two device-local `VkBuffer` objects (one for vertices, one for indices) and uses a staging buffer process to upload the provided data to them for optimal performance.
 *
 * @param vertex_data Pointer to the raw, interleaved vertex data.
 * @param vertex_count The total number of vertices in the buffer.
 * @param vertex_stride The size of a single vertex struct in bytes (e.g., `sizeof(MyVertex)`).
 * @param index_data Pointer to the index data (must be `uint32_t`).
 * @param index_count The total number of indices.
 *
 * @return A `SituationMesh` handle.
 *         - On success, the `id` will be non-zero.
 *         - On failure, the `id` will be 0. Use `SituationGetLastErrorMsg()` for details.
 *
 * @note The provided vertex data **must** conform to the attribute layout defined in the Shader Contract (e.g., Position `vec3`, Normal `vec3`, TexCoord `vec2`).
 * @note The caller is **responsible** for destroying the mesh using `SituationDestroyMesh()`.
 */
SITAPI SituationMesh SituationCreateMesh(const void* vertex_data, int vertex_count, size_t vertex_stride, const uint32_t* index_data, int index_count) {
    SituationMesh mesh = {0};
    if (!vertex_data || vertex_count <= 0 || !index_data || index_count <= 0 || vertex_stride == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Invalid data or stride provided for mesh creation.");
        return mesh;
    }
    
    mesh.index_count = index_count;

#if defined(SITUATION_USE_OPENGL)
    // --- OpenGL: Create a self-contained mesh object with its own VAO ---

    // 1. Create all necessary OpenGL objects: one VAO to hold the state, and two buffers for the data.
    //    We use Direct State Access (DSA) for a cleaner, object-oriented approach.
    glCreateVertexArrays(1, &mesh.vao_id);
    glCreateBuffers(1, &mesh.vbo_id);
    glCreateBuffers(1, &mesh.ebo_id);

    // 2. Upload the vertex and index data to their respective buffers.
    //    GL_STATIC_DRAW is a hint that this data will not be modified frequently.
    glNamedBufferData(mesh.vbo_id, vertex_count * vertex_stride, vertex_data, GL_STATIC_DRAW);
    glNamedBufferData(mesh.ebo_id, index_count * sizeof(uint32_t), index_data, GL_STATIC_DRAW);

    // 3. Configure the VAO: This is where we describe the layout of the vertex data.
    //    We are telling the VAO, "When you are used for drawing..."

    // "...use `mesh.vbo_id` as the source for vertex data for binding point 0."
    glVertexArrayVertexBuffer(mesh.vao_id, 0, mesh.vbo_id, 0, vertex_stride);
    
    // "...use `mesh.ebo_id` as the source for indices."
    glVertexArrayElementBuffer(mesh.vao_id, mesh.ebo_id);
    
    // "...enable vertex attribute location 0 (Position)."
    glEnableVertexArrayAttrib(mesh.vao_id, SIT_ATTR_POSITION);
    // "...and tell it to find its data at binding point 0, with 3 floats, starting at offset 0."
    glVertexArrayAttribFormat(mesh.vao_id, SIT_ATTR_POSITION, 3, GL_FLOAT, GL_FALSE, 0);
    glVertexArrayAttribBinding(mesh.vao_id, SIT_ATTR_POSITION, 0);

    // "...enable vertex attribute location 1 (Normal)."
    glEnableVertexArrayAttrib(mesh.vao_id, SIT_ATTR_NORMAL);
    // "...and tell it to find its data at binding point 0, with 3 floats, starting after the position data."
    glVertexArrayAttribFormat(mesh.vao_id, SIT_ATTR_NORMAL, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float));
    glVertexArrayAttribBinding(mesh.vao_id, SIT_ATTR_NORMAL, 0);

    // Conditionally enable texture coordinates if the vertex stride is large enough to contain them.
    if (vertex_stride >= (3 + 3 + 2) * sizeof(float)) {
        glEnableVertexArrayAttrib(mesh.vao_id, SIT_ATTR_TEXCOORD_0);
        glVertexArrayAttribFormat(mesh.vao_id, SIT_ATTR_TEXCOORD_0, 2, GL_FLOAT, GL_FALSE, 6 * sizeof(float));
        glVertexArrayAttribBinding(mesh.vao_id, SIT_ATTR_TEXCOORD_0, 0);
    }
    
    // The VAO is now fully configured and self-contained. The VAO's ID serves as the public handle ID for the mesh.
    mesh.id = mesh.vao_id;
    SIT_CHECK_GL_ERROR();

#elif defined(SITUATION_USE_VULKAN)
    VkDeviceSize vertex_buffer_size = (VkDeviceSize)vertex_count * vertex_stride;
    if (_SituationVulkanCreateAndUploadBuffer(vertex_data, vertex_buffer_size, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, &mesh.vertex_buffer, &mesh.vertex_buffer_memory) != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED, "Failed to create vertex buffer for mesh.");
        return (SituationMesh){0};
    }

    VkDeviceSize index_buffer_size = (VkDeviceSize)index_count * sizeof(uint32_t);
    if (_SituationVulkanCreateAndUploadBuffer(index_data, index_buffer_size, VK_BUFFER_USAGE_INDEX_BUFFER_BIT, &mesh.index_buffer, &mesh.index_buffer_memory) != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED, "Failed to create index buffer for mesh.");
        vmaDestroyBuffer(sit_gs.vk.vma_allocator, mesh.vertex_buffer, mesh.vertex_buffer_memory);
        return (SituationMesh){0};
    }
    mesh.id = (uint32_t)(uintptr_t)mesh.vertex_buffer;
#endif

    // --- Resource Manager: Add to tracking list ---
    if (mesh.id != 0) {
        _SituationMeshNode* node = (_SituationMeshNode*)malloc(sizeof(_SituationMeshNode));
        if (node) {
            node->mesh = mesh;
            node->next = sit_gs.all_meshes;
            sit_gs.all_meshes = node;
        } else {
            _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Resource tracking node for mesh");
            SituationDestroyMesh(&mesh); // Clean up the GPU resource we just made
            return (SituationMesh){0};
        }
    }
    
    return mesh;
}

/**
 * @brief Destroys a GPU mesh and frees all of its associated resources.
 * @details This is the only correct way to release a mesh created with `SituationCreateMesh`. It handles the full cleanup process, ensuring that all backend-specific GPU objects are deleted and that the mesh is removed from the library's internal resource tracking list.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Deletes the Vertex Array Object (VAO), Vertex Buffer Object (VBO), and Element Buffer Object (EBO) associated with the mesh using `glDelete*` functions.
 * - **Vulkan:** Waits for the GPU to become idle to ensure the buffers are not in use, then destroys the `VkBuffer` and frees the `VmaAllocation` for both the vertex and index buffers.
 *
 * @param[in,out] mesh A pointer to the `SituationMesh` handle to destroy. The handle is invalidated by being zeroed out after this call, preventing accidental reuse.
 *
 * @note It is safe to call this function on a NULL pointer or an already-destroyed (zeroed) mesh handle; it will simply do nothing.
 * @note Failure to call this function on a created mesh will result in a GPU memory leak and a warning message upon application shutdown.
 * @warning This function can cause a GPU stall on the Vulkan backend due to `vkDeviceWaitIdle`. Avoid destroying meshes frequently in performance-critical loops.
 *
 * @see SituationCreateMesh()
 */
SITAPI void SituationDestroyMesh(SituationMesh* mesh) {
    // --- 1. Input Validation ---
    // Safely handle NULL pointers or already-invalidated handles to prevent crashes.
    if (!mesh || mesh->id == 0) {
        return;
    }

    // --- 2. Resource Manager: Remove from internal tracking list ---
    // This prevents the shutdown sequence from reporting this mesh as a leak.
    _SituationMeshNode* current = sit_gs.all_meshes;
    _SituationMeshNode* prev = NULL;

    while (current != NULL) {
        if (current->mesh.id == mesh->id) {
            if (prev) {
                prev->next = current->next; // Unlink from middle/end of the list
            } else {
                sit_gs.all_meshes = current->next; // Unlink from the head of the list
            }
            free(current); // Free the tracking node itself
            break; // Found and removed, can exit the loop
        }
        prev = current;
        current = current->next;
    }

    // --- 3. Backend-Specific Destruction ---
#if defined(SITUATION_USE_OPENGL)
    {
        // For OpenGL, we must delete the VAO and the two buffers it references.
        // It's safe to call glDelete* on an ID of 0.
        glDeleteVertexArrays(1, &mesh->vao_id);
        glDeleteBuffers(1, &mesh->vbo_id);
        glDeleteBuffers(1, &mesh->ebo_id);
        SIT_CHECK_GL_ERROR(); // Check for any errors during deletion.
    }
#elif defined(SITUATION_USE_VULKAN)
    {
        // For Vulkan, we must ensure the GPU is finished before destroying buffers.
        // Waiting for the device to be idle is the simplest and safest synchronization method.
        if (sit_gs.vk.device) {
            vkDeviceWaitIdle(sit_gs.vk.device);
        }
        
        // Use the Vulkan Memory Allocator (VMA) to destroy the buffers and free their allocations.
        if (sit_gs.vk.vma_allocator) {
            if (mesh->vertex_buffer != VK_NULL_HANDLE) {
                vmaDestroyBuffer(sit_gs.vk.vma_allocator, mesh->vertex_buffer, mesh->vertex_buffer_memory);
            }
            if (mesh->index_buffer != VK_NULL_HANDLE) {
                vmaDestroyBuffer(sit_gs.vk.vma_allocator, mesh->index_buffer, mesh->index_buffer_memory);
            }
        }
    }
#endif

    // --- 4. Invalidate the User-Facing Handle ---
    // Zero out the entire struct to prevent accidental use of dangling pointers or stale handles.
    // This correctly sets mesh->id to 0, marking it as invalid for future calls.
    memset(mesh, 0, sizeof(SituationMesh));
}


#if defined(SITUATION_USE_OPENGL)
/**
 * @brief [INTERNAL] Compiles a single GLSL shader stage from a source string.
 * @details This is a low-level helper function that takes a string of GLSL code and a shader type (e.g., vertex, fragment, compute) and uses the OpenGL driver to compile it into a shader object. It performs comprehensive error checking and reporting.
 *
 * @par Compilation Process
 *   1.  Creates a new shader object of the specified `type` (`glCreateShader`).
 *   2.  Associates the `source` string with the shader object (`glShaderSource`).
 *   3.  Attempts to compile the shader (`glCompileShader`).
 *   4.  Checks the `GL_COMPILE_STATUS`. If compilation fails, it retrieves the detailed error log from the driver.
 *
 * The retrieved error log is formatted with a prefix indicating the shader type and is set as the library's last error message, providing invaluable feedback for debugging shader code.
 *
 * @param source A null-terminated C string containing the GLSL source code to compile.
 * @param type The type of shader to create (e.g., `GL_VERTEX_SHADER`, `GL_FRAGMENT_SHADER`, `GL_COMPUTE_SHADER`).
 * @param[out] error_code A pointer to a `SituationError` variable that will be filled with a specific error code on failure. Can be `NULL`.
 *
 * @return The `GLuint` ID of the compiled shader object on success.
 * @return `0` on failure. On failure, a detailed error message is set, and the invalid shader object is deleted.
 *
 * @note This function is for internal use by the higher-level shader program creation functions.
 * @warning The returned shader object is an intermediate resource. It should be attached to a program and then deleted with `glDeleteShader` to prevent resource leaks.
 *
 * @see _SituationCreateGLShaderProgram(), _SituationCreateGLShaderProgramFromSource()
 */
static GLuint _SituationCompileGLShader(const char* source, GLenum type, SituationError* error_code) {
    if (!source) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Null shader source");
        if (error_code) *error_code = SITUATION_ERROR_INVALID_PARAM;
        return 0;
    }

    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &source, NULL);
    glCompileShader(shader);

    GLint success = 0;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        GLint log_length = 0;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &log_length);

        if (log_length > 0) {
            // Determine the prefix for the error message.
            const char* type_name = "Unknown Shader";
            if (type == GL_VERTEX_SHADER) type_name = "Vertex Shader";
            else if (type == GL_FRAGMENT_SHADER) type_name = "Fragment Shader";
            else if (type == GL_COMPUTE_SHADER) type_name = "Compute Shader";
        
            // Calculate the total size needed for the final error string: "PREFIX: LOG\0"
            size_t prefix_len = strlen(type_name) + 2; // For ": "
            size_t total_buffer_size = prefix_len + log_length;

            // Allocate a single buffer for the entire message.
            char* final_error_message = (char*)malloc(total_buffer_size);
        
            if (final_error_message) {
                // Write the prefix into the buffer.
                strcpy(final_error_message, type_name);
                strcat(final_error_message, ": ");
            
                // Get a pointer to where the log should start.
                char* log_part = final_error_message + prefix_len;
            
                // Read the GL info log directly into the end of our buffer.
                glGetShaderInfoLog(shader, log_length, NULL, log_part);
            
                // Set the final, combined error message.
                _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_SHADER_COMPILE, final_error_message);
            
                // Free the single allocated buffer.
                free(final_error_message);
            } else {
                // If allocation fails, set a memory error.
                _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Failed to allocate memory for shader compilation log.");
            }
        } else {
            // No log available, provide a generic error.
            _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_SHADER_COMPILE, "An unknown shader compilation error occurred with no log.");
        }

        if (error_code) *error_code = SITUATION_ERROR_OPENGL_SHADER_COMPILE;
        glDeleteShader(shader);
        return 0;
    }

    if (error_code) *error_code = SITUATION_SUCCESS;
    return shader;
}

/**
 * @brief [INTERNAL] Creates a standard two-stage (vertex + fragment) OpenGL shader program from GLSL source.
 * @details This is the primary internal helper for creating graphics pipelines on the OpenGL backend. It orchestrates the process of compiling individual vertex and fragment shader sources and linking them together into a complete, usable `glProgram`.
 *
 * @par Creation Process
 *   1.  Calls `_SituationCompileGLShader` to compile the vertex shader source (`vs_src`).
 *   2.  If successful, it calls `_SituationCompileGLShader` to compile the fragment shader source (`fs_src`).
 *   3.  If both shaders compile successfully, it creates a new program object (`glCreateProgram`), attaches both shaders, and links them (`glLinkProgram`).
 *   4.  After linking, the individual shader objects are detached and deleted, as they are no longer needed.
 *   5.  Finally, it checks the link status and reports any errors.
 *
 * @param vs_src A null-terminated C string containing the vertex shader source code.
 * @param fs_src A null-terminated C string containing the fragment shader source code.
 * @param[out] error_code A pointer to a `SituationError` variable that will be filled with a specific error code on failure. Can be `NULL`.
 *
 * @return The OpenGL program ID (`GLuint`) on successful compilation and linking.
 * @return `0` on failure. On failure, a detailed error message (from either the compiler or linker) is set via `_SituationSetErrorFromCode`, and all intermediate resources are cleaned up.
 *
 * @note This function is for internal use by high-level `SituationLoadShader*` functions.
 * @warning The caller is responsible for deleting the returned program ID using `glDeleteProgram` when it is no longer needed.
 *
 * @see SituationLoadShaderFromMemory(), _SituationCompileGLShader()
 */
static GLuint _SituationCreateGLShaderProgram(const char* vs_src, const char* fs_src, SituationError* error_code) {
    if (!vs_src || !fs_src) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Null shader source");
        if (error_code) *error_code = SITUATION_ERROR_INVALID_PARAM;
        return 0;
    }

    SituationError local_err = SITUATION_SUCCESS;
    GLuint vs = _SituationCompileGLShader(vs_src, GL_VERTEX_SHADER, &local_err);
    if (local_err != SITUATION_SUCCESS) {
        if (error_code) *error_code = local_err;
        return 0;
    }

    GLuint fs = _SituationCompileGLShader(fs_src, GL_FRAGMENT_SHADER, &local_err);
    if (local_err != SITUATION_SUCCESS) {
        glDeleteShader(vs);
        if (error_code) *error_code = local_err;
        return 0;
    }

    GLuint program = glCreateProgram();
    if (!program) {
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_GENERAL, "Failed to create shader program");
        glDeleteShader(vs);
        glDeleteShader(fs);
        if (error_code) *error_code = SITUATION_ERROR_OPENGL_GENERAL;
        return 0;
    }

    glAttachShader(program, vs);
    glAttachShader(program, fs);
    glLinkProgram(program);

    glDeleteShader(vs);
    glDeleteShader(fs);

    GLint success;
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (!success) {
        GLint log_length = 0;
        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &log_length);
        // Dynamically allocate a buffer large enough for the full link error log.
        if (log_length > 0) {
            char* infoLog = (char*)malloc(log_length);
            if (infoLog) {
                glGetProgramInfoLog(program, log_length, NULL, infoLog);
                _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_SHADER_LINK, infoLog);
                free(infoLog);
            } else {
                _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Failed to allocate memory for shader link log.");
            }
        } else {
            // No log, provide a generic message.
            _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_SHADER_LINK, "An unknown linking error occurred.");
        }
        glDeleteProgram(program); // Add this line
        glDeleteShader(vs);       // Ensure shaders are deleted
        glDeleteShader(fs);       // Ensure shaders are deleted
        if (error_code) *error_code = SITUATION_ERROR_OPENGL_SHADER_LINK;
        return 0;
    }

    if (error_code) *error_code = SITUATION_SUCCESS;
    return program;
}

/**
 * @brief [INTERNAL] Creates a single-stage (compute) OpenGL shader program from GLSL source.
 * @details This helper function is the traditional GLSL-based creation path for compute shaders. It is called by the `_SituationCreateGLComputeProgram` dispatcher when the source type is GLSL or when SPIR-V is not supported.
 *
 * @par Creation Process
 *   1.  Calls `_SituationCompileGLShader` to compile the compute shader source (`cs_src`) with the type `GL_COMPUTE_SHADER`.
 *   2.  If compilation is successful, it creates a new program object, attaches the compute shader, and links the program.
 *   3.  The individual shader object is deleted after linking.
 *   4.  The link status is checked to ensure a valid executable program was created.
 *
 * @param cs_src A null-terminated C string containing the compute shader source code.
 * @param[out] error_code A pointer to a `SituationError` variable that will be filled with a specific error code on failure. Can be `NULL`.
 *
 * @return The OpenGL program ID (`GLuint`) on successful compilation and linking.
 * @return `0` on failure. On failure, a detailed error message is set, and all intermediate resources are cleaned up.
 *
 * @note This function is for internal use by `_SituationCreateGLComputeProgram` only. It specifically handles the single-stage linking process required for compute programs.
 *
 * @see _SituationCreateGLComputeProgram(), _SituationCompileGLShader()
 */
static GLuint _SituationCreateGLShaderProgramFromSource(const char* cs_src, SituationError* error_code) {
    if (!cs_src) {
        // This check is now primarily for internal consistency
        if (error_code) *error_code = SITUATION_ERROR_INVALID_PARAM;
        // _SituationCreateGLComputeProgram already set the error msg, avoid duplication or override it carefully
        // _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "_SituationCreateGLShaderProgramFromSource: Compute shader source cannot be NULL");
        return 0;
    }

    // 1. Compile the compute shader
    SituationError local_err = SITUATION_SUCCESS;
    GLuint cs = _SituationCompileGLShader(cs_src, GL_COMPUTE_SHADER, &local_err); // Assume this function exists and handles glGetShaderiv(GL_COMPILE_STATUS, ...)
    if (local_err != SITUATION_SUCCESS) {
        if (error_code) *error_code = local_err;
        return 0; // Error message already set by _SituationCompileGLShader
    }

    // 2. Create a program and attach the shader
    GLuint program = glCreateProgram();
    if (!program) {
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_GENERAL, "_SituationCreateGLShaderProgramFromSource: Failed to create shader program object");
        glDeleteShader(cs); // Clean up the successfully created shader
        if (error_code) *error_code = SITUATION_ERROR_OPENGL_GENERAL;
        return 0;
    }

    glAttachShader(program, cs);
    glLinkProgram(program);

    // 3. Shader is linked, we no longer need the individual shader object
    glDeleteShader(cs);
    cs = 0; // Good practice

    // 4. Check for linking errors
    GLint success = 0;
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (!success) {
        GLint log_length = 0;
        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &log_length);
        // Handle potential glGetProgramiv failure? Unlikely, but glGetError could check.
        if (log_length > 0) {
            char* infoLog = (char*)malloc((size_t)log_length);
            if (infoLog) {
                glGetProgramInfoLog(program, log_length, NULL, infoLog);
                _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_SHADER_LINK, infoLog);
                free(infoLog);
            } else {
                _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "_SituationCreateGLShaderProgramFromSource: Failed to allocate memory for shader link log.");
            }
        } else {
            _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_SHADER_LINK, "_SituationCreateGLShaderProgramFromSource: An unknown linking error occurred (no log available).");
        }
        glDeleteProgram(program); // Clean up the unsuccessfully linked program
        program = 0;
        if (error_code) *error_code = SITUATION_ERROR_OPENGL_SHADER_LINK;
        return 0;
    }

    // Success path for this helper
    if (error_code) *error_code = SITUATION_SUCCESS;
    return program;
}

/**
 * @brief [INTERNAL] Creates a single-stage OpenGL compute program, dispatching to the optimal creation path.
 * @details This function acts as a high-level dispatcher for creating OpenGL compute shaders.
 *          It intelligently selects the best method—either using modern, pre-compiled SPIR-V bytecode or falling back to traditional GLSL source compilation—based on the type of data provided and the capabilities of the current OpenGL driver.
 *
 * @par Dispatch Logic
 *   - If `source_type` is `SITUATION_GL_SHADER_SOURCE_TYPE_SPIRV` and the `GL_ARB_gl_spirv` extension is available, it calls `_SituationCreateGLComputeProgramFromSpirv` for the fastest and most consistent creation path.
 *   - Otherwise, if `source_type` is `SITUATION_GL_SHADER_SOURCE_TYPE_GLSL`, it calls `_SituationCreateGLShaderProgramFromSource` to perform traditional compilation and linking.
 *   - If SPIR-V data is provided but the driver does not support it, the function will fail and report an error.
 *
 * @param source_data A pointer to the shader data. This must be a `const struct _SituationSpirvBlob*` for SPIR-V or a `const char*` for GLSL.
 * @param source_type An enum (`SituationGLShaderSourceType`) specifying whether `source_data` points to GLSL or SPIR-V.
 * @param[out] error_code A pointer to a `SituationError` variable that will be filled with a specific error code on failure. Can be `NULL`.
 *
 * @return The OpenGL program ID (`GLuint`) on successful creation and linking.
 * @return `0` on failure. On failure, a detailed error message is set by one of the internal helper functions.
 *
 * @note This is the sole entry point for all internal OpenGL compute shader creation and is called by `SituationCreateComputePipelineFromMemory`.
 * @warning The caller is responsible for deleting the returned program ID using `glDeleteProgram`.
 *
 * @see SituationCreateComputePipelineFromMemory(), _SituationCreateGLComputeProgramFromSpirv(), _SituationCreateGLShaderProgramFromSource()
 */
static GLuint _SituationCreateGLComputeProgram(const void* source_data, SituationGLShaderSourceType source_type, SituationError* error_code) {
    if (error_code) *error_code = SITUATION_SUCCESS;

    if (!source_data) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "_SituationCreateGLComputeProgram: Shader source data cannot be NULL.");
        if (error_code) *error_code = SITUATION_ERROR_INVALID_PARAM;
        return 0;
    }

#if defined(SITUATION_ENABLE_SHADER_COMPILER)
    // If we have SPIR-V data and the driver supports it, use the modern path.
    if (source_type == SITUATION_GL_SHADER_SOURCE_TYPE_SPIRV && GLAD_GL_ARB_gl_spirv) {
        return _SituationCreateGLComputeProgramFromSpirv((const struct _SituationSpirvBlob*)source_data, error_code);
    }
#endif

    // Fallback to the traditional GLSL source path in all other cases.
    if (source_type == SITUATION_GL_SHADER_SOURCE_TYPE_GLSL) {
        return _SituationCreateGLShaderProgramFromSource((const char*)source_data, error_code);
    }

    // If we get here, it means we were given SPIR-V but couldn't use it (either compiler is off or driver lacks support).
    _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_UNSUPPORTED, "Received SPIR-V data, but cannot process it (GL_ARB_gl_spirv unavailable or shader compiler disabled).");
    if (error_code) *error_code = SITUATION_ERROR_OPENGL_UNSUPPORTED;
    return 0;
}
#endif

/**
 * @brief Creates a compute pipeline directly from GLSL source code provided as a C string in memory.
 *
 * @details This function compiles the provided GLSL compute shader source code into SPIR-V bytecode (if the shader compiler is enabled) and then creates the corresponding backend-specific compute pipeline object (e.g., OpenGL program, Vulkan pipeline).
 *          The resulting `SituationComputePipeline` handle can be used with `SituationCmdBindComputePipeline` and `SituationCmdDispatch` to execute compute work on the GPU.
 *
 * @param compute_shader_source A null-terminated string containing the GLSL compute shader source code. Must not be NULL.
 *
 * @return A `SituationComputePipeline` handle.
 *         - On **success**: The handle's `.id` member will be non-zero, and it can be used for binding and dispatching. The caller is responsible for destroying it using `SituationDestroyComputePipeline()` to prevent resource leaks.
 *         - On **failure**: The handle will be in an invalid state (`.id` == 0). A detailed error message can be retrieved using `SituationGetLastErrorMsg()`.
 *
 * @note This function requires the library to be initialized (`SituationInit()` must have been called successfully).
 * @note This function requires the `SITUATION_ENABLE_SHADER_COMPILER` define to be set during compilation for the Vulkan backend to work with GLSL source. For OpenGL, it depends on the internal handling of GLSL vs SPIR-V (as discussed in `_SituationCreateGLComputeProgram`).
 * @warning This function is not thread-safe and must be called from the main thread that initialized the library.
 *
 * @par Resource Tracking and Potential Leaks:
 * If this function succeeds (returns a handle with `.id != 0`), the underlying GPU resources are valid.
 * However, an internal CPU memory allocation for resource tracking might fail. In this rare case:
 * - A warning will be printed to `stderr` (e.g., "WARNING: Potential leak of Vulkan compute pipeline handle...").
 * - The valid GPU resource handle is still returned.
 * - It is the caller's **absolute responsibility** to call `SituationDestroyComputePipeline()` on the returned handle to prevent a GPU resource leak, as the library's automatic shutdown cleanup will not track this specific resource.
 *
 * @see SituationCreateComputePipeline()
 * @see SituationDestroyComputePipeline()
 * @see SituationCmdBindComputePipeline()
 * @see SituationCmdDispatch()
 */
SITAPI SituationComputePipeline SituationCreateComputePipelineFromMemory(const char* compute_shader_source, SituationComputeLayoutType layout_type) {
    SituationComputePipeline pipeline = {0}; // Always initialize to an invalid state.

    // --- 1. Pre-condition Checks ---
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "SituationCreateComputePipelineFromMemory: Library not initialized.");
        return pipeline; // Return invalid pipeline
    }

    if (!compute_shader_source) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "SituationCreateComputePipelineFromMemory: Compute shader source cannot be NULL.");
        return pipeline; // Return invalid pipeline
    }

    // --- 2. Backend-Specific Pipeline Creation ---
#if defined(SITUATION_USE_OPENGL)
    SituationError err = SITUATION_SUCCESS;

    // --- Dispatch to OpenGL Creation Helper ---
    // Pass the source and explicitly state it's GLSL.
    // The refactored _SituationCreateGLComputeProgram handles internal logic, including checking sit_gs.gl.arb_gl_spirv_available if it receives SPIR-V internally.
    pipeline.gl_program_id = _SituationCreateGLComputeProgram(
        (const void*)compute_shader_source, // Cast source string to generic pointer
        SITUATION_GL_SHADER_SOURCE_TYPE_GLSL, // Explicitly tell the function the type of data
        &err
    );

    if (err == SITUATION_SUCCESS && pipeline.gl_program_id != 0) { // Extra check for robustness
        // Assign the public ID (using the GL program ID directly is common)
        pipeline.id = pipeline.gl_program_id;

        // --- Resource Tracking for OpenGL ---
        _SituationComputePipelineNode* node = (_SituationComputePipelineNode*)malloc(sizeof(_SituationComputePipelineNode));
        if (node) {
            node->pipeline = pipeline;
            node->next = sit_gs.all_compute_pipelines;
            sit_gs.all_compute_pipelines = node;
            // Optional: node->was_spirv_used = false; // Since we passed GLSL directly
        } else {
            _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "SituationCreateComputePipelineFromMemory: Failed to allocate resource tracking node for OpenGL compute pipeline.");
            // Log warning about potential leak due to tracking failure
            fprintf(stderr, "WARNING: Potential leak of OpenGL compute program ID %u due to tracking node allocation failure.\n", pipeline.gl_program_id);
            // Returning the valid pipeline is acceptable, the user MUST call SituationDestroyComputePipeline.
            // If strict no-leak policy is required even on tracking failure, you'd call SituationDestroyComputePipeline(&pipeline) here and return {0}.
        }
        // Success path: pipeline struct is valid with .id and .gl_program_id set.
    } else {
        // Error occurred during OpenGL program creation.
        // _SituationCreateGLComputeProgram should have set a detailed error message.
        // The pipeline struct remains {0}, which is the correct invalid state to return.
        // No need for explicit cleanup here as gl_program_id should be 0 on failure.
        // Error message is already set.
    }

#elif defined(SITUATION_USE_VULKAN)
    // The Vulkan backend requires the shader compiler to be enabled to handle GLSL source.
    #if !defined(SITUATION_ENABLE_SHADER_COMPILER)
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_IMPLEMENTED, "Vulkan backend requires SITUATION_ENABLE_SHADER_COMPILER to create pipelines from source code.");
        return pipeline; // Return the invalid (zeroed) pipeline handle
    #else

    // 1. --- Compile GLSL source to SPIR-V bytecode ---
    _SituationSpirvBlob cs_spirv = _SituationVulkanCompileGLSLtoSPIRV(compute_shader_source, "compute.comp", shaderc_compute_shader);

    // If compilation fails, the helper function sets the error and returns an empty blob.
    if (cs_spirv.data == NULL) {
        // No need to set an error here; it's already done by the compiler helper.
        return pipeline; // Return the invalid (zeroed) pipeline handle
    }

    // 2. --- Select the pre-created Pipeline Layout ---
    // Validate the user-provided layout type to prevent out-of-bounds access.
    if (layout_type < 0 || layout_type >= (sizeof(sit_gs.vk.compute_layouts) / sizeof(sit_gs.vk.compute_layouts[0]))) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "An invalid SituationComputeLayoutType was specified.");
        _SituationFreeSpirvBlob(&cs_spirv); // Clean up the compiled SPIR-V
        return pipeline;
    }
    VkPipelineLayout selected_layout = sit_gs.vk.compute_layouts[layout_type];

    // 3. --- Create the Vulkan Pipeline from SPIR-V and the selected layout ---
    pipeline = _SituationVulkanCreateComputePipeline(cs_spirv.data, cs_spirv.size, selected_layout);

    // Always free the temporary SPIR-V blob now that it has been consumed by the pipeline creation.
    _SituationFreeSpirvBlob(&cs_spirv);

    // 4. --- Handle Creation Result and Resource Tracking ---
    if (pipeline.vk_pipeline != VK_NULL_HANDLE) {
        // Success: The pipeline and layout handles are valid.
        
        // Assign a unique public ID for the resource manager.
        pipeline.id = (uint64_t)(uintptr_t)pipeline.vk_pipeline; // Using 64-bit ID

        // Add the new pipeline to the internal tracking list for leak detection.
        _SituationComputePipelineNode* node = (_SituationComputePipelineNode*)malloc(sizeof(_SituationComputePipelineNode));
        if (node) {
            node->pipeline = pipeline;
            node->next = sit_gs.all_compute_pipelines;
            sit_gs.all_compute_pipelines = node;
        } else {
            // This is a non-fatal but serious issue: the GPU resource was created
            // but we failed to track it. We warn the user they are now responsible for cleanup.
            _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Failed to allocate resource tracking node for compute pipeline.");
            fprintf(stderr,
                "SITUATION WARNING: GPU compute pipeline created successfully but failed to add to resource tracker.\n"
                "         This is a potential memory leak. You MUST call SituationDestroyComputePipeline() on the returned handle to free GPU resources.\n");
        }
    }
    // If _SituationVulkanCreateComputePipeline failed, it returned a zeroed 'pipeline' struct and set the error.
    // There is nothing more to do here; we simply return the invalid handle.

    return pipeline;

    #endif // SITUATION_ENABLE_SHADER_COMPILER
#else
    // Unsupported backend
    _SituationSetErrorFromCode(SITUATION_ERROR_NOT_IMPLEMENTED, "SituationCreateComputePipelineFromMemory: Unsupported graphics backend.");
    // Return invalid pipeline (already {0})
#endif // SITUATION_USE_OPENGL / SITUATION_USE_VULKAN

    // --- 3. Return Result ---
    // Return the (potentially valid) pipeline handle.
    // If valid, .id will be non-zero.
    // If invalid, .id will be zero, and an error message will be set.
    return pipeline;
}

/**
 * @brief Creates a compute pipeline by loading GLSL source code from a file.
 *
 * @details This function is a convenience wrapper around `SituationCreateComputePipelineFromMemory`. It loads the GLSL compute shader source code from the specified file path into memory and then uses that string to create the compute pipeline using the standard process.
 *
 * @param compute_shader_path The file system path to the GLSL compute shader source file (e.g., "shaders/compute_filter.comp"). This path must be valid and accessible.
 *
 * @return A `SituationComputePipeline` handle.
 *         - On **success**, the handle's `id` member will be non-zero, and it can be used with functions like `SituationCmdBindComputePipeline` and `SituationDestroyComputePipeline`.
 *         - On **failure** (e.g., file not found, read error, compilation error, pipeline creation failure), the handle will be zero-initialized (`{0}`). Use `SituationGetLastErrorMsg()` to retrieve a detailed error message.
 *
 * @note This function requires the library to be successfully initialized  (`SituationInit` must have been called).
 * @note This function requires `SITUATION_ENABLE_SHADER_COMPILER` to be defined if runtime compilation of GLSL to SPIR-V is needed (which is the standard process for Vulkan and often for OpenGL).
 * @note The caller is responsible for eventually destroying the returned pipeline using `SituationDestroyComputePipeline` to prevent GPU and CPU memory leaks.
 *
 * @see SituationCreateComputePipelineFromMemory(), SituationDestroyComputePipeline(), SituationLoadFileText()
 */
SITAPI SituationComputePipeline SituationCreateComputePipeline(const char* compute_shader_path) {
    // --- 1. Input Validation ---
    SituationComputePipeline pipeline = {0}; // Initialize to invalid state

    if (!sit_gs.is_initialized) { _SituationSetErrorFromCode( SITUATION_ERROR_NOT_INITIALIZED, "SituationCreateComputePipeline: Cannot create pipeline, library not initialized." ); return pipeline; } // Return invalid pipeline
    if (!compute_shader_path) { _SituationSetErrorFromCode( SITUATION_ERROR_INVALID_PARAM, "SituationCreateComputePipeline: compute_shader_path cannot be NULL." ); return pipeline; } // Return invalid pipeline

    // --- 2. Load Shader Source from File ---
    // Use the library's built-in function to load the text content of the file.
    // This function handles file opening, reading, and null-termination.
    char* source = SituationLoadFileText(compute_shader_path);

    if (!source) {
        // SituationLoadFileText should have set a specific error message (e.g., file not found, permission denied) in sit_gs.last_error_msg.
        // We can add a prefix to make the context clearer.
        char prefixed_error[SITUATION_MAX_ERROR_MSG_LEN];
        snprintf( prefixed_error, sizeof(prefixed_error), "SituationCreateComputePipeline: Failed to load shader file '%s'. Reason: %s", compute_shader_path, SituationGetLastErrorMsg() ); // Get the error set by SituationLoadFileText
        _SituationSetError(prefixed_error); // Update the global error message
        // pipeline is already {0}, so we just return it.
        return pipeline;
    }

    // --- 3. Create Pipeline from Loaded Source ---
    // Delegate the actual pipeline creation (compilation, backend object creation) to the memory-based function.
    pipeline = SituationCreateComputePipelineFromMemory(source);

    // --- 4. Cleanup Temporary Source ---
    // Free the memory allocated by SituationLoadFileText.
    free(source);
    source = NULL; // Defensive nulling

    // --- 5. Return Result ---
    // The `pipeline` struct is returned. It will be valid (id != 0) on success, or invalid (id == 0) on failure, with the error state set appropriately
    // by SituationCreateComputePipelineFromMemory.
    return pipeline;
}

// --- Updated/Added Documentation Block for SituationDestroyComputePipeline ---
/**
 * @brief Destroys a compute pipeline and frees all associated resources.
 *
 * @details This function cleans up the resources acquired during the creation of a `SituationComputePipeline`. This includes backend-specific objects
 *          (e.g., OpenGL program, Vulkan pipeline/layout) and removing the pipeline from the library's internal resource tracking list.
 *          It is crucial to call this function for every successfully created `SituationComputePipeline` to prevent memory leaks of both GPU resources and CPU-side tracking structures.
 *
 * @param pipeline A pointer to the `SituationComputePipeline` handle to be destroyed. The handle's `id` member must be non-zero.
 *                 The contents of the struct pointed to by `pipeline` will be zeroed upon successful destruction.
 *
 * @note It is safe to call this function on an already destroyed or invalid pipeline (where `pipeline->id` is 0); it will simply do nothing.
 * @note This function internally waits for the GPU to be idle (Vulkan:
 *       `vkDeviceWaitIdle`, OpenGL: potentially implied by driver) before destroying resources to ensure safety.
 * @warning This function must only be called before `SituationShutdown`.
 * @warning After calling this function, the `SituationComputePipeline` handle pointed to by `pipeline` becomes invalid and must not be used again.
 *
 * @see SituationCreateComputePipeline(), SituationCreateComputePipelineFromMemory()
 */
SITAPI void SituationDestroyComputePipeline(SituationComputePipeline* pipeline) {
    // --- 1. Input Validation ---
    // Check if the pipeline pointer is valid and if the pipeline has been created.
    if (!pipeline || pipeline->id == 0) {
        // Silently succeed if trying to destroy an invalid/null pipeline.
        // This is a common and safe pattern.
        return;
    }

    // --- 2. Resource Manager: Remove from Tracking List ---
    // Find and remove the node corresponding to this pipeline ID from the global linked list `sit_gs.all_compute_pipelines`.
    _SituationComputePipelineNode* current = sit_gs.all_compute_pipelines;
    _SituationComputePipelineNode* prev = NULL;

    while (current != NULL) {
        if (current->pipeline.id == pipeline->id) {
            // Found the node to remove.
            if (prev) {
                // Node is in the middle or end of the list.
                prev->next = current->next;
            } else {
                // Node is the head of the list.
                sit_gs.all_compute_pipelines = current->next;
            }
            // Free the memory allocated for the tracking node itself.
            free(current);
            current = NULL; // Defensive nulling (optional)
            // Break after removal, assuming IDs are unique.
            break;
        }
        // Move to the next node in the list.
        prev = current;
        current = current->next;
    }
    // If the loop completes without finding the ID, it indicates an inconsistency (pipeline exists but isn't tracked), but proceeding with backend destruction is still the correct action for the resource itself.

    // --- 3. Backend-Specific Destruction ---
#if defined(SITUATION_USE_OPENGL)
    {
        // --- OpenGL Destruction ---
        // Check if the program ID appears to be a valid OpenGL name before deleting.
        // This is a good defensive practice, though glDeleteProgram is safe with 0.
        if (glIsProgram(pipeline->gl_program_id)) {
            glDeleteProgram(pipeline->gl_program_id);
            // Note: SIT_CHECK_GL_ERROR() could be used here, but glDeleteProgram rarely generates errors for valid IDs. Omitting for brevity, but could be added if robustness is paramount.
        }
        // Reset OpenGL-specific members
        pipeline->gl_program_id = 0;
        // Note: Other potential members like uniform locations are just data, not GPU objects, so no specific cleanup is needed beyond memset.
    }

#elif defined(SITUATION_USE_VULKAN)
    {
        // --- Vulkan Destruction ---
        // Critical: Ensure the GPU is finished using any resources associated with this pipeline before we destroy them.
        // Waiting for the entire device to be idle is the simplest and safest way, though potentially not the most performant for frequent destructions.
        // A more advanced system might use fences associated with the last use of the pipeline.
        if (sit_gs.vk.device != VK_NULL_HANDLE) { // Defensive check
            VkResult wait_result = vkDeviceWaitIdle(sit_gs.vk.device);
            if (wait_result != VK_SUCCESS) {
                // Log error? The device might be in a bad state.
                fprintf(
                    stderr,
                    "WARNING: vkDeviceWaitIdle failed (0x%x) during compute pipeline destruction (ID: %u).\n",
                    wait_result,
                    pipeline->id
                );
                // Proceeding to destroy resources to prevent leaks, despite potential issues.
            }
        }

        // --- Use Internal Helper for Complete Cleanup ---
        // The original code manually destroyed vk_pipeline and vk_pipeline_layout.
        // However, the internal helper `_SituationVulkanDestroyComputePipeline` is designed to handle the *complete* destruction of a compute pipeline,
        // including the VkShaderModule which was missing from the manual code.
        // This centralizes the Vulkan cleanup logic and ensures nothing is missed.
        // Pass the internal struct containing the Vulkan handles.
        // Assuming the SituationComputePipeline struct contains an internal struct like _SituationComputePipeline (as seen in snippets) or the handles directly.
        // The helper function signature is:
        // static void _SituationVulkanDestroyComputePipeline(_SituationComputePipeline* pipeline);
        //
        // We need to pass the internal data. If `SituationComputePipeline` directly holds `vk_pipeline`, `vk_pipeline_layout`, `vk_shader_module`, the helper
        // might take `pipeline`. If it holds an internal struct, we pass that.
        // Based on typical patterns and the helper's signature, it likely takes a pointer to the struct containing the Vk* handles.
        // Let's assume `SituationComputePipeline` is the struct the helper expects, or it contains the necessary Vk members directly.
        // The helper will set handles to VK_NULL_HANDLE internally.
        _SituationVulkanDestroyComputePipeline(pipeline);

        // Reset Vulkan-specific members (if not done by the helper, or for clarity)
        // If the helper correctly nullifies them, this is redundant but safe.
        // pipeline->vk_pipeline = VK_NULL_HANDLE;
        // pipeline->vk_pipeline_layout = VK_NULL_HANDLE;
        // pipeline->vk_shader_module = VK_NULL_HANDLE; // Assuming this member exists
    }
#endif

    // --- 4. Invalidate the User-Facing Handle ---
    // Zero out the entire user-facing struct to invalidate it and prevent accidental reuse. This also resets the `id` to 0.
    memset(pipeline, 0, sizeof(SituationComputePipeline));
    // After this call, pipeline->id is 0, indicating it's no longer valid.
}

// --- Final resource cleanup function ---
static void _SituationCleanupDanglingResources(void) {
    // This function is called during shutdown to clean up any resources the user forgot to destroy.
    // It iterates through the tracking lists and frees everything, logging warnings.
    
    // Clean up Meshes
    while (sit_gs.all_meshes != NULL) {
        fprintf(stderr, "SITUATION WARNING: Leaked SituationMesh (ID: %u). Automatically cleaning up.\n", sit_gs.all_meshes->mesh.id);
        // Note: The Destroy function will internally remove the node from the list, advancing the head.
        SituationDestroyMesh(&sit_gs.all_meshes->mesh);
    }

    // Clean up Graphics Shaders
    while (sit_gs.all_shaders != NULL) {
        fprintf(stderr, "SITUATION WARNING: Leaked SituationShader (ID: %u). Automatically cleaning up.\n", sit_gs.all_shaders->shader.id);
        SituationUnloadShader(&sit_gs.all_shaders->shader);
    }

    // Clean up Compute Pipelines
    while (sit_gs.all_compute_pipelines != NULL) {
        fprintf(stderr, "SITUATION WARNING: Leaked SituationComputePipeline (ID: %u). Automatically cleaning up.\n", sit_gs.all_compute_pipelines->pipeline.id);
        SituationDestroyComputePipeline(&sit_gs.all_compute_pipelines->pipeline);
    }

    // Clean up Textures
    while (sit_gs.all_textures != NULL) {
        fprintf(stderr, "SITUATION WARNING: Leaked SituationTexture (ID: %u). Automatically cleaning up.\n", sit_gs.all_textures->texture.id);
        SituationDestroyTexture(&sit_gs.all_textures->texture);
    }

    // Clean up Buffers
    while (sit_gs.all_buffers != NULL) {
        fprintf(stderr, "SITUATION WARNING: Leaked SituationBuffer (ID: %u). Automatically cleaning up.\n", sit_gs.all_buffers->buffer.id);
        SituationDestroyBuffer(&sit_gs.all_buffers->buffer);
    }
    
    // Virtual Displays are in a static array, so we can just loop through them.
    for (int i = 0; i < SITUATION_MAX_VIRTUAL_DISPLAYS; ++i) {
        if (sit_gs.virtual_display_slots_used[i]) {
            fprintf(stderr, "SITUATION WARNING: Leaked SituationVirtualDisplay (ID: %d). Automatically cleaning up.\n", i);
            SituationDestroyVirtualDisplay(i);
        }
    }
}


/**
 * @brief Updates a region of data within an existing GPU buffer.
 *
 * @details Replaces a specified range of data within a GPU buffer with new data provided by the user. This is the primary method for dynamically updating buffer contents (e.g., updating a Uniform Buffer with per-frame camera data, or modifying data for a compute shader).
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Uses `glNamedBufferSubData` to directly update the buffer's data store. This requires the buffer to have been created with flags allowing updates (e.g., `GL_DYNAMIC_STORAGE_BIT`).
 * - **Vulkan:** Updating GPU-local memory (`VMA_MEMORY_USAGE_GPU_ONLY`) requires a staging buffer. This function internally allocates a temporary staging buffer, copies the user's `data` into it, and then uses a one-time command buffer to record and submit a `vkCmdCopyBuffer`
 *   command. This efficiently transfers the new data from CPU-visible staging memory to the target GPU-local buffer. The function waits for the transfer to complete before returning, making it a synchronous operation.
 *
 * @param buffer The `SituationBuffer` handle of the buffer to update.
 * @param offset The byte offset within the GPU buffer where the update will begin.
 * @param size The number of bytes to update.
 * @param data A pointer to the new data on the host (CPU) side.
 *
 * @return SITUATION_SUCCESS on successful update.
 * @return SITUATION_ERROR_NOT_INITIALIZED if the library is not initialized.
 * @return SITUATION_ERROR_RESOURCE_INVALID if the buffer handle is invalid.
 * @return SITUATION_ERROR_INVALID_PARAM if `data` is NULL.
 * @return SITUATION_ERROR_BUFFER_INVALID_SIZE if `offset + size` exceeds the buffer's size.
 * @return SITUATION_ERROR_BUFFER_MAP_FAILED if mapping memory fails temporarily (rare, Vulkan staging path).
 * @return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED if creating a staging buffer fails (Vulkan).
 * @return SITUATION_ERROR_VULKAN_COMMAND_FAILED if recording or submitting the copy command fails (Vulkan).
 * @return SITUATION_ERROR_OPENGL_GENERAL if the OpenGL driver reports an error during the update.
 *
 * @note The buffer must have been created with usage flags that permit updates
 *       (e.g., `SITUATION_BUFFER_USAGE_UNIFORM_BUFFER`, `SITUATION_BUFFER_USAGE_STORAGE_BUFFER`, `SITUATION_BUFFER_USAGE_TRANSFER_DST`).
 */
SITAPI SituationError SituationUpdateBuffer(SituationBuffer buffer, size_t offset, size_t size, const void* data) {
    // --- 1. Pre-Operation Validation ---
    if (!sit_gs.is_initialized) {
        return SITUATION_ERROR_NOT_INITIALIZED;
    }
    if (buffer.id == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_RESOURCE_INVALID, "Attempted to update an invalid buffer.");
        return SITUATION_ERROR_RESOURCE_INVALID;
    }
    if (!data) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Data pointer for buffer update is NULL.");
        return SITUATION_ERROR_INVALID_PARAM;
    }
    if (size == 0) {
        // Updating 0 bytes is technically valid, but often a logic error.
        // Alternatively, return SITUATION_SUCCESS immediately.
        return SITUATION_SUCCESS;
    }
    if ((offset + size) > buffer.size_in_bytes) {
        _SituationSetErrorFromCode(SITUATION_ERROR_BUFFER_INVALID_SIZE, "Update range exceeds buffer size.");
        return SITUATION_ERROR_BUFFER_INVALID_SIZE;
    }

#if defined(SITUATION_USE_OPENGL)
    {
        // --- 2. OpenGL Implementation ---
        glNamedBufferSubData(buffer.gl_buffer_id, (GLintptr)offset, (GLsizeiptr)size, data);
        SIT_CHECK_GL_ERROR();
        if (sit_gs.gl.last_error != GL_NO_ERROR) {
            // Error message likely set by SIT_CHECK_GL_ERROR
            return SITUATION_ERROR_OPENGL_GENERAL; // Or a more specific OpenGL error if available
        }
        return SITUATION_SUCCESS;
    }

#elif defined(SITUATION_USE_VULKAN)
    {
        // --- 2. Vulkan Implementation (Using Staging Buffer for GPU_LOCAL Memory) ---
        VkDevice device = sit_gs.vk.device;
        VmaAllocator allocator = sit_gs.vk.vma_allocator;

        // 2.1. Handle Directly Mappable Buffers (e.g., CPU_TO_GPU)
        // First, check if the buffer's memory is host-visible/coherent.
        VmaAllocationInfo alloc_info;
        vmaGetAllocationInfo(allocator, buffer.vma_allocation, &alloc_info);

        if ((alloc_info.memoryTypeBits & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) &&
            (alloc_info.memoryTypeBits & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)) {
            // Memory is host-visible and coherent, we can map it directly and update.
            void* mapped_data;
            VkResult result = vmaMapMemory(allocator, buffer.vma_allocation, &mapped_data);
            if (result != VK_SUCCESS) {
                _SituationSetErrorFromCode(SITUATION_ERROR_BUFFER_MAP_FAILED, "Failed to map Vulkan buffer memory for direct update.");
                return SITUATION_ERROR_BUFFER_MAP_FAILED;
            }
            memcpy((char*)mapped_data + offset, data, size);
            vmaUnmapMemory(allocator, buffer.vma_allocation);
            return SITUATION_SUCCESS;
        } else {
            // 2.2. Handle Non-Mappable Buffers (e.g., GPU_ONLY) - Use Staging Buffer
            // This is the more common and robust path for performance-oriented buffers.

            // --- a. Create Staging Buffer (Host Visible) ---
            VkBuffer staging_buffer;
            VmaAllocation staging_allocation;

            // Create a temporary, host-visible staging buffer for the upload
            VkBufferCreateInfo staging_buffer_info = { .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, .size = size, .usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT };
            VmaAllocationCreateInfo staging_alloc_info = { .usage = VMA_MEMORY_USAGE_CPU_TO_GPU };
            
            // Ensure it's host visible for mapping
            staging_alloc_info.requiredFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;

            VkResult result = vmaCreateBuffer(allocator, &staging_buffer_info, &staging_alloc_info, &staging_buffer, &staging_allocation, NULL);
            if (result != VK_SUCCESS) {
                _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED, "Failed to create staging buffer for buffer update.");
                return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED;
            }

            // --- b. Map Staging Buffer and Copy Data ---
            void* mapped_data;
            result = vmaMapMemory(allocator, staging_allocation, &mapped_data);
            if (result != VK_SUCCESS) {
                vmaDestroyBuffer(allocator, staging_buffer, staging_allocation);
                _SituationSetErrorFromCode(SITUATION_ERROR_BUFFER_MAP_FAILED, "Failed to map staging buffer for buffer update.");
                return SITUATION_ERROR_BUFFER_MAP_FAILED;
            }
            memcpy(mapped_data, data, size); // Copy user data to staging buffer
            vmaUnmapMemory(allocator, staging_allocation);

            // --- c. Record Copy Command ---
            // Acquire a temporary command buffer for the transfer.
            // Using a dedicated utility command pool/buffer is more efficient for frequent transfers, but this works for general use.
            VkCommandBuffer transfer_cmd = VK_NULL_HANDLE;
            VkCommandBufferAllocateInfo alloc_info_cmd = {0};
            alloc_info_cmd.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
            alloc_info_cmd.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
            alloc_info_cmd.commandPool = sit_gs.vk.command_pool; // Assuming main pool can be used
            alloc_info_cmd.commandBufferCount = 1;
            result = vkAllocateCommandBuffers(device, &alloc_info_cmd, &transfer_cmd);
            if (result != VK_SUCCESS) {
                vmaDestroyBuffer(allocator, staging_buffer, staging_allocation);
                _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to allocate temporary command buffer for buffer update.");
                return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
            }

            VkCommandBufferBeginInfo begin_info = {0};
            begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
            begin_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
            result = vkBeginCommandBuffer(transfer_cmd, &begin_info);
            if (result != VK_SUCCESS) {
                vkFreeCommandBuffers(device, sit_gs.vk.command_pool, 1, &transfer_cmd);
                vmaDestroyBuffer(allocator, staging_buffer, staging_allocation);
                _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to begin temporary command buffer for buffer update.");
                return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
            }

            // *** CRITICAL SYNCHRONIZATION BARRIER ***
            // Insert a barrier to ensure any previous shader reads from the destination buffer are complete before we begin writing to it.
            VkBufferMemoryBarrier barrier = {};
            barrier.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
            barrier.srcAccessMask = VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_INDIRECT_COMMAND_READ_BIT | VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT;
            barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
            barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
            barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
            barrier.buffer = buffer.vk_buffer;
            barrier.offset = offset;
            barrier.size = size;

            vkCmdPipelineBarrier(
                transfer_cmd,
                VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT | VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, // Wait for any prior shader stage
                VK_PIPELINE_STAGE_TRANSFER_BIT,                                           // Before the transfer stage begins
                0, 0, NULL, 1, &barrier, 0, NULL
            );

            VkBufferCopy copy_region = {};
            copy_region.srcOffset = 0; // Data starts at beginning of staging buffer
            copy_region.dstOffset = offset; // Copy to specified offset in target buffer
            copy_region.size = size;
            vkCmdCopyBuffer(transfer_cmd, staging_buffer, buffer.vk_buffer, 1, &copy_region);

            result = vkEndCommandBuffer(transfer_cmd);
            if (result != VK_SUCCESS) {
                vkFreeCommandBuffers(device, sit_gs.vk.command_pool, 1, &transfer_cmd);
                vmaDestroyBuffer(allocator, staging_buffer, staging_allocation);
                _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to end temporary command buffer for buffer update.");
                return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
            }

            // --- d. Submit Copy Command & Wait ---
            VkSubmitInfo submit_info = {0};
            submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
            submit_info.commandBufferCount = 1;
            submit_info.pCommandBuffers = &transfer_cmd;

            // Submit to the graphics queue and wait for completion.
            // This is a synchronous, blocking operation.
            result = vkQueueSubmit(sit_gs.vk.graphics_queue, 1, &submit_info, VK_NULL_HANDLE);
            if (result != VK_SUCCESS) {
                vkFreeCommandBuffers(device, sit_gs.vk.command_pool, 1, &transfer_cmd);
                vmaDestroyBuffer(allocator, staging_buffer, staging_allocation);
                _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to submit buffer update command.");
                return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
            }

            result = vkQueueWaitIdle(sit_gs.vk.graphics_queue); // Wait for the copy to finish
            if (result != VK_SUCCESS) {
                vkFreeCommandBuffers(device, sit_gs.vk.command_pool, 1, &transfer_cmd);
                vmaDestroyBuffer(allocator, staging_buffer, staging_allocation);
                _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to wait for buffer update command to finish.");
                return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
            }

            // --- e. Cleanup Temporary Resources ---
            vkFreeCommandBuffers(device, sit_gs.vk.command_pool, 1, &transfer_cmd);
            vmaDestroyBuffer(allocator, staging_buffer, staging_allocation);

            return SITUATION_SUCCESS;
        }
    }
#endif // SITUATION_USE_VULKAN

    // Should not be reached, but included for completeness
    return SITUATION_ERROR_NOT_IMPLEMENTED;
}

/**
 * @brief Reads data back from a GPU buffer to host memory.
 *
 * @details Copies a specified range of data from the GPU buffer into a user-provided host memory buffer. This is useful for debugging, reading results from compute shaders, or retrieving data generated on the GPU.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Uses `glGetNamedBufferSubData` to read data directly from the buffer object into host memory, provided the buffer was created with appropriate flags (e.g., `GL_DYNAMIC_STORAGE_BIT` or `GL_MAP_READ_BIT` implicitly via usage).
 * - **Vulkan:** Reading from GPU-local memory (`VMA_MEMORY_USAGE_GPU_ONLY`) requires a staging buffer. This function internally allocates a temporary staging buffer, copies the data from the source buffer to the staging buffer using a command,
 *   and then maps the staging buffer to copy the data to the user's `out_data` pointer.
 *   This process is asynchronous and requires waiting for the GPU to finish the copy.
 *
 * @param buffer The `SituationBuffer` handle to read data from.
 * @param offset The byte offset within the GPU buffer to start reading from.
 * @param size The number of bytes to read.
 * @param[out] out_data A pointer to the host memory buffer where the data will be written.
 *                      This buffer must be allocated by the caller and large enough to hold `size` bytes.
 *
 * @return SITUATION_SUCCESS on successful read.
 * @return SITUATION_ERROR_NOT_INITIALIZED if the library is not initialized.
 * @return SITUATION_ERROR_RESOURCE_INVALID if the buffer handle is invalid.
 * @return SITUATION_ERROR_INVALID_PARAM if `out_data` is NULL.
 * @return SITUATION_ERROR_BUFFER_INVALID_SIZE if `offset + size` exceeds the buffer's size.
 * @return SITUATION_ERROR_BUFFER_MAP_FAILED if mapping memory fails (Vulkan) or reading fails (OpenGL).
 * @return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED if creating a staging buffer fails (Vulkan).
 * @return SITUATION_ERROR_VULKAN_COMMAND_FAILED if recording or submitting the copy command fails (Vulkan).
 */
SITAPI SituationError SituationGetBufferData(SituationBuffer buffer, size_t offset, size_t size, void* out_data) {
    // --- 1. Pre-Operation Validation ---
    if (!sit_gs.is_initialized) {
        return SITUATION_ERROR_NOT_INITIALIZED;
    }
    if (buffer.id == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_RESOURCE_INVALID, "Attempted to read from an invalid buffer.");
        return SITUATION_ERROR_RESOURCE_INVALID;
    }
    if (!out_data) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Output data pointer is NULL.");
        return SITUATION_ERROR_INVALID_PARAM;
    }
    if (size == 0) {
        // Reading 0 bytes is technically valid, but let's treat it as a potential logic error.
        // Alternatively, return SITUATION_SUCCESS immediately.
        return SITUATION_SUCCESS;
    }
    if ((offset + size) > buffer.size_in_bytes) {
        _SituationSetErrorFromCode(SITUATION_ERROR_BUFFER_INVALID_SIZE, "Read range exceeds buffer size.");
        return SITUATION_ERROR_BUFFER_INVALID_SIZE;
    }

#if defined(SITUATION_USE_OPENGL)
    {
        // --- 2. OpenGL Implementation ---
        glGetNamedBufferSubData(buffer.gl_buffer_id, (GLintptr)offset, (GLsizeiptr)size, out_data);
        SIT_CHECK_GL_ERROR();
        if (sit_gs.gl.last_error != GL_NO_ERROR) {
            // Error message likely set by SIT_CHECK_GL_ERROR
            return SITUATION_ERROR_BUFFER_MAP_FAILED; // Or a more specific OpenGL error if available
        }
        return SITUATION_SUCCESS;
    }

#elif defined(SITUATION_USE_VULKAN)
    {
        // --- 2. Vulkan Implementation (Using Staging Buffer for GPU_LOCAL Memory) ---
        VkDevice device = sit_gs.vk.device;
        VmaAllocator allocator = sit_gs.vk.vma_allocator;

        // 2.1. Handle Directly Mappable Buffers (e.g., CPU_TO_GPU)
        // First, check if the buffer's memory is host-visible/coherent.
        // This requires querying VMA allocation info.
        VmaAllocationInfo alloc_info;
        vmaGetAllocationInfo(allocator, buffer.vma_allocation, &alloc_info);

        if ((alloc_info.memoryTypeBits & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) &&
            (alloc_info.memoryTypeBits & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)) {
            // Memory is host-visible and coherent, we can map it directly.
            void* mapped_data;
            VkResult result = vmaMapMemory(allocator, buffer.vma_allocation, &mapped_data);
            if (result != VK_SUCCESS) {
                _SituationSetErrorFromCode(SITUATION_ERROR_BUFFER_MAP_FAILED, "Failed to map Vulkan buffer memory for reading.");
                return SITUATION_ERROR_BUFFER_MAP_FAILED;
            }
            // Copy data from mapped GPU memory to user's host buffer
            memcpy(out_data, (char*)mapped_data + offset, size);
            vmaUnmapMemory(allocator, buffer.vma_allocation);
            return SITUATION_SUCCESS;
        } else {
            // 2.2. Handle Non-Mappable Buffers (e.g., GPU_ONLY) - Use Staging Buffer
            // This is the more common and robust path.

            // --- a. Create Staging Buffer (Host Visible) ---
            VkBuffer staging_buffer;
            VmaAllocation staging_allocation;

            VkBufferCreateInfo staging_buffer_info = {0};
            staging_buffer_info.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
            staging_buffer_info.size = size;
            staging_buffer_info.usage = VK_BUFFER_USAGE_TRANSFER_DST_BIT;

            VmaAllocationCreateInfo staging_alloc_info = {0};
            staging_alloc_info.usage = VMA_MEMORY_USAGE_CPU_TO_GPU; // Or CPU_ONLY if you need coherent reads
            // Ensure it's host visible for mapping
            staging_alloc_info.requiredFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;

            VkResult result = vmaCreateBuffer(allocator, &staging_buffer_info, &staging_alloc_info, &staging_buffer, &staging_allocation, NULL);
            if (result != VK_SUCCESS) {
                _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED, "Failed to create staging buffer for reading data.");
                return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED;
            }

            // --- b. Record Copy Command ---
            // We need a command buffer to record the copy. Using the current graphics command buffer
            // might be problematic if it's in use or not in the correct state.
            // A safer approach is to use a dedicated single-use command buffer or
            // temporarily acquire one from the pool.
            // For simplicity here, let's assume we can use a temporary command buffer.
            // A more robust system might have a dedicated utility command pool/buffer for such transfers.

            VkCommandBuffer transfer_cmd = VK_NULL_HANDLE;
            // --- Simple way: Allocate a one-time command buffer ---
            VkCommandBufferAllocateInfo alloc_info_cmd = {0};
            alloc_info_cmd.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
            alloc_info_cmd.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
            alloc_info_cmd.commandPool = sit_gs.vk.command_pool; // Assuming main pool can be used
            alloc_info_cmd.commandBufferCount = 1;
            result = vkAllocateCommandBuffers(device, &alloc_info_cmd, &transfer_cmd);
            if (result != VK_SUCCESS) {
                vmaDestroyBuffer(allocator, staging_buffer, staging_allocation);
                _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to allocate temporary command buffer for buffer readback.");
                return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
            }

            VkCommandBufferBeginInfo begin_info = {0};
            begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
            begin_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
            result = vkBeginCommandBuffer(transfer_cmd, &begin_info);
            if (result != VK_SUCCESS) {
                vkFreeCommandBuffers(device, sit_gs.vk.command_pool, 1, &transfer_cmd);
                vmaDestroyBuffer(allocator, staging_buffer, staging_allocation);
                _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to begin temporary command buffer for buffer readback.");
                return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
            }

            VkBufferCopy copy_region = {0};
            copy_region.srcOffset = offset;
            copy_region.dstOffset = 0;
            copy_region.size = size;
            vkCmdCopyBuffer(transfer_cmd, buffer.vk_buffer, staging_buffer, 1, &copy_region);

            result = vkEndCommandBuffer(transfer_cmd);
            if (result != VK_SUCCESS) {
                vkFreeCommandBuffers(device, sit_gs.vk.command_pool, 1, &transfer_cmd);
                vmaDestroyBuffer(allocator, staging_buffer, staging_allocation);
                _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to end temporary command buffer for buffer readback.");
                return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
            }

            // --- c. Submit Copy Command & Wait ---
            VkSubmitInfo submit_info = {0};
            submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
            submit_info.commandBufferCount = 1;
            submit_info.pCommandBuffers = &transfer_cmd;

            // Submit to the graphics queue and wait for completion.
            // This is a synchronous, blocking operation.
            // A more advanced system might use fences for async readbacks.
            result = vkQueueSubmit(sit_gs.vk.graphics_queue, 1, &submit_info, VK_NULL_HANDLE);
            if (result != VK_SUCCESS) {
                vkFreeCommandBuffers(device, sit_gs.vk.command_pool, 1, &transfer_cmd);
                vmaDestroyBuffer(allocator, staging_buffer, staging_allocation);
                _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to submit buffer readback command.");
                return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
            }

            result = vkQueueWaitIdle(sit_gs.vk.graphics_queue); // Wait for the copy to finish
            if (result != VK_SUCCESS) {
                vkFreeCommandBuffers(device, sit_gs.vk.command_pool, 1, &transfer_cmd);
                vmaDestroyBuffer(allocator, staging_buffer, staging_allocation);
                _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_COMMAND_FAILED, "Failed to wait for buffer readback command to finish.");
                return SITUATION_ERROR_VULKAN_COMMAND_FAILED;
            }

            // Clean up the temporary command buffer
            vkFreeCommandBuffers(device, sit_gs.vk.command_pool, 1, &transfer_cmd);

            // --- d. Map Staging Buffer and Copy Data ---
            void* mapped_data;
            result = vmaMapMemory(allocator, staging_allocation, &mapped_data);
            if (result != VK_SUCCESS) {
                vmaDestroyBuffer(allocator, staging_buffer, staging_allocation);
                _SituationSetErrorFromCode(SITUATION_ERROR_BUFFER_MAP_FAILED, "Failed to map staging buffer for reading data.");
                return SITUATION_ERROR_BUFFER_MAP_FAILED;
            }

            memcpy(out_data, mapped_data, size);
            vmaUnmapMemory(allocator, staging_allocation);

            // --- e. Cleanup Staging Buffer ---
            vmaDestroyBuffer(allocator, staging_buffer, staging_allocation);

            return SITUATION_SUCCESS;
        }
    }
#endif // SITUATION_USE_VULKAN

    // Should not be reached, but included for completeness
    return SITUATION_ERROR_NOT_IMPLEMENTED;
}

// --- Command Buffer Implementations ---

/**
 * @brief Binds a compute pipeline for subsequent dispatch commands.
 * @details Activates the specified compute pipeline, making its shader program and associated state active for subsequent `SituationCmdDispatch` and resource binding commands (e.g., `SituationCmdBindComputeBuffer`) recorded in the command buffer.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Calls `glUseProgram(pipeline.gl_program_id)` to activate the OpenGL Compute Program associated with the `SituationComputePipeline` handle.
 * - **Vulkan:** Records a `vkCmdBindPipeline` command into the provided command buffer for the `VK_PIPELINE_BIND_POINT_COMPUTE` bind point. It also updates the internal global state `sit_gs.vk.current_compute_pipeline_layout` with the pipeline's layout.
 *   This layout is essential for subsequent `vkCmdBindDescriptorSets` (called by `SituationCmdBindComputeBuffer`) and `vkCmdPushConstants` (called by `SituationCmdSetPushConstant`) commands to specify the correct pipeline interface.
 *
 * @param cmd The command buffer into which the bind command will be recorded.
 *            In OpenGL, this parameter is typically ignored as it uses global state.
 * @param pipeline The `SituationComputePipeline` handle representing the compute pipeline to bind.
 *
 * @note It is the caller's responsibility to ensure that:
 *       1. (Vulkan) The command buffer `cmd` is valid and in the recording state.
 *       2. The compute pipeline represented by `pipeline` was created successfully.
 * @warning This function must be called before any dispatch or resource binding commands related to this compute pipeline.
 */
SITAPI void SituationCmdBindComputePipeline(SituationCommandBuffer cmd, SituationComputePipeline pipeline) {
    // --- Input Validation ---
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot bind compute pipeline.");
        return;
    }
    if (pipeline.id == 0) { // Validate the pipeline handle itself
         _SituationSetErrorFromCode(SITUATION_ERROR_RESOURCE_INVALID, "Invalid compute pipeline handle provided.");
        return;
    }

#if defined(SITUATION_USE_VULKAN)
    // --- Vulkan Implementation ---
    if (cmd == 0 || (VkCommandBuffer)cmd == VK_NULL_HANDLE) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Invalid command buffer for binding compute pipeline.");
        return;
    }

    // 1. Bind the VkPipeline object.
    vkCmdBindPipeline((VkCommandBuffer)cmd, VK_PIPELINE_BIND_POINT_COMPUTE, pipeline.vk_pipeline);

    // 2. Store the VkPipelineLayout for subsequent operations like push constants
    //    or binding descriptor sets that conform to this pipeline's layout.
    sit_gs.vk.current_compute_pipeline_layout = pipeline.vk_pipeline_layout; // Assuming this global/state member exists

    // 3. (Optional/Advanced) If the compute pipeline itself requires a specific descriptor set
    //    to be bound (e.g., for push constants if they use a descriptor set, or other
    //    pipeline-specific resources managed this way), bind it now.
    //    This assumes such a set is pre-created and stored in the pipeline struct.
    /*
    if (pipeline.descriptor_set != VK_NULL_HANDLE) {
        vkCmdBindDescriptorSets(
            (VkCommandBuffer)cmd,
            VK_PIPELINE_BIND_POINT_COMPUTE,
            pipeline.vk_pipeline_layout, // Layout this set conforms to
            0,                           // Set index for pipeline-specific set
            1,
            &pipeline.descriptor_set,
            0,
            NULL
        );
    }
    */
    // If your compute pipeline setup doesn't use this, you can omit step 3.

#elif defined(SITUATION_USE_OPENGL)
    // --- OpenGL Implementation ---
    // Bind the OpenGL Compute Program using glUseProgram.
    glUseProgram(pipeline.gl_program_id);
    SIT_CHECK_GL_ERROR();
    // Note: Error handling for glUseProgram is often omitted as it typically only fails
    //       if the program is invalid, which should be caught during creation.
    //       You can add SIT_CHECK_GL_ERROR() if robustness is critical here.
#endif
}

/**
 * @brief Binds a GPU buffer (typically an SSBO) to a specific binding point within the currently bound compute pipeline.
 * @details Associates a `SituationBuffer` with a binding point declared in the GLSL compute shader code (e.g., `layout(set = ..., binding = X) buffer ...`). This allows the compute shader to access the buffer's data.
 *
 * @par Backend-Specific Behavior & Performance
 * - **OpenGL:** Calls `glBindBufferBase(GL_SHADER_STORAGE_BUFFER, binding, buffer.gl_buffer_id)`.
 *   This efficiently binds the buffer to the specified unit for use by the currently active compute program.
 * - **Vulkan:** This function implements a high-performance, persistent descriptor set model.
 *   When the `SituationBuffer` was created (via `SituationCreateBuffer`), the Vulkan backend internally allocated a `VkDescriptorSet` from a dedicated persistent pool and populated
 *   it with the buffer's `VkBuffer` handle. This function simply records a fast `vkCmdBindDescriptorSets` command using this pre-cached descriptor set.
 *   This approach avoids the significant CPU overhead of allocating and updating descriptor sets every frame, which is crucial for performance in Vulkan.
 *
 * @param cmd The command buffer into which the bind command will be recorded (Vulkan) or ignored (OpenGL).
 * @param binding The binding point index within the compute shader's descriptor set.
 *                In GLSL, this corresponds to the `binding = X` part of the layout qualifier.
 *                In Vulkan, this corresponds to the `dstBinding` used when the buffer's internal descriptor set was originally populated (typically 0 for a single buffer resource within its set).
 * @param buffer The `SituationBuffer` handle to bind. The buffer should have been created with usage flags indicating it will be used as a storage buffer (e.g., `SITUATION_BUFFER_USAGE_STORAGE_BUFFER`).
 *
 * @return SITUATION_SUCCESS on successful recording of the bind command.
 * @return SITUATION_ERROR_NOT_INITIALIZED if the library is not initialized.
 * @return SITUATION_ERROR_RESOURCE_INVALID if the buffer handle is invalid (e.g., `id` is 0).
 * @return SITUATION_ERROR_INVALID_PARAM (Vulkan) if the provided command buffer handle is invalid.
 * @return SITUATION_ERROR_RESOURCE_INVALID (Vulkan) if the buffer's internal pre-cached descriptor set is invalid or missing.
 *
 * @note It is the caller's responsibility to ensure that:
 *       1. A compute pipeline has been successfully bound using `SituationCmdBindComputePipeline` before calling this function.
 *       2. (Vulkan) The command buffer `cmd` is valid and in the recording state.
 *       3. The `binding` index matches the layout specified in the compute shader.
 * @warning Binding a buffer that was not created with appropriate usage flags (like `SITUATION_BUFFER_USAGE_STORAGE_BUFFER`) may lead to undefined behavior or validation errors.
 */
SITAPI SituationError SituationCmdBindComputeBuffer(SituationCommandBuffer cmd, uint32_t binding, SituationBuffer buffer) {
    // The old 'binding' parameter directly maps to the new 'set_index' parameter.
    return SituationCmdBindDescriptorSet(cmd, binding, buffer);
}

/**
 * @brief Inserts a pipeline memory barrier for synchronization.
 * @details This is a critical function for synchronizing memory access between different pipeline stages, especially between compute and graphics passes, or before/after transfer operations.
 *          It ensures that writes from a source stage (e.g., a compute shader) are visible to reads or writes in a destination stage (e.g., a vertex shader, or another compute shader).
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** This maps to one or more `glMemoryBarrier` calls. The `src_flags` and `dst_flags` are combined to determine the necessary OpenGL barrier bits. Multiple barriers might be issued
 *   if the combined flags require it (e.g., one for SSBO/ShaderImage access, another for indirect commands).
 * - **Vulkan:** This maps to one or more `vkCmdPipelineBarrier` calls. It carefully constructs the `srcStageMask`, `dstStageMask`, `srcAccessMask`, and `dstAccessMask` based on the abstract flags.
 *   This implementation correctly maps the defined abstract flags to their Vulkan equivalents.
 *
 * @param cmd The command buffer to record the barrier into.
 * @param src_flags A bitmask of `SituationBarrierSrcFlags` indicating the pipeline stage(s) and type(s) of memory access that form the source of the dependency.
 * @param dst_flags A bitmask of `SituationBarrierDstFlags` indicating the pipeline stage(s) and type(s) of memory access that form the destination of the dependency.
 */
SITAPI void SituationCmdPipelineBarrier(SituationCommandBuffer cmd, uint32_t src_flags, uint32_t dst_flags) {
    if (!sit_gs.is_initialized) { return; } // Silently return if the library isn't initialized.

#if defined(SITUATION_USE_OPENGL)
    {
        (void)cmd; // Command buffer is unused in OpenGL immediate mode for memory barriers.

        GLbitfield combined_barrier_bits = 0;

        // --- Determine Combined OpenGL Barrier Bits ---
        // Source: What stages/types wrote the data?
        if (src_flags & SITUATION_BARRIER_COMPUTE_SHADER_WRITE) {
            combined_barrier_bits |= GL_SHADER_STORAGE_BARRIER_BIT;
        }
        if (src_flags & SITUATION_BARRIER_FRAGMENT_SHADER_WRITE) {
            combined_barrier_bits |= GL_SHADER_IMAGE_ACCESS_BARRIER_BIT; // For imageStore
            // Note: glClearBuffer* might use GL_FRAMEBUFFER_BARRIER_BIT, but imageStore typically needs SHADER_IMAGE_ACCESS
        }
        if (src_flags & SITUATION_BARRIER_VERTEX_SHADER_WRITE) {
            // Vertex shader writes are uncommon without extensions like Transform Feedback.
            // If used (e.g., SSBO writes), SHADER_STORAGE_BARRIER_BIT is appropriate.
            combined_barrier_bits |= GL_SHADER_STORAGE_BARRIER_BIT;
        }
        if (src_flags & SITUATION_BARRIER_TRANSFER_WRITE) {
            combined_barrier_bits |= GL_BUFFER_UPDATE_BARRIER_BIT; // For glBufferSubData, etc.
            // Could also use GL_PIXEL_BUFFER_BARRIER_BIT for PBO operations if used.
        }

        // Destination: What stages/types will read/use the data?
        if (dst_flags & SITUATION_BARRIER_COMPUTE_SHADER_READ) {
            combined_barrier_bits |= GL_SHADER_STORAGE_BARRIER_BIT; // For reading SSBOs
        }
        if (dst_flags & SITUATION_BARRIER_COMPUTE_SHADER_WRITE) {
            // If a subsequent compute dispatch *writes* to the same resource, ensure prior writes are visible.
            combined_barrier_bits |= GL_SHADER_STORAGE_BARRIER_BIT;
        }
        if (dst_flags & SITUATION_BARRIER_VERTEX_SHADER_READ) {
            // Reading from SSBOs or textures in the vertex shader.
            combined_barrier_bits |= GL_SHADER_STORAGE_BARRIER_BIT; // For SSBOs
            combined_barrier_bits |= GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT; // If reading from a vertex buffer that was written to
            // combined_barrier_bits |= GL_ELEMENT_ARRAY_BARRIER_BIT; // If reading index buffer written by transfer
        }
        if (dst_flags & SITUATION_BARRIER_FRAGMENT_SHADER_READ) {
            combined_barrier_bits |= GL_TEXTURE_FETCH_BARRIER_BIT; // For sampling textures
            combined_barrier_bits |= GL_SHADER_STORAGE_BARRIER_BIT; // For reading SSBOs in fragment shader
        }
        if (dst_flags & SITUATION_BARRIER_TRANSFER_READ) {
            // Reading data in a transfer operation (e.g., glReadPixels, CopyBuffer/TextureSubData src)
            combined_barrier_bits |= GL_BUFFER_UPDATE_BARRIER_BIT; // If reading from a buffer written by shader
            // Could also use GL_PIXEL_BUFFER_BARRIER_BIT for PBO operations if used.
        }
        if (dst_flags & SITUATION_BARRIER_TRANSFER_WRITE) {
             // If the destination is a transfer write (e.g., CopyBuffer/TextureSubData dst), ensure previous writes to the *source* are visible.
             // This is implicitly handled by the src_flags barrier above. The dst_flags barrier is more about what *reads* the result of the transfer.
             // However, to ensure the *destination* buffer/image is ready to be written to by a transfer after being written by a shader, we might need a barrier.
             // But the typical pattern is the src barrier ensures the data is ready for transfer read.
             // Let's add a general buffer/image barrier for transfer destinations if they were written to.
             // This is tricky with the current src/dst flag abstraction.
             // A simpler interpretation: if we are about to do a transfer write, ensure prior shader writes to that resource are visible.
             // The src barrier should cover this. Adding it here might be redundant.
             // Let's omit it for now to avoid over-syncing. The src_flags should be the primary driver.
             // combined_barrier_bits |= GL_BUFFER_UPDATE_BARRIER_BIT; // Potentially redundant
        }
        if (dst_flags & SITUATION_BARRIER_INDIRECT_COMMAND_READ) {
            // Reading indirect draw/dispatch arguments.
            combined_barrier_bits |= GL_COMMAND_BARRIER_BIT;
        }

        // --- Issue the Barrier ---
        if (combined_barrier_bits != 0) {
            glMemoryBarrier(combined_barrier_bits);
            SIT_CHECK_GL_ERROR();
            // Note: glMemoryBarrier errors are rare but can occur with invalid bit combinations
            // or driver issues. SIT_CHECK_GL_ERROR handles this.
        }
        // If no bits were set, the call is effectively a no-op, which is valid.
    }

#elif defined(SITUATION_USE_VULKAN)
    {
        // --- Enhanced Vulkan Pipeline Barrier Implementation ---
        VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;

        // --- Accumulate Vulkan Stages and Access Masks ---
        VkPipelineStageFlags src_stage_mask = 0;
        VkAccessFlags src_access_mask = 0;
        VkPipelineStageFlags dst_stage_mask = 0;
        VkAccessFlags dst_access_mask = 0;

        // --- Determine Source Stage and Access ---
        // What stage wrote the data, and how?
        if (src_flags & SITUATION_BARRIER_COMPUTE_SHADER_WRITE) { src_stage_mask |= VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT; src_access_mask |= VK_ACCESS_SHADER_WRITE_BIT; }
        if (src_flags & SITUATION_BARRIER_FRAGMENT_SHADER_WRITE) { src_stage_mask |= VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT; src_access_mask |= VK_ACCESS_SHADER_WRITE_BIT; } // VK_ACCESS_SHADER_WRITE_BIT is correct for imageStore or SSBO writes in the fragment shader.
        if (src_flags & SITUATION_BARRIER_VERTEX_SHADER_WRITE) { src_stage_mask |= VK_PIPELINE_STAGE_VERTEX_SHADER_BIT; src_access_mask |= VK_ACCESS_SHADER_WRITE_BIT; } // Vertex shader writes (e.g., to SSBOs).
        if (src_flags & SITUATION_BARRIER_TRANSFER_WRITE) { src_stage_mask |= VK_PIPELINE_STAGE_TRANSFER_BIT; src_access_mask |= VK_ACCESS_TRANSFER_WRITE_BIT; }
        // --- Determine Destination Stage and Access ---
        // What stage will read or write the data next, and how?
        if (dst_flags & SITUATION_BARRIER_COMPUTE_SHADER_READ) { dst_stage_mask |= VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT; dst_access_mask |= VK_ACCESS_SHADER_READ_BIT; }
        if (dst_flags & SITUATION_BARRIER_COMPUTE_SHADER_WRITE) { dst_stage_mask |= VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT; dst_access_mask |= VK_ACCESS_SHADER_WRITE_BIT; } // Ensuring visibility for a subsequent write by the compute shader.
        if (dst_flags & SITUATION_BARRIER_VERTEX_SHADER_READ) { dst_stage_mask |= VK_PIPELINE_STAGE_VERTEX_SHADER_BIT; dst_access_mask |= VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT; } // [FIX] Added VERTEX_ATTRIBUTE_READ
        if (dst_flags & SITUATION_BARRIER_FRAGMENT_SHADER_READ) { dst_stage_mask |= VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT; dst_access_mask |= VK_ACCESS_SHADER_READ_BIT; } // For textures/SSBOs
        if (dst_flags & SITUATION_BARRIER_TRANSFER_READ) { dst_stage_mask |= VK_PIPELINE_STAGE_TRANSFER_BIT; dst_access_mask |= VK_ACCESS_TRANSFER_READ_BIT; } // Reading for a copy operation
        if (dst_flags & SITUATION_BARRIER_TRANSFER_WRITE) {
            // Ensuring the destination of a transfer write is ready.
            // The src barrier ensures data written by shaders is visible for transfer *read*.
            // This barrier ensures the *destination* resource is ready to be written to by transfer.
            // This is less common as transfer destinations are often "fresh". But if a buffer/image was previously written by a shader and is now the destination of a transfer, this barrier makes sense.
            dst_stage_mask |= VK_PIPELINE_STAGE_TRANSFER_BIT;
            dst_access_mask |= VK_ACCESS_TRANSFER_WRITE_BIT;
        }
        if (dst_flags & SITUATION_BARRIER_INDIRECT_COMMAND_READ) {
            dst_stage_mask |= VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT; // Or DISPATCH_INDIRECT_BIT for compute
            // Vulkan spec often uses VERTEX_INPUT_BIT or others for indirect, but DRAW_INDIRECT_BIT is specific.
            // Let's use DRAW_INDIRECT_BIT. For compute dispatches, DISPATCH_INDIRECT_BIT is correct.
            // The source stage/access for writing indirect args would be SHADER_WRITE_BIT.
            // To cover both draw and dispatch indirect, we might need to set both stages, or determine it dynamically. For simplicity, we'll use DRAW_INDIRECT_BIT.
            // Access for reading indirect args is INDIRECT_COMMAND_READ_BIT.
            dst_stage_mask |= VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT; // Safer to include both
            dst_access_mask |= VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
        }

        // --- [ROBUSTNESS] Prevent validation errors from empty stage masks ---
        // If no source stage is specified, assume the earliest possible stage.
        if (src_stage_mask == 0) { src_stage_mask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT; }
        // If no destination stage is specified, assume the latest possible stage.
        if (dst_stage_mask == 0) { dst_stage_mask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT; }
        
        // --- Issue the Barrier ---
        // Only record the barrier if there's an actual dependency to synchronize.
        if ((src_stage_mask != 0 || dst_stage_mask != 0) && (src_access_mask != 0 || dst_access_mask != 0)) {
            // --- Basic Memory Barrier (No image/buffer memory transitions assumed) ---
            // For image/buffer layout transitions, VkImageMemoryBarrier or VkBufferMemoryBarrier structs would need to be set up and passed to vkCmdPipelineBarrier.
            VkMemoryBarrier memory_barrier = {0};
            memory_barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
            memory_barrier.srcAccessMask = src_access_mask;
            memory_barrier.dstAccessMask = dst_access_mask;

            // Perform the barrier
            // Using VK_DEPENDENCY_BY_REGION_BIT can be a performance hint if the access is localized.
            // For general barriers, it's often omitted unless specifically needed.
            vkCmdPipelineBarrier(
                vk_cmd,
                src_stage_mask,           // srcStageMask
                dst_stage_mask,           // dstStageMask
                0,                        // dependencyFlags (e.g., VK_DEPENDENCY_BY_REGION_BIT)
                1,                        // memoryBarrierCount
                &memory_barrier,          // pMemoryBarriers
                0,                        // bufferMemoryBarrierCount
                NULL,                     // pBufferMemoryBarriers
                0,                        // imageMemoryBarrierCount
                NULL                      // pImageMemoryBarriers
            );
        } else {
            // Optional: Log a verbose message if no effective barrier is specified?
            // This is generally not an error, just a no-op.
            // fprintf(stderr, "VERBOSE: SituationCmdPipelineBarrier called with no effective barriers (src: 0x%x, dst: 0x%x).\n", src_flags, dst_flags);
        }
        // --- End Enhanced Implementation ---
    }
#endif
}

/**
 * @brief Dispatches compute work using the currently bound compute pipeline.
 *
 * @details Executes the compute shader associated with the compute pipeline that was previously bound using `SituationCmdBindComputePipeline`. The number of work groups to be executed in each dimension (X, Y, Z) must be specified.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Calls `glDispatchCompute`. This function uses the currently active compute program (bound via `glUseProgram`).
 * - **Vulkan:** Records a `vkCmdDispatch` command into the provided command buffer.
 *   It requires that a compute pipeline has been previously bound to the command buffer using `vkCmdBindPipeline` with `VK_PIPELINE_BIND_POINT_COMPUTE`.
 *   Any necessary descriptor sets (for SSBOs, textures, etc.) must also be bound prior to this call.
 *
 * @param cmd The command buffer into which the dispatch command will be recorded (Vulkan) or which provides context (OpenGL, though often unused).
 * @param group_count_x The number of local work groups to dispatch in the X dimension.
 * @param group_count_y The number of local work groups to dispatch in the Y dimension.
 * @param group_count_z The number of local work groups to dispatch in the Z dimension.
 *
 * @note It is the caller's responsibility to ensure that:
 *       1. A valid compute pipeline is bound before calling this function.
 *       2. All required resources (buffers, textures via descriptor sets/binds) are bound.
 *       3. Appropriate memory barriers (`SituationMemoryBarrier`) are used if synchronization is needed before or after the dispatch.
 *
 * @warning Calling this function without a bound compute pipeline will result in undefined behavior or a Vulkan validation error.
 */
SITAPI void SituationCmdDispatch(SituationCommandBuffer cmd, uint32_t group_count_x, uint32_t group_count_y, uint32_t group_count_z) {
    // --- 1. Core Library Initialization Check ---
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot dispatch compute work.");
        return;
    }

#if defined(SITUATION_USE_OPENGL)
    {
        (void)cmd; // OpenGL uses the currently bound program state, command buffer not needed for the dispatch call itself.
        // --- 2. OpenGL Dispatch ---
        glDispatchCompute(group_count_x, group_count_y, group_count_z);
        SIT_CHECK_GL_ERROR();
        // Note: Error handling for glDispatchCompute is often limited. Invalid group counts
        // might not generate an error until submission/draw, or might be silently clamped.
        // SIT_CHECK_GL_ERROR() catches errors from the call itself (e.g., invalid context).
    }

#elif defined(SITUATION_USE_VULKAN)
    {
        // --- 2. Vulkan Input Validation ---
        // 2.1. Validate Command Buffer Handle
        if (cmd == 0 || (VkCommandBuffer)cmd == VK_NULL_HANDLE) {
            _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Invalid command buffer for compute dispatch.");
            return;
        }
        VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;

        // 2.2. (Optional but Robust) Validate that a Compute Pipeline is Bound
        // While Vulkan drivers will error if no pipeline is bound, checking here provides
        // clearer feedback. This requires tracking the last bound compute pipeline layout
        // or a simple boolean flag in the global state (e.g., sit_gs.vk.is_compute_pipeline_bound).
        // Uncomment the lines below if such state tracking is implemented.
        /*
        if (sit_gs.vk.current_compute_pipeline_layout == VK_NULL_HANDLE) {
             _SituationSetErrorFromCode(SITUATION_ERROR_RENDER_COMMAND_FAILED, "Cannot dispatch compute work; no compute pipeline is currently bound. Call SituationCmdBindComputePipeline first.");
             return;
        }
        */

        // --- 3. Vulkan Dispatch ---
        // Records the dispatch command into the command buffer.
        // Assumes the pipeline and descriptor sets are correctly bound beforehand.
        vkCmdDispatch(vk_cmd, group_count_x, group_count_y, group_count_z);
    }
#endif
    // --- 4. Post-Dispatch (if needed) ---
    // No general post-dispatch actions are required here.
    // Synchronization is handled by the user via SituationMemoryBarrier.
}

/**
 * @brief Checks if the situation.h library is initialized.
 * @return True if the library is initialized (SituationInit has been called successfully), false otherwise.
 * @note Safe to call at any time, including before SituationInit or after SituationShutdown.
 */
bool SituationIsInitialized(void) {
    return sit_gs.is_initialized;
}

/**
 * @brief Retrieves text from the system clipboard.
 * @details The returned string is valid only until the next call to GetClipboardText or
 *          SetClipboardText. Do not store this pointer; copy the string if you need to keep it. The memory is managed by GLFW.
 * @return A const, null-terminated UTF-8 string, or NULL if an error occurred.
 */
SITAPI const char* SituationGetClipboardText(void) {
    if (!SituationIsInitialized()) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot get clipboard text");
        return NULL;
    }
    // GLFW handles all the complexity and memory management.
    return glfwGetClipboardString(sit_gs.sit_glfw_window);
}

/**
 * @brief Sets the system clipboard to the specified text.
 * @param text A null-terminated UTF-8 string to place in the clipboard.
 */
SITAPI void SituationSetClipboardText(const char* text) {
    if (!SituationIsInitialized()) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot set clipboard text");
        return;
    }
    if (!text) {
        // Setting an empty string is the correct way to "clear" the clipboard.
        text = "";
    }
    // GLFW handles all the complexity.
    glfwSetClipboardString(sit_gs.sit_glfw_window);
}

/**
 * @brief Sets a callback function to be executed when files are dragged and dropped onto the window.
 * @param callback The function to be called, or NULL to clear the callback.
 * @param user_data A custom pointer that will be passed to your callback function.
 */
SITAPI void SituationSetFileDropCallback(SituationFileDropCallback callback, void* user_data) {
    // Simply store the user's function pointer and data pointer in our global state.
    // The internal GLFW callback will then use these.
    sit_gs.file_drop_callback = callback;
    sit_gs.file_drop_user_data = user_data;
}

SITAPI bool SituationIsFileDropped(void) {
    if (!sit_gs.is_initialized) return false;
    return sit_gs.file_was_dropped_this_frame;
}

/**
 * @brief Get the paths of dropped files.
 * @warning The returned list and its string contents are dynamically allocated. The caller is **responsible for freeing this memory** using `SituationUnloadDroppedFiles()`.
 * @return A list of file paths.
 */
SITAPI char** SituationLoadDroppedFiles(int* count) {
    if (!sit_gs.is_initialized || sit_gs.dropped_file_count == 0) {
        *count = 0;
        return NULL;
    }

    // Return a COPY of the internal list, so the user can own it and free it.
    char** user_list = (char**)malloc(sit_gs.dropped_file_count * sizeof(char*));
    if (user_list == NULL) {
        *count = 0;
        return NULL;
    }

    for (int i = 0; i < sit_gs.dropped_file_count; i++) {
        user_list[i] = strdup(sit_gs.dropped_file_paths[i]);
        if (user_list[i] == NULL) {
            // Allocation failed, clean up this partial list
            for (int j = 0; j < i; j++) free(user_list[j]);
            free(user_list);
            *count = 0;
            return NULL;
        }
    }

    *count = sit_gs.dropped_file_count;

    // We have now given the user their own copy. We can clear the internal one.
    // This also prevents calling LoadDroppedFiles multiple times for the same drop event.
    for (int i = 0; i < sit_gs.dropped_file_count; i++) {
        free(sit_gs.dropped_file_paths[i]);
    }
    free(sit_gs.dropped_file_paths);
    sit_gs.dropped_file_paths = NULL;
    sit_gs.dropped_file_count = 0;

    return user_list;
}

SITAPI void SituationUnloadDroppedFiles(char** paths, int count) {
    if (paths == NULL || count == 0) return;
    for (int i = 0; i < count; i++) {
        free(paths[i]);
    }
    free(paths);
}

// --- System Profiling Implementation ---
#if defined(__GNUC__) || defined(__clang__)
    #define SITUATION_DEVICE_INFO_DEPRECATED(msg) __attribute__((deprecated(msg)))
#elif defined(_MSC_VER)
    #define SITUATION_DEVICE_INFO_DEPRECATED(msg) __declspec(deprecated(msg))
#else
    #define SITUATION_DEVICE_INFO_DEPRECATED(msg)
#endif
/**
 * @brief Gathers and returns a comprehensive snapshot of the host system's hardware.
 * @details This function queries the operating system and underlying platform libraries to collect a wide range of information about the CPU, GPU, memory, storage, and connected devices. The collected data is aggregated into a single `SituationDeviceInfo` struct.
 *          This function is designed to give the application deep "Awareness" of its runtime environment, which can be used for logging, debugging, selecting quality settings, or displaying system information to the user.
 *
 * @par Data Collection & Platform Specificity
 *   The level of detail provided is platform-dependent and relies on various native APIs:
 *   - **CPU Info (Name, Cores, Speed):** Retrieved from the Windows Registry on Windows and `sysconf` on POSIX systems.
 *   - **GPU Info (Name, VRAM):**
 *     - On Windows, it prioritizes the DXGI API (if `SITUATION_ENABLE_DXGI` is defined) for the most accurate information, including dedicated VRAM.
 *     - As a fallback, or on other platforms, it retrieves the renderer string provided by the active graphics context (OpenGL or Vulkan).
 *   - **RAM Info (Total, Available):** Uses `GlobalMemoryStatusEx` on Windows and `sysinfo` on Linux. Not implemented on all POSIX systems.
 *   - **Storage Info (Drives, Capacity):** Enumerates logical drives on Windows. Not implemented on other platforms.
 *   - **Network & Input Devices:** Enumerates adapters and device classes on Windows for detailed names. Not implemented on other platforms.
 *
 * @return A `SituationDeviceInfo` struct populated with the discovered hardware information.
 * @return A zeroed struct if the library is not initialized. Fields for which information could not be retrieved will also be zero or empty.
 *
 * @note This can be a moderately expensive call, as it may involve querying multiple system APIs. It is best to call it once at startup and cache the results if the information is needed frequently.
 * @warning The completeness of the returned data is highly dependent on the operating system. Features like VRAM size, storage info, and detailed network/input device names are most reliable on Windows.
 */
SITUATION_DEVICE_INFO_DEPRECATED("Use the new, more specific functions like SituationGetCPUInfo(), SituationGetGPUInfo(), etc. This function will be removed in a future version.")
SITAPI SituationDeviceInfo SituationGetDeviceInfo(void) {
    SituationDeviceInfo info = {0};
    if (!sit_gs.is_initialized) { _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot get device info"); return info; }

    #if defined(_WIN32)
    // CPU Info
    SYSTEM_INFO sys_info_win; 
    GetSystemInfo(&sys_info_win);
    info.cpu_cores = sys_info_win.dwNumberOfProcessors;
    HKEY hKey;
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0", 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        DWORD size_cpu_name = sizeof(info.cpu_name);
        if (RegQueryValueExA(hKey, "ProcessorNameString", NULL, NULL, (LPBYTE)info.cpu_name, &size_cpu_name) != ERROR_SUCCESS) {
            strncpy(info.cpu_name, "Unknown CPU", SITUATION_MAX_CPU_NAME_LEN -1);
            info.cpu_name[SITUATION_MAX_CPU_NAME_LEN -1] = '\0';
        }
        DWORD speed_mhz = 0;
        DWORD size_speed = sizeof(speed_mhz);
        if (RegQueryValueExA(hKey, "~MHz", NULL, NULL, (LPBYTE)&speed_mhz, &size_speed) == ERROR_SUCCESS) {
            info.cpu_clock_speed_ghz = speed_mhz / 1000.0f;
        }
        RegCloseKey(hKey);
    } else {
        strncpy(info.cpu_name, "Unknown CPU (RegOpenKeyExA failed)", SITUATION_MAX_CPU_NAME_LEN -1);
        info.cpu_name[SITUATION_MAX_CPU_NAME_LEN -1] = '\0';
    }

    // GPU Info
    #ifdef SITUATION_ENABLE_DXGI
    // DXGI needs COM to be initialized. The flag sit_gs.is_com_initialized should be true.
    if (sit_gs.is_com_initialized) { // Check if COM is available
        IDXGIFactory* pFactory = NULL;
        if (SUCCEEDED(CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&pFactory)) && pFactory) {
            IDXGIAdapter* pAdapter = NULL;
            if (SUCCEEDED(pFactory->EnumAdapters(0, &pAdapter)) && pAdapter) { // Get primary adapter
                DXGI_ADAPTER_DESC desc;
                if (SUCCEEDED(pAdapter->GetDesc(&desc))) {
                    WideCharToMultiByte(CP_UTF8, 0, desc.Description, -1, info.gpu_name, SITUATION_MAX_GPU_NAME_LEN-1, NULL, NULL);
                    info.gpu_name[SITUATION_MAX_GPU_NAME_LEN-1] = '\0';
                    info.gpu_dedicated_memory_bytes = desc.DedicatedVideoMemory;
                } else { strncpy(info.gpu_name, "Unknown GPU (DXGI desc failed)", SITUATION_MAX_GPU_NAME_LEN-1);
                info.gpu_name[SITUATION_MAX_GPU_NAME_LEN-1] = '\0';}
                pAdapter->Release();
            } else { strncpy(info.gpu_name, "Unknown GPU (DXGI adapter enum failed)", SITUATION_MAX_GPU_NAME_LEN-1);
            info.gpu_name[SITUATION_MAX_GPU_NAME_LEN-1] = '\0';}
            pFactory->Release();
        } else { /* CreateDXGIFactory failed, or pFactory is NULL */
            strncpy(info.gpu_name, "Unknown GPU (DXGI factory failed)", SITUATION_MAX_GPU_NAME_LEN-1);
            info.gpu_name[SITUATION_MAX_GPU_NAME_LEN-1] = '\0';
        }
    } else 
    #endif // SITUATION_ENABLE_DXGI
    if (sit_gs.sit_glfw_window && glad_glGetString) { 
        const char* gl_renderer = (const char*)glGetString(GL_RENDERER);
        if (gl_renderer) { strncpy(info.gpu_name, gl_renderer, SITUATION_MAX_GPU_NAME_LEN-1);
        info.gpu_name[SITUATION_MAX_GPU_NAME_LEN-1] = '\0'; }
        else { strncpy(info.gpu_name, "Unknown GPU (OpenGL name not available)", SITUATION_MAX_GPU_NAME_LEN-1);
        info.gpu_name[SITUATION_MAX_GPU_NAME_LEN-1] = '\0'; }
    } else {
        strncpy(info.gpu_name, "Unknown GPU (No context/DXGI/COM)", SITUATION_MAX_GPU_NAME_LEN-1);
        info.gpu_name[SITUATION_MAX_GPU_NAME_LEN-1] = '\0';
    }

    // RAM Info
    MEMORYSTATUSEX mem_status = { .dwLength = sizeof(MEMORYSTATUSEX) };
    if (GlobalMemoryStatusEx(&mem_status)) {
        info.total_ram_bytes = mem_status.ullTotalPhys;
        info.available_ram_bytes = mem_status.ullAvailPhys;
    }

    // Storage Info
    DWORD drives_mask = GetLogicalDrives();
    info.storage_device_count = 0;
    for (int i = 0; i < 26 && info.storage_device_count < SITUATION_MAX_STORAGE_DEVICES; ++i) {
        if (drives_mask & (1 << i)) {
            char drive_path[] = { (char)('A' + i), ':', '\\', '\0' };
            ULARGE_INTEGER total_cap, free_space;
            if (GetDiskFreeSpaceExA(drive_path, NULL, &total_cap, &free_space)) { snprintf(info.storage_device_names[info.storage_device_count], SITUATION_MAX_DEVICE_NAME_LEN, "Drive %c:", (char)('A' + i));
                info.storage_capacity_bytes[info.storage_device_count] = total_cap.QuadPart;
                info.storage_free_bytes[info.storage_device_count] = free_space.QuadPart;
                info.storage_device_count++;
            }
        }
    }
    
    // Network Adapter Info
    ULONG adapters_buffer_size = 15000; // Recommended starting size by MS docs
    info.network_adapter_count = 0;
    IP_ADAPTER_ADDRESSES* adapters_list = (IP_ADAPTER_ADDRESSES*)malloc(adapters_buffer_size);
    if (adapters_list) {
        DWORD ret_val = GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_PREFIX, NULL, adapters_list, &adapters_buffer_size);
        if (ret_val == ERROR_BUFFER_OVERFLOW) { // Should have been caught if initial buffer was 0 and we got size.
                                                // But if initial guess was too small.
            free(adapters_list);
            adapters_list = (IP_ADAPTER_ADDRESSES*)malloc(adapters_buffer_size); // Retry with new size
            if (adapters_list) { ret_val = GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_PREFIX, NULL, adapters_list, &adapters_buffer_size);
            }
        }
        if (ret_val == ERROR_SUCCESS && adapters_list) {
            IP_ADAPTER_ADDRESSES* current_adapter = adapters_list;
            while (current_adapter && info.network_adapter_count < SITUATION_MAX_NETWORK_ADAPTERS) {
                // Filter for common operational adapters if desired (e.g., IfOperStatusUp) if (current_adapter->OperStatus == IfOperStatusUp) {
                WideCharToMultiByte(CP_UTF8, 0, current_adapter->FriendlyName, -1, info.network_adapter_names[info.network_adapter_count], SITUATION_MAX_DEVICE_NAME_LEN-1, NULL, NULL);
                info.network_adapter_names[info.network_adapter_count][SITUATION_MAX_DEVICE_NAME_LEN-1] = '\0';
                info.network_adapter_count++;
                // }
                current_adapter = current_adapter->Next;
            }
        }
        free(adapters_list); adapters_list = NULL;
    }


    // Input Device Info
    info.input_device_count = 0;
    const GUID* device_classes[] = { &GUID_DEVCLASS_KEYBOARD, &GUID_DEVCLASS_MOUSE, &GUID_DEVCLASS_HIDCLASS };
    for (int class_idx = 0; class_idx < 3 && info.input_device_count < SITUATION_MAX_INPUT_DEVICES; ++class_idx) {
        HDEVINFO hDevInfo = SetupDiGetClassDevsW(device_classes[class_idx], NULL, NULL, DIGCF_PRESENT);
        if (hDevInfo == INVALID_HANDLE_VALUE) continue;
        SP_DEVINFO_DATA dev_info_data = { .cbSize = sizeof(SP_DEVINFO_DATA) };
        for (DWORD i = 0; SetupDiEnumDeviceInfo(hDevInfo, i, &dev_info_data) && info.input_device_count < SITUATION_MAX_INPUT_DEVICES; ++i) {
            char friendly_name[SITUATION_MAX_DEVICE_NAME_LEN];
            if (SetupDiGetDeviceRegistryPropertyW(hDevInfo, &dev_info_data, SPDRP_FRIENDLYNAME, NULL, (PBYTE)friendly_name, sizeof(friendly_name)-1, NULL) ||
                SetupDiGetDeviceRegistryPropertyW(hDevInfo, &dev_info_data, SPDRP_DEVICEDESC, NULL, (PBYTE)friendly_name, sizeof(friendly_name)-1, NULL) ) {
                friendly_name[sizeof(friendly_name)-1] = '\0';
                if (device_classes[class_idx] == &GUID_DEVCLASS_HIDCLASS) { // Filter HIDCLASS for gamepads/controllers
                    if (!strstr(friendly_name, "Controller") && !strstr(friendly_name, "Gamepad") &&
                        !strstr(friendly_name, "Joystick") && !strstr(friendly_name, "XBOX") &&
                        !strstr(friendly_name, "Wireless Controller") && !strstr(friendly_name, "Joy-Con") &&
                        !strstr(friendly_name, "controller") && !strstr(friendly_name, "gamepad") ) { // Add lowercase checks
                        continue; // Skip if not a typical gamepad name
                    }
                }
                strncpy(info.input_device_names[info.input_device_count], friendly_name, SITUATION_MAX_DEVICE_NAME_LEN -1);
                info.input_device_names[info.input_device_count][SITUATION_MAX_DEVICE_NAME_LEN-1] = '\0';
                info.input_device_count++;
            }
        }
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }
    #else // Non-Windows basic info
    strncpy(info.cpu_name, "Generic CPU", SITUATION_MAX_CPU_NAME_LEN-1); info.cpu_name[SITUATION_MAX_CPU_NAME_LEN-1] = '\0';
    long nproc = sysconf(_SC_NPROCESSORS_ONLN);
    info.cpu_cores = (nproc > 0) ? (int)nproc : 1;

    if (sit_gs.sit_glfw_window && glad_glGetString) {
        const char* gl_renderer = (const char*)glGetString(GL_RENDERER);
        if (gl_renderer) { strncpy(info.gpu_name, gl_renderer, SITUATION_MAX_GPU_NAME_LEN-1);
        info.gpu_name[SITUATION_MAX_GPU_NAME_LEN-1] = '\0'; }
        else { strncpy(info.gpu_name, "Generic GPU (OpenGL name not available)", SITUATION_MAX_GPU_NAME_LEN-1);
        info.gpu_name[SITUATION_MAX_GPU_NAME_LEN-1] = '\0'; }
    } else {
        strncpy(info.gpu_name, "Generic GPU", SITUATION_MAX_GPU_NAME_LEN-1);
        info.gpu_name[SITUATION_MAX_GPU_NAME_LEN-1] = '\0';
    }
    // RAM, Storage, Network, Input would need platform-specific non-Win32 implementations (e.g., /proc/meminfo on Linux)
    #endif
    return info;
}

// --- Storage Media Information Implementation ---

SITAPI char* SituationGetUserDirectory(void) { 
    #if defined(_WIN32)
    if (!sit_gs.is_initialized || !sit_gs.is_com_initialized) { // Check COM for SHGetKnownFolderPath
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "COM or library not initialized for GetUserDirectory");
        return NULL;
    }
    PWSTR wPath = NULL;
    HRESULT hr = SHGetKnownFolderPath(&FOLDERID_Profile, 0, NULL, &wPath);
    if (SUCCEEDED(hr) && wPath) {
        char path_utf8[MAX_PATH * 4]; // Ensure enough space for UTF-8
        int chars_converted = WideCharToMultiByte(CP_UTF8, 0, wPath, -1, path_utf8, sizeof(path_utf8), NULL, NULL);
        CoTaskMemFree(wPath);
        if (chars_converted > 0) {
            char* result = (char*)malloc(strlen(path_utf8) + 1);
            if (!result) { _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "User directory string"); return NULL; }
            strcpy(result, path_utf8);
            return result;
        }
    }
    _SituationSetErrorFromCode(SITUATION_ERROR_DEVICE_QUERY, "SHGetKnownFolderPath failed");
    return NULL;
    #else
    // On Linux/macOS, get $HOME or use getpwuid(getuid())->pw_dir
    const char* home_dir = getenv("HOME");
    if (!home_dir) {
        struct passwd* pw = getpwuid(getuid());
        if (pw) home_dir = pw->pw_dir;
    }
    if (home_dir) {
        char* result = (char*)malloc(strlen(home_dir) + 1);
        if (!result) { _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "User directory string"); return NULL; }
        strcpy(result, home_dir);
        return result;
    }
    _SituationSetErrorFromCode(SITUATION_ERROR_DEVICE_QUERY, "Could not get user directory");
    return NULL;
    #endif
}


#if defined(_WIN32)
#include <fileapi.h> // For GetVolumeInformationA, GetDiskFreeSpaceExA
#include <shlwapi.h> // For PathGetDriveNumberA (link with Shlwapi.lib)
#pragma comment(lib, "Shlwapi.lib") // For PathGetDriveNumberA

/**
 * @brief Gets the drive letter of the logical volume where the running executable is located.
 * @details This is a Windows-specific utility function. It retrieves the full path of the current application's executable and extracts the drive letter from it (e.g., 'C', 'D').
 *
 * @par Platform Specificity
 *   This function is only implemented on Windows and will not be available on other platforms like Linux or macOS, where the concept of drive letters does not exist.
 *
 * @return The uppercase drive letter (e.g., 'C') on success.
 * @return `0` (null character) if the function fails, if the executable is running from a path without a drive letter (e.g., a UNC network path), or if the library is not initialized.
 *
 * @note This function is useful for applications that need to be aware of their installation location in a Windows environment, for example, to check for available space on the current drive.
 *
 * @see SituationGetDriveInfo()
 */
SITAPI char SituationGetCurrentDriveLetter(void) {
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "GetCurrentDriveLetter");
        return 0;
    }
    char exe_path[MAX_PATH];
    if (GetModuleFileNameA(NULL, exe_path, MAX_PATH) == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_DEVICE_QUERY, "GetModuleFileNameA failed for current drive letter");
        return 0;
    }

    int drive_number = PathGetDriveNumberA(exe_path);
    if (drive_number != -1) { // -1 means no drive letter (e.g. UNC path) or error
        return (char)('A' + drive_number);
    }
    _SituationSetErrorFromCode(SITUATION_ERROR_DEVICE_QUERY, "PathGetDriveNumberA failed or path has no drive letter");
    return 0;
}

/**
 * @brief Retrieves information about a specific logical drive on Windows, including its capacity, free space, and volume name.
 * @details This is a Windows-specific utility function that provides detailed information about a storage volume identified by its drive letter.
 *
 * @par Platform Specificity
 *   This function is only implemented on Windows and will not be available on other platforms. It uses the Win32 API functions `GetDiskFreeSpaceExA` and `GetVolumeInformationA`.
 *
 * @param drive_letter The letter of the drive to query (e.g., 'C' or 'c').
 * @param[out] out_total_capacity_bytes A pointer to a `uint64_t` that will be filled with the total size of the drive in bytes. Can be `NULL` if not needed.
 * @param[out] out_free_space_bytes A pointer to a `uint64_t` that will be filled with the free space available to the current user on the drive, in bytes. Can be `NULL` if not needed.
 * @param[out] out_volume_name A character buffer that will be filled with the drive's volume label (e.g., "Local Disk"). Can be `NULL` if not needed.
 * @param volume_name_len The size of the `out_volume_name` buffer, including the null terminator.
 *
 * @return `true` if the function was able to attempt the query.
 * @return `false` if the library is not initialized or if the provided drive letter is invalid.
 *
 * @note The function is considered successful if the API calls are made. If a specific query fails (e.g., a drive is not ready), the corresponding output parameter will not be filled, and an internal error will be set via `SituationGetLastErrorMsg()`.
 *   The caller should always check the contents of the output parameters.
 *
 * @see SituationGetCurrentDriveLetter()
 */
SITAPI bool SituationGetDriveInfo(char drive_letter, uint64_t* out_total_capacity_bytes, uint64_t* out_free_space_bytes, char* out_volume_name, int volume_name_len) {
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "GetDriveInfo");
        return false;
    }
    if (!((drive_letter >= 'A' && drive_letter <= 'Z') || (drive_letter >= 'a' && drive_letter <= 'z'))) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Invalid drive letter for GetDriveInfo");
        return false;
    }
    if (!out_total_capacity_bytes && !out_free_space_bytes && !out_volume_name) {
         _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "No output parameters provided for GetDriveInfo");
        return false; // Nothing to retrieve
    }


    char root_path[4]; // "X:\\"
    snprintf(root_path, sizeof(root_path), "%c:\\", toupper(drive_letter));

    if (out_total_capacity_bytes || out_free_space_bytes) {
        ULARGE_INTEGER total_bytes, free_bytes_to_caller, total_free_bytes;
        if (GetDiskFreeSpaceExA(root_path, &free_bytes_to_caller, &total_bytes, &total_free_bytes)) {
            if (out_total_capacity_bytes) *out_total_capacity_bytes = total_bytes.QuadPart;
            if (out_free_space_bytes) *out_free_space_bytes = free_bytes_to_caller.QuadPart; // Free space available to the caller
        } else {
            char err_detail[128];
            snprintf(err_detail, sizeof(err_detail), "GetDiskFreeSpaceExA failed for drive %c (Error: %lu)", toupper(drive_letter), GetLastError());
            _SituationSetErrorFromCode(SITUATION_ERROR_DEVICE_QUERY, err_detail);
            // Don't return false yet, try to get volume name if requested
        }
    }

    if (out_volume_name && volume_name_len > 0) {
        char volume_name_buffer[MAX_PATH + 1]; // MAX_PATH for volume name is generous
        char file_system_name_buffer[MAX_PATH + 1];
        DWORD volume_serial_number;
        DWORD max_component_length;
        DWORD file_system_flags;

        if (GetVolumeInformationA(
                root_path,
                volume_name_buffer,
                sizeof(volume_name_buffer),
                &volume_serial_number,
                &max_component_length,
                &file_system_flags,
                file_system_name_buffer,
                sizeof(file_system_name_buffer))) {
            strncpy(out_volume_name, volume_name_buffer, volume_name_len - 1);
            out_volume_name[volume_name_len - 1] = '\0';
        } else {
            char err_detail[128];
            snprintf(err_detail, sizeof(err_detail), "GetVolumeInformationA failed for drive %c (Error: %lu)", toupper(drive_letter), GetLastError());
            _SituationSetErrorFromCode(SITUATION_ERROR_DEVICE_QUERY, err_detail);
            out_volume_name[0] = '\0'; // Clear output volume name on error
            // If both GetDiskFreeSpaceExA and GetVolumeInformationA failed, then return false
            if (!out_total_capacity_bytes && !out_free_space_bytes) return false; // if only volume name was requested and failed
            if ( (out_total_capacity_bytes || out_free_space_bytes) && GetLastError() != ERROR_SUCCESS) {
                // if space was also requested and failed, this is an overall failure
                // The check above for GetDiskFreeSpaceExA already set an error.
            }
        }
    } else if (out_volume_name) {
        out_volume_name[0] = '\0'; // No space to write volume name
    }
    
    // Return true if at least one requested piece of info was successfully retrieved or attempted.
    // A more strict approach would return false if any part fails.
    // For now, let's assume if we got here without an early return, it's "successful enough" unless both GetDiskFreeSpaceExA and GetVolumeInformationA specifically failed and were requested.
    // The error state will hold the latest error.
    return true; // Simplification: if function runs, it's considered a success, caller checks outputs.
                 // A better check: return true only if ALL requested outputs were successfully populated.
                 // For now, if GetDiskFreeSpaceExA fails for requested space info, it's a problem.
                 // If GetVolumeInformationA fails for requested name info, it's a problem.
                 // Let's return based on whether the *last* critical operation succeeded or if nothing critical was requested.
    // Revised logic:
    // if ((out_total_capacity_bytes || out_free_space_bytes) && GetLastError() from GetDiskFreeSpaceExA was not SUCCESS) return false;
    // if (out_volume_name && GetLastError() from GetVolumeInformationA was not SUCCESS) return false;
    // This becomes complex due to GetLastError state. The current code is simpler.
    // Let's assume if we try to get info and it fails, the out params won't be valid, and the error message will be set. The boolean indicates an attempt was made.
}


/**
 * @brief Asks the operating system to open a file, folder, or URL with its default application.
 * @details This functions like a "double-click". It uses the platform's recommended native APIs for a secure and reliable operation (e.g., ShellExecute on Windows, xdg-open on Linux).
 * @param filePath The path to the file, folder, or a full URL to open.
 */
SITAPI void SituationOpenFile(const char* filePath) {
    if (!filePath || filePath[0] == '\0') {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "File path cannot be null or empty.");
        return;
    }

#if defined(_WIN32)
    #include <shellapi.h>
    int result = (int)(uintptr_t)ShellExecuteA(NULL, "open", filePath, NULL, NULL, SW_SHOWNORMAL);
    if (result <= 32) {
        _SituationSetError("ShellExecuteA failed to open file or path.");
    }
#elif defined(__APPLE__)
    char command[2048];
    snprintf(command, sizeof(command), "open \"%s\"", filePath);
    if (system(command) != 0) {
        _SituationSetError("macOS 'open' command failed.");
    }
#elif defined(__linux__)
    char command[2048];
    snprintf(command, sizeof(command), "xdg-open \"%s\"", filePath);
    if (system(command) != 0) {
        _SituationSetError("Linux 'xdg-open' command failed.");
    }
#else
    _SituationSetError("SituationOpenFile is not supported on this platform.");
#endif
}

// --- Monitor Enum Proc for Physical Displays (Windows-specific) ---
#if defined(_WIN32)
typedef struct {
    SituationDisplayInfo* displays_array;
    int current_display_idx;
    int max_displays;
    GLFWmonitor** glfw_monitors;
    int glfw_monitor_count;
} _SituationMonitorEnumData;

/**
 * @brief [INTERNAL] Win32 callback function for enumerating and collecting physical display information.
 * @details This function is the core of the display enumeration logic on the Windows platform. It is designed to be passed as a callback to the Win32 API function `EnumDisplayMonitors`.
 *          For each monitor detected by the operating system, Windows invokes this function, providing a handle to the monitor.
 *
 * @par Function Workflow
 *   For each monitor passed to it, this function performs the following steps:
 *   1.  **Get Detailed Info:** Uses `GetMonitorInfoExA` to retrieve the monitor's unique device name (e.g., `\\.\DISPLAY1`) and determine if it is the primary display.
 *   2.  **Match with GLFW:** It attempts to correlate the Win32 monitor handle with a `GLFWmonitor` handle by comparing their screen coordinates. This is crucial for bridging the gap between the low-level OS information and the GLFW context used for windowing.
 *   3.  **Query Current Mode:** It uses `EnumDisplaySettingsA` to get the monitor's current resolution, refresh rate, and color depth.
 *   4.  **Enumerate All Modes:** It repeatedly calls `EnumDisplaySettingsA` in a loop to build a comprehensive, de-duplicated list of all video modes supported by the display.
 *   5.  **Store Data:** All of this collected information is stored in the next available `SituationDisplayInfo` struct within the array provided via the `dwData` parameter.
 *
 * @param hMonitor A handle to the display monitor, provided by the Win32 API.
 * @param hdcMonitor A handle to a device context for the monitor (unused).
 * @param lprcMonitor A pointer to a rectangle specifying the monitor's display area (unused).
 * @param dwData A user-defined value passed from the `EnumDisplayMonitors` call. In this library, it is a pointer to a `_SituationMonitorEnumData` struct, which contains the destination array and state for the enumeration process.
 *
 * @return `TRUE` to continue the enumeration to the next monitor. `FALSE` would halt the process.
 *
 * @note This function is platform-specific to Windows and is only compiled on `_WIN32`.
 * @warning This is a low-level callback and is not part of the public API. It should never be called directly.
 *
 * @see _SituationCachePhysicalDisplays(), EnumDisplayMonitors()
 */
static BOOL CALLBACK _SituationMonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData) {
    (void)hdcMonitor; (void)lprcMonitor;
    _SituationMonitorEnumData* enum_data = (_SituationMonitorEnumData*)dwData;
    if (enum_data->current_display_idx >= enum_data->max_displays) return TRUE;

    MONITORINFOEXA monitor_info_ex = { .cbSize = sizeof(MONITORINFOEXA) };
    if (GetMonitorInfoA(hMonitor, (LPMONITORINFO)&monitor_info_ex)) {
        SituationDisplayInfo* display = &enum_data->displays_array[enum_data->current_display_idx];
        strncpy(display->name, monitor_info_ex.szDevice, SITUATION_MAX_MONITOR_NAME_LEN-1);
        display->name[SITUATION_MAX_MONITOR_NAME_LEN-1] = '\0';
        display->is_primary = (monitor_info_ex.dwFlags & MONITORINFOF_PRIMARY) != 0;
        display->situation_monitor_id = enum_data->current_display_idx;
        display->glfw_monitor_handle = NULL;

        for (int i = 0; i < enum_data->glfw_monitor_count; ++i) {
            int gx, gy;
            glfwGetMonitorPos(enum_data->glfw_monitors[i], &gx, &gy);
            if (monitor_info_ex.rcMonitor.left == gx && monitor_info_ex.rcMonitor.top == gy) {
                display->glfw_monitor_handle = enum_data->glfw_monitors[i];
                break;
            }
        }
        if (!display->glfw_monitor_handle && display->is_primary) {
             display->glfw_monitor_handle = glfwGetPrimaryMonitor();
        }

        DEVMODEA current_dev_mode = { .dmSize = sizeof(DEVMODEA), .dmDriverExtra = 0 };
        if (EnumDisplaySettingsA(monitor_info_ex.szDevice, ENUM_CURRENT_SETTINGS, &current_dev_mode)) {
            display->current_mode.width = current_dev_mode.dmPelsWidth;
            display->current_mode.height = current_dev_mode.dmPelsHeight;
            display->current_mode.refresh_rate = current_dev_mode.dmDisplayFrequency;
            display->current_mode.color_depth = current_dev_mode.dmBitsPerPel;
        } else {memset(&display->current_mode, 0, sizeof(SituationDisplayMode));}

        #define TEMP_MAX_MODES_ENUM 256
        SituationDisplayMode temp_modes_buffer[TEMP_MAX_MODES_ENUM];
        int unique_modes_count = 0;
        DEVMODEA available_dev_mode = { .dmSize = sizeof(DEVMODEA), .dmDriverExtra = 0 };
        int mode_idx_counter = 0;

        while (EnumDisplaySettingsA(monitor_info_ex.szDevice, mode_idx_counter++, &available_dev_mode)) {
            if (available_dev_mode.dmBitsPerPel < 16) continue; 
            bool is_duplicate = false;
            for (int k = 0; k < unique_modes_count; ++k) {
                if (temp_modes_buffer[k].width == (int)available_dev_mode.dmPelsWidth &&
                    temp_modes_buffer[k].height == (int)available_dev_mode.dmPelsHeight &&
                    temp_modes_buffer[k].refresh_rate == (int)available_dev_mode.dmDisplayFrequency &&
                    temp_modes_buffer[k].color_depth == (int)available_dev_mode.dmBitsPerPel) {
                    is_duplicate = true;
                    break;
                }
            }
            if (!is_duplicate) {
                if (unique_modes_count < TEMP_MAX_MODES_ENUM) {
                    temp_modes_buffer[unique_modes_count].width = available_dev_mode.dmPelsWidth;
                    temp_modes_buffer[unique_modes_count].height = available_dev_mode.dmPelsHeight;
                    temp_modes_buffer[unique_modes_count].refresh_rate = available_dev_mode.dmDisplayFrequency;
                    temp_modes_buffer[unique_modes_count].color_depth = available_dev_mode.dmBitsPerPel;
                    unique_modes_count++;
                } else { break; }
            }
            memset(&available_dev_mode, 0, sizeof(DEVMODEA));
            available_dev_mode.dmSize = sizeof(DEVMODEA);
        }

        if (unique_modes_count > 0) {
            display->available_modes = (SituationDisplayMode*)malloc(unique_modes_count * sizeof(SituationDisplayMode));
            if (display->available_modes) {
                memcpy(display->available_modes, temp_modes_buffer, unique_modes_count * sizeof(SituationDisplayMode));
                display->available_mode_count = unique_modes_count;
            } else {
                _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Available display modes array");
                display->available_mode_count = 0;
            }
        } else {
            display->available_modes = NULL;
            display->available_mode_count = 0;
        }
        enum_data->current_display_idx++;
    }
    return TRUE;
}
#endif

#if defined(_WIN32)
    #include <direct.h> // For _mkdir _rmdir

// Converts a UTF-8 string to a UTF-16 (wide) string.
// Caller must free the returned WCHAR* with free().
static WCHAR* _sit_utf8_to_wide(const char* utf8_str) {
    if (!utf8_str) return NULL;
    int wide_len = MultiByteToWideChar(CP_UTF8, 0, utf8_str, -1, NULL, 0);
    if (wide_len == 0) return NULL;
    WCHAR* wide_str = (WCHAR*)malloc(wide_len * sizeof(WCHAR));
    if (!wide_str) return NULL;
    MultiByteToWideChar(CP_UTF8, 0, utf8_str, -1, wide_str, wide_len);
    return wide_str;
}

// Converts a UTF-16 (wide) string to a UTF-8 string.
// Caller must free the returned char* with free().
static char* _sit_wide_to_utf8(const WCHAR* wide_str) {
    if (!wide_str) return NULL;
    int utf8_len = WideCharToMultiByte(CP_UTF8, 0, wide_str, -1, NULL, 0, NULL, NULL);
    if (utf8_len == 0) return NULL;
    char* utf8_str = (char*)malloc(utf8_len * sizeof(char));
    if (!utf8_str) return NULL;
    WideCharToMultiByte(CP_UTF8, 0, wide_str, -1, utf8_str, utf8_len, NULL, NULL);
    return utf8_str;
}

#else
    #include <errno.h> // For checking errno on rename failure
    #include <unistd.h>
    #include <sys/stat.h> // For mkdir rmdir
    #include <dirent.h>   // For opendir, readdir, closedir
#endif


// Filesystem Module
//==================================================================================
// --- Path Management & Special Directories ---

/**
 * @brief Get a safe, persistent path for saving application data (e.g., %APPDATA%/AppName).
 * @warning The returned string is dynamically allocated. The caller is **responsible for freeing this memory** using `free()`.
 * @param app_name The name of your application, used to create the final subdirectory.
 * @return A new string containing the full path, or NULL on failure.
 */
SITAPI char* SituationGetAppSavePath(const char* app_name) {
    if (!app_name || app_name[0] == '\0') return NULL;

#if defined(_WIN32)
    // NOTE: For this to work reliably, CoInitialize may need to be called.
    // situation.h already does this for DXGI, so it should be fine.
    PWSTR wide_path_appdata = NULL;
    HRESULT hr = SHGetKnownFolderPath(&FOLDERID_RoamingAppData, 0, NULL, &wide_path_appdata);

    if (FAILED(hr)) {
        // TODO: Set last error message
        return NULL;
    }

    char* path_appdata = _sit_wide_to_utf8(wide_path_appdata);
    CoTaskMemFree(wide_path_appdata); // Free the memory allocated by the shell API

    if (!path_appdata) {
        // TODO: Set last error message
        return NULL;
    }

    // Now, construct the full path: %APPDATA%\app_name
    // +1 for separator, +1 for null terminator
    size_t final_len = strlen(path_appdata) + 1 + strlen(app_name) + 1;
    char* final_path = (char*)malloc(final_len);
    if (!final_path) {
        free(path_appdata);
        return NULL;
    }
    
    // snprintf is safer than strcpy/strcat
    snprintf(final_path, final_len, "%s\\%s", path_appdata, app_name);
    free(path_appdata);

    // Create the directory if it doesn't exist
    WCHAR* wide_final_path = _sit_utf8_to_wide(final_path);
    if (wide_final_path) {
        CreateDirectoryW(wide_final_path, NULL); // Fails harmlessly if it already exists
        free(wide_final_path);
    }

    return final_path;
#else // POSIX fallback
    const char* home_dir = getenv("HOME");
    if (!home_dir) return NULL;

    // Follow XDG Base Directory Spec: $XDG_DATA_HOME or fallback to ~/.local/share
    const char* xdg_data_home = getenv("XDG_DATA_HOME");
    char* base_path = NULL;
    if (xdg_data_home && xdg_data_home[0] != '\0') {
        base_path = strdup(xdg_data_home);
    } else {
        const char* fallback_suffix = "/.local/share";
        size_t len = strlen(home_dir) + strlen(fallback_suffix) + 1;
        base_path = (char*)malloc(len);
        if (base_path) snprintf(base_path, len, "%s%s", home_dir, fallback_suffix);
    }
    
    if (!base_path) return NULL;
    
    // TODO: Create the base directory if it doesn't exist.
    // mkdir(base_path, 0755);

    size_t final_len = strlen(base_path) + 1 + strlen(app_name) + 1;
    char* final_path = (char*)malloc(final_len);
    if (!final_path) {
        free(base_path);
        return NULL;
    }
    snprintf(final_path, final_len, "%s/%s", base_path, app_name);
    free(base_path);

    // TODO: Create the final directory.
    // mkdir(final_path, 0755);

    return final_path;
#endif
}

/**
 * @brief Get the path to the directory containing the executable.
 * @warning The returned string is dynamically allocated. The caller is **responsible for freeing this memory** using `free()`.
 * @return A new string containing the base path, or NULL on failure.
 */
SITAPI char* SituationGetBasePath(void) {
#if defined(_WIN32)
    WCHAR wide_path[MAX_PATH];
    DWORD len = GetModuleFileNameW(NULL, wide_path, MAX_PATH);
    if (len == 0 || len == MAX_PATH) {
        // TODO: Set last error: Path too long or other failure
        return NULL;
    }

    // Find the last backslash to get the directory part
    WCHAR* last_slash = wcsrchr(wide_path, L'\\');
    if (last_slash) {
        *last_slash = L'\0'; // Null-terminate at the slash to chop off the filename
    }

    return _sit_wide_to_utf8(wide_path);
#else // POSIX fallback
    char path_buf[1024] = {0};
    // readlink is the standard way on Linux
    ssize_t len = readlink("/proc/self/exe", path_buf, sizeof(path_buf) - 1);
    
    if (len != -1) {
        path_buf[len] = '\0'; // Null-terminate the result
        char* last_slash = strrchr(path_buf, '/');
        if (last_slash) {
            *last_slash = '\0';
        }
        return strdup(path_buf);
    }
    
    // Fallback for other systems or if /proc isn't available
    return strdup("."); // Current working directory
#endif
}

/**
 * @brief Join two path components with the correct OS separator.
 * @warning The returned string is dynamically allocated. The caller is **responsible for freeing this memory** using `free()`.
 * @return A new string containing the combined path.
 */
SITAPI char* SituationJoinPath(const char* base_path, const char* file_or_dir_name) {
    if (!base_path || !file_or_dir_name) return NULL;

#if defined(_WIN32)
    const char separator = '\\';
#else
    const char separator = '/';
#endif

    size_t base_len = strlen(base_path);
    if (base_len == 0) return strdup(file_or_dir_name);

    // Check if the base path already ends with a separator
    bool needs_separator = (base_path[base_len - 1] != '\\' && base_path[base_len - 1] != '/');
    
    size_t final_len = base_len + strlen(file_or_dir_name) + (needs_separator ? 1 : 0) + 1;
    char* final_path = (char*)malloc(final_len);
    if (!final_path) return NULL;

    strcpy(final_path, base_path);
    if (needs_separator) {
        final_path[base_len] = separator;
        final_path[base_len + 1] = '\0';
    }
    strcat(final_path, file_or_dir_name);

    return final_path;
}

/**
 * @brief Extracts the file name (including extension) from a full path.
 * @param full_path The full path to a file (e.g., "/data/assets/player.png").
 * @return A pointer to the start of the file name within the original string (e.g., "player.png").
 */
SITAPI const char* SituationGetFileName(const char* full_path) {
    if (!full_path) return NULL;

    const char* last_slash = strrchr(full_path, '/');
    const char* last_backslash = strrchr(full_path, '\\');

    const char* last_separator = (last_slash > last_backslash) ? last_slash : last_backslash;

    if (last_separator) {
        return last_separator + 1; // Return the character after the separator
    }

    return full_path; // No separator found, the whole string is the filename
}

/**
 * @brief Extracts the file extension from a path.
 * @param file_path The path to a file.
 * @return A pointer to the '.' in the file extension within the original string. Returns NULL if no extension.
 */
SITAPI const char* SituationGetFileExtension(const char* file_path) {
    if (!file_path) return NULL;
    
    // First, find the filename part to avoid matching dots in directory names
    const char* filename = SituationGetFileName(file_path);
    if (!filename) return NULL; // Should not happen if file_path is valid

    const char* last_dot = strrchr(filename, '.');

    // Return the pointer to the dot if it exists and is not the first character (e.g., ".bashrc")
    if (last_dot && last_dot != filename) {
        return last_dot;
    }

    return NULL; // No extension found
}


// --- File & Directory Queries ---

/**
 * @brief Checks if a file exists at the given path.
 * @param file_path The path to the file to check.
 * @return True if the file exists and is a regular file, false otherwise.
 */
SITAPI bool SituationFileExists(const char* file_path) {
    if (!file_path) return false;
#if defined(_WIN32)
    WIN32_FIND_DATAW find_data;
    WCHAR* wide_path = _sit_utf8_to_wide(file_path);
    if (wide_path == NULL) {
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "_sit_utf8_to_wide failed for file path.");
        return false; // Treat as not found if conversion fails
    }

    HANDLE handle = FindFirstFileW(wide_path, &find_data);
    free(wide_path); // Free the converted path regardless of FindFirstFileW result

    if (handle == INVALID_HANDLE_VALUE) {
        return false;
    }

    bool is_directory = (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
    FindClose(handle);

    return !is_directory; // Return true only if it's a file, not a directory
#else // POSIX
    struct stat st;
    if (stat(file_path, &st) != 0) return false; // Error or doesn't exist
    return S_ISREG(st.st_mode); // Check if it's a regular file
#endif
}

/**
 * @brief Checks if a directory exists at the given path.
 * @param dir_path The path to the directory to check.
 * @return True if the directory exists, false otherwise.
 */
SITAPI bool SituationDirectoryExists(const char* dir_path) {
    if (!dir_path) return false;
#if defined(_WIN32)
    WCHAR* wide_path = _sit_utf8_to_wide(dir_path);
    if (!wide_path) return false;

    DWORD attrib = GetFileAttributesW(wide_path);
    free(wide_path);

    // Check if it exists AND is a directory
    return (attrib != INVALID_FILE_ATTRIBUTES && (attrib & FILE_ATTRIBUTE_DIRECTORY));
#else // POSIX
    struct stat st;
    if (stat(dir_path, &st) != 0) return false; // Error or doesn't exist
    return S_ISDIR(st.st_mode); // Check if it's a directory
#endif
}

/**
 * @brief Gets the last modification time of a file.
 * @param file_path The path to the file.
 * @return The last modification time as a Unix timestamp (seconds since epoch), or 0 on failure.
 */
SITAPI long SituationGetFileModTime(const char* file_path) {
    if (!file_path) return 0;
#if defined(_WIN32)
    WCHAR* wide_path = _sit_utf8_to_wide(file_path);
    if (!wide_path) return 0;
    
    HANDLE hFile = CreateFileW(wide_path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    free(wide_path);

    if (hFile == INVALID_HANDLE_VALUE) {
        return 0;
    }

    FILETIME ft_write;
    if (!GetFileTime(hFile, NULL, NULL, &ft_write)) {
        CloseHandle(hFile);
        return 0;
    }
    CloseHandle(hFile);

    // Convert Windows FILETIME to Unix timestamp
    ULARGE_INTEGER uli;
    uli.LowPart = ft_write.dwLowDateTime;
    uli.HighPart = ft_write.dwHighDateTime;
    // The number of 100-nanosecond intervals between Jan 1, 1601 and Jan 1, 1970.
    const ULONGLONG EPOCH_DIFFERENCE = 116444736000000000ULL;
    return (long)((uli.QuadPart - EPOCH_DIFFERENCE) / 10000000L);
#else // POSIX
    struct stat st;
    if (stat(file_path, &st) != 0) return 0;
    return (long)st.st_mtime;
#endif
}

/**
 * @brief Deletes a file from the file system.
 * @param file_path The path to the file to be deleted.
 * @return True if the file was successfully deleted, false otherwise.
 */
SITAPI bool SituationDeleteFile(const char* file_path) {
    if (!file_path) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "file_path cannot be NULL.");
        return false;
    }
#if defined(_WIN32)
    WCHAR* wide_path = _sit_utf8_to_wide(file_path);
    if (!wide_path) {
        _SituationSetErrorFromCode(SITUATION_ERROR_PATH_INVALID, "Could not convert path to wide string.");
        return false;
    }
    
    BOOL result = DeleteFileW(wide_path);
    free(wide_path);

    if (result == 0) {
        _SituationSetFilesystemError("Failed to delete file", file_path);
        return false;
    }
    return true;
#else // POSIX/Standard C
    if (remove(file_path) != 0) {
        _SituationSetFilesystemError("Failed to delete file", file_path);
        return false;
    }
    return true;
#endif
}

/**
 * @brief Renames a file or directory.
 * @param old_path The current path of the file or directory.
 * @param new_path The new path for the file or directory.
 * @return True on success, false on failure.
 */
SITAPI bool SituationRenameFile(const char* old_path, const char* new_path) {
    return SituationMoveFile(old_path, new_path);
}

/**
 * @brief Renames or moves a file or directory. This function can move items across different drives on Windows. On POSIX, it will attempt a fast rename, and if that fails due to a cross-device link, it will fall back to a copy-and-delete operation.
 * @param old_path The current path of the file or directory.
 * @param new_path The new path for the file or directory.
 * @return True on success, false on failure.
 */
SITAPI bool SituationMoveFile(const char* old_path, const char* new_path) {
    if (!old_path || !new_path) return false;

#if defined(_WIN32)
    WCHAR* wide_old = _sit_utf8_to_wide(old_path);
    if (!wide_old) return false;
    WCHAR* wide_new = _sit_utf8_to_wide(new_path);
    if (!wide_new) { free(wide_old); return false; }
    
    BOOL result = MoveFileExW(wide_old, wide_new, MOVEFILE_REPLACE_EXISTING);
    free(wide_old);
    free(wide_new);
    
    if (result == 0) {
        _SituationSetFilesystemError("Failed to move/rename file", old_path);
        return false;
    }
    return true;
#else
    if (rename(old_path, new_path) == 0) {
        return true;
    }
    if (errno == EXDEV) {
        if (SituationCopyFile(old_path, new_path)) {
            return SituationDeleteFile(old_path);
        }
        _SituationSetFilesystemError("Failed to copy file during cross-device move", old_path);
        return false;
    }
    _SituationSetFilesystemError("Failed to move/rename file", old_path);
    return false;
#endif
}

/**
 * @brief Copies a file from a source path to a destination path.
 * @details If the destination file already exists, it will be overwritten.
 * @param source_path The path of the file to copy.
 * @param dest_path The path where the file will be copied to.
 * @return True on success, false on failure.
 */
SITAPI bool SituationCopyFile(const char* source_path, const char* dest_path) {
    if (!source_path || !dest_path) return false;

#if defined(_WIN32)
    WCHAR* wide_source = _sit_utf8_to_wide(source_path);
    if (!wide_source) return false;

    WCHAR* wide_dest = _sit_utf8_to_wide(dest_path);
    if (!wide_dest) {
        free(wide_source);
        return false;
    }

    // The final parameter (FALSE) means to overwrite the destination if it exists.
    BOOL result = CopyFileW(wide_source, wide_dest, FALSE);

    free(wide_source);
    free(wide_dest);
    return (result != 0);

#else // POSIX/Standard C manual implementation
    const int BUFFER_SIZE = 65536; // 64KB buffer for copying
    char buffer[BUFFER_SIZE];
    size_t bytes_read;

    FILE* source = fopen(source_path, "rb");
    if (!source) return false;

    FILE* dest = fopen(dest_path, "wb");
    if (!dest) {
        fclose(source);
        return false;
    }

    while ((bytes_read = fread(buffer, 1, BUFFER_SIZE, source)) > 0) {
        if (fwrite(buffer, 1, bytes_read, dest) != bytes_read) {
            // Write error occurred
            fclose(source);
            fclose(dest);
            return false;
        }
    }

    fclose(source);
    fclose(dest);
    
    // Check for read error from source file
    if (ferror(source)) {
        return false;
    }

    return true;
#endif
}

// --- Directory Operations ---
/**
 * @brief List files and subdirectories in a path.
 * @warning The returned list and its string contents are dynamically allocated. The caller is **responsible for freeing this memory** using `SituationFreeDirectoryFileList()`.
 * @param dir_path The path of the directory to list.
 * @return A list of file and directory names.
 */
SITAPI bool SituationCreateDirectory(const char* dir_path, bool create_parents) {
    if (!dir_path || dir_path[0] == '\0') {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "dir_path cannot be NULL or empty.");
        return false;
    }

    if (SituationDirectoryExists(dir_path)) {
        return true; // Already exists, success.
    }

    if (!create_parents) {
#if defined(_WIN32)
        WCHAR* wide_path = _sit_utf8_to_wide(dir_path);
        if (!wide_path) {
            _SituationSetErrorFromCode(SITUATION_ERROR_PATH_INVALID, "Could not convert path to wide string.");
            return false;
        }
        BOOL result = CreateDirectoryW(wide_path, NULL);
        free(wide_path);
        if (result == 0) {
            _SituationSetFilesystemError("Failed to create directory", dir_path);
            return false;
        }
        return true;
#else
        if (mkdir(dir_path, 0755) != 0) {
            _SituationSetFilesystemError("Failed to create directory", dir_path);
            return false;
        }
        return true;
#endif
    }

    char* path_copy = strdup(dir_path);
    if (!path_copy) {
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Could not duplicate path string for recursive create.");
        return false;
    }
    
    char* p = path_copy;
    bool success = true;

    // Handle drive letters or root on both platforms
    if (p[0] == '/') { p++; } // POSIX root
    else if (p[1] == ':' && (p[2] == '\\' || p[2] == '/')) { p += 3; } // Windows drive

    while (*p) {
        if (*p == '/' || *p == '\\') {
            *p = '\0';
            if (!SituationDirectoryExists(path_copy)) {
                if (!SituationCreateDirectory(path_copy, false)) { // Call non-recursive version
                    success = false;
                    break;
                }
            }
            *p = (p[-1] == ':') ? '\\' : '/'; // Restore separator
        }
        p++;
    }

    if (success) {
        success = SituationCreateDirectory(dir_path, false); // Create the final directory
    }

    free(path_copy);
    return success;
}

/**
 * @brief Deletes a directory and, optionally, all of its contents.
 * @param dir_path The path to the directory to delete.
 * @param recursive If true, perform a recursive deletion of all contents.
 * @return True if the directory was successfully deleted, false otherwise.
 */
SITAPI bool SituationDeleteDirectory(const char* dir_path, bool recursive) {
    if (!dir_path || !SituationDirectoryExists(dir_path)) {
        // TODO: Set last error: Invalid path or directory not found
        return false;
    }

    if (recursive) {
        int count = 0;
        char** entries = SituationListDirectoryFiles(dir_path, &count);
        if (entries) {
            bool all_deleted = true;
            for (int i = 0; i < count; i++) {
                char* full_entry_path = SituationJoinPath(dir_path, entries[i]);
                if (!full_entry_path) {
                    all_deleted = false;
                    continue; // Skip if path join fails
                }

                // Check if the entry is a file or a directory
                if (SituationDirectoryExists(full_entry_path)) {
                    // It's a directory, recurse
                    if (!SituationDeleteDirectory(full_entry_path, true)) {
                        all_deleted = false;
                    }
                } else {
                    // It's a file, delete it
                    if (!SituationDeleteFile(full_entry_path)) {
                        all_deleted = false;
                    }
                }
                free(full_entry_path);
            }
            SituationFreeDirectoryFileList(entries, count);

            if (!all_deleted) {
                // TODO: Set last error: Failed to delete one or more items within the directory
                return false; // Failed to empty the directory, so we can't delete it
            }
        }
    }

    // At this point, the directory should be empty. Proceed with deletion.
#if defined(_WIN32)
    WCHAR* wide_path = _sit_utf8_to_wide(dir_path);
    if (!wide_path) return false;
    BOOL result = RemoveDirectoryW(wide_path);
    free(wide_path);
    return (result != 0);
#else // POSIX
    return (rmdir(dir_path) == 0);
#endif
}

/**
 * @brief Lists the files and subdirectories within a given directory.
 * @param dir_path The path of the directory to scan.
 * @param out_count A pointer to an integer that will be filled with the number of entries found.
 * @return A dynamically allocated array of strings containing the names of the entries.
 *          The caller MUST free both the array itself and each string within it using SituationFreeDirectoryFileList.
 *          Returns NULL on failure.
 */
SITAPI char** SituationListDirectoryFiles(const char* dir_path, int* out_count) {
    if (!dir_path || !out_count) {
        if (out_count) *out_count = 0;
        return NULL;
    }
    *out_count = 0;

    int capacity = 32;
    char** files = (char**)malloc(capacity * sizeof(char*));
    if (!files) {
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Initial allocation for file list failed.");
        return NULL;
    }

#if defined(_WIN32)
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WCHAR* wide_search_path = NULL;
#else
    DIR* dir = NULL;
#endif

    char* new_entry_name = NULL;

#if defined(_WIN32)
    char search_path[MAX_PATH];
    snprintf(search_path, MAX_PATH, "%s\\*", dir_path);

    wide_search_path = _sit_utf8_to_wide(search_path);
    if (!wide_search_path) goto error_cleanup;

    WIN32_FIND_DATAW find_data;
    hFind = FindFirstFileW(wide_search_path, &find_data);
    free(wide_search_path);
    wide_search_path = NULL; // Prevent double-free in cleanup

    if (hFind == INVALID_HANDLE_VALUE) goto success_cleanup; // Not an error, just empty/no dir

    do {
        if (wcscmp(find_data.cFileName, L".") == 0 || wcscmp(find_data.cFileName, L"..") == 0) {
            continue;
        }
        new_entry_name = _sit_wide_to_utf8(find_data.cFileName);
#else // POSIX
    dir = opendir(dir_path);
    if (!dir) goto success_cleanup; // Not an error, just empty/no dir

    struct dirent* entry;
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            continue;
        }
        new_entry_name = strdup(entry->d_name);
#endif
        // --- COMMON LOGIC BLOCK ---
        if (!new_entry_name) {
            _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "strdup/_sit_wide_to_utf8 failed.");
            goto error_cleanup;
        }

        if (*out_count >= capacity) {
            capacity *= 2;
            char** temp_files = (char**)realloc(files, capacity * sizeof(char*));
            if (!temp_files) {
                // realloc failed. 'files' is still valid. 'new_entry_name' must be freed.
                free(new_entry_name);
                new_entry_name = NULL;
                _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "realloc failed.");
                goto error_cleanup;
            }
            files = temp_files;
        }

        files[*out_count] = new_entry_name;
        new_entry_name = NULL; // Ownership transferred to the 'files' array
        (*out_count)++;
        // --- END COMMON LOGIC BLOCK ---
#if defined(_WIN32)
    } while (FindNextFileW(hFind, &find_data) != 0);
#else
    }
#endif

success_cleanup:
#if defined(_WIN32)
    if (hFind != INVALID_HANDLE_VALUE) FindClose(hFind);
#else
    if (dir) closedir(dir);
#endif
    return files;

error_cleanup:
    // This block handles cleanup for any failure path.
    SituationFreeDirectoryFileList(files, *out_count);
#if defined(_WIN32)
    free(wide_search_path); // Safe to call on NULL
    if (hFind != INVALID_HANDLE_VALUE) FindClose(hFind);
#else
    if (dir) closedir(dir);
#endif
    return NULL;
}

/**
 * @brief Frees the memory allocated by SituationListDirectoryFiles.
 * @param file_list The array of strings returned by SituationListDirectoryFiles.
 * @param count The number of entries in the array.
 */
SITAPI void SituationFreeDirectoryFileList(char** file_list, int count) {
    if (!file_list) return;
    for (int i = 0; i < count; i++) {
        free(file_list[i]);
    }
    free(file_list);
}


// --- File Operations ---

/**
 * @brief [INTERNAL] Sets a detailed filesystem error message including the OS-specific reason.
 * @details This function now attempts to map common OS-level error codes to the more specific SituationError enums for better diagnostics.
 * @param base_message A string describing the operation that failed (e.g., "Failed to create directory").
 * @param path The file or directory path that was involved in the failed operation.
 */
static void _SituationSetFilesystemError(const char* base_message, const char* path) {
    char platform_error_str[256] = {0};
    SituationError specific_error_code = SITUATION_ERROR_FILE_ACCESS; // Default to a generic file error

#if defined(_WIN32)
    DWORD error_code = GetLastError();
    if (error_code != 0) {
        // --- [NEW] Map Windows error codes to our enums ---
        switch (error_code) {
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                specific_error_code = SITUATION_ERROR_PATH_NOT_FOUND;
                break;
            case ERROR_ACCESS_DENIED:
                specific_error_code = SITUATION_ERROR_PERMISSION_DENIED;
                break;
            case ERROR_SHARING_VIOLATION:
            case ERROR_LOCK_VIOLATION:
                specific_error_code = SITUATION_ERROR_FILE_LOCKED;
                break;
            case ERROR_HANDLE_DISK_FULL:
                specific_error_code = SITUATION_ERROR_DISK_FULL;
                break;
            case ERROR_ALREADY_EXISTS:
            case ERROR_FILE_EXISTS:
                specific_error_code = SITUATION_ERROR_FILE_ALREADY_EXISTS;
                break;
            case ERROR_DIR_NOT_EMPTY:
                specific_error_code = SITUATION_ERROR_DIR_NOT_EMPTY;
                break;
            // Add other mappings as needed...
        }

        // Get the descriptive string from the OS
        FormatMessageA(
            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL, error_code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            platform_error_str, sizeof(platform_error_str) - 1, NULL
        );
        // Clean up trailing newline characters from FormatMessageA
        size_t len = strlen(platform_error_str);
        if (len > 1 && platform_error_str[len-2] == '\r') platform_error_str[len-2] = '\0';
    } else {
        strncpy(platform_error_str, "No system error code reported.", sizeof(platform_error_str) - 1);
    }
#else
    #include <errno.h>
    int err_num = errno; // Capture errno immediately

    // --- Map POSIX error codes to our enums ---
    switch (err_num) {
        case ENOENT:
            specific_error_code = SITUATION_ERROR_PATH_NOT_FOUND;
            break;
        case EACCES:
        case EPERM:
            specific_error_code = SITUATION_ERROR_PERMISSION_DENIED;
            break;
        case EBUSY:
            specific_error_code = SITUATION_ERROR_FILE_LOCKED;
            break;
        case ENOSPC:
            specific_error_code = SITUATION_ERROR_DISK_FULL;
            break;
        case EEXIST:
            specific_error_code = SITUATION_ERROR_FILE_ALREADY_EXISTS;
            break;
        case ENOTEMPTY:
            specific_error_code = SITUATION_ERROR_DIR_NOT_EMPTY;
            break;
        case ENOTDIR:
            specific_error_code = SITUATION_ERROR_PATH_IS_FILE;
            break;
        case EISDIR:
            specific_error_code = SITUATION_ERROR_PATH_IS_DIRECTORY;
            break;
        // Add other mappings as needed...
    }

    // Get the descriptive string from the OS
    strncpy(platform_error_str, strerror(err_num), sizeof(platform_error_str) - 1);
#endif

    char final_message[SITUATION_MAX_ERROR_MSG_LEN];
    snprintf(final_message, sizeof(final_message), "%s: '%s' - %s", base_message, path, platform_error_str);
    
    // Use the specific error code we determined, with the full message as detail.
    _SituationSetErrorFromCode(specific_error_code, final_message);
}

/**
 * @brief Load an entire file into a memory buffer.
 * @warning The returned buffer is dynamically allocated. The caller is **responsible for freeing this memory** using `free()`.
 * @param file_path The path to the file to load.
 * @param out_bytes_read A pointer that will be filled with the number of bytes read.
 * @return A new buffer containing the file data, or NULL on failure.
 */
SITAPI unsigned char* SituationLoadFileData(const char* file_path, unsigned int* out_bytes_read) {
    if (!file_path) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "file_path cannot be NULL.");
        if (out_bytes_read) *out_bytes_read = 0;
        return NULL;
    }
    if (!out_bytes_read) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "out_bytes_read cannot be NULL.");
        return NULL;
    }
    *out_bytes_read = 0;

#if defined(_WIN32)
    WCHAR* wide_path = _sit_utf8_to_wide(file_path);
    if (!wide_path) {
        _SituationSetErrorFromCode(SITUATION_ERROR_PATH_INVALID, "Could not convert path to wide string (check for invalid UTF-8 characters).");
        return NULL;
    }

    HANDLE hFile = CreateFileW(wide_path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    free(wide_path);

    if (hFile == INVALID_HANDLE_VALUE) {
        _SituationSetFilesystemError("Failed to open file for reading", file_path);
        return NULL;
    }

    LARGE_INTEGER file_size;
    if (!GetFileSizeEx(hFile, &file_size)) {
        _SituationSetFilesystemError("Failed to get file size", file_path);
        CloseHandle(hFile);
        return NULL;
    }
    
    if (file_size.QuadPart > 0xFFFFFFFF) {
        _SituationSetErrorFromCode(SITUATION_ERROR_FILE_ACCESS, "File is too large (>4GB).");
        CloseHandle(hFile);
        return NULL;
    }
    
    unsigned int size_to_read = (unsigned int)file_size.QuadPart;
    if (size_to_read == 0) {
        CloseHandle(hFile);
        *out_bytes_read = 0;
        return (unsigned char*)malloc(1); // Return valid, empty buffer.
    }

    unsigned char* buffer = (unsigned char*)malloc(size_to_read);
    if (!buffer) {
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Failed to allocate buffer for file data.");
        CloseHandle(hFile);
        return NULL;
    }

    DWORD bytes_read_win = 0;
    if (!ReadFile(hFile, buffer, size_to_read, &bytes_read_win, NULL) || bytes_read_win != size_to_read) {
        _SituationSetFilesystemError("Error during file read", file_path);
        free(buffer);
        CloseHandle(hFile);
        return NULL;
    }

    CloseHandle(hFile);
    *out_bytes_read = size_to_read;
    return buffer;

#else // Standard C library implementation (POSIX)
    FILE* file = fopen(file_path, "rb");
    if (!file) {
        _SituationSetFilesystemError("Failed to open file for reading", file_path);
        return NULL;
    }

    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    fseek(file, 0, SEEK_SET);

    if (file_size < 0) {
        _SituationSetFilesystemError("Failed to get file size", file_path);
        fclose(file);
        return NULL;
    }
    
    unsigned int size_to_read = (unsigned int)file_size;
    if (size_to_read == 0) {
        fclose(file);
        *out_bytes_read = 0;
        return (unsigned char*)malloc(1);
    }

    unsigned char* buffer = (unsigned char*)malloc(size_to_read);
    if (!buffer) {
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Failed to allocate buffer for file data.");
        fclose(file);
        return NULL;
    }

    size_t read_count = fread(buffer, 1, size_to_read, file);
    if (read_count != size_to_read) {
        _SituationSetFilesystemError("Error during file read", file_path);
        free(buffer);
        fclose(file);
        return NULL;
    }

    fclose(file);
    *out_bytes_read = size_to_read;
    return buffer;
#endif
}

/**
 * @brief Saves a block of memory to a file, overwriting it if it exists.
 * @param file_path The path to the file to save.
 * @param data A pointer to the data to write.
 * @param bytes_to_write The number of bytes to write from the data buffer.
 * @return True on success, false on failure.
 */
SITAPI bool SituationSaveFileData(const char* file_path, const void* data, unsigned int bytes_to_write) {
    if (!file_path) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "file_path cannot be NULL.");
        return false;
    }
    if (!data && bytes_to_write > 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "data cannot be NULL when bytes_to_write is > 0.");
        return false;
    }

#if defined(_WIN32)
    WCHAR* wide_path = _sit_utf8_to_wide(file_path);
    if (!wide_path) {
        _SituationSetErrorFromCode(SITUATION_ERROR_PATH_INVALID, "Could not convert path to wide string.");
        return false;
    }

    HANDLE hFile = CreateFileW(wide_path, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    free(wide_path);

    if (hFile == INVALID_HANDLE_VALUE) {
        _SituationSetFilesystemError("Failed to create file for writing", file_path);
        return false;
    }

    if (bytes_to_write > 0) {
        DWORD bytes_written = 0;
        if (!WriteFile(hFile, data, bytes_to_write, &bytes_written, NULL) || bytes_written != bytes_to_write) {
            _SituationSetFilesystemError("Error during file write", file_path);
            CloseHandle(hFile);
            return false;
        }
    }

    CloseHandle(hFile);
    return true;

#else // Standard C library implementation
    FILE* file = fopen(file_path, "wb");
    if (!file) {
        _SituationSetFilesystemError("Failed to create file for writing", file_path);
        return false;
    }

    if (bytes_to_write > 0) {
        if (fwrite(data, 1, bytes_to_write, file) != bytes_to_write) {
            _SituationSetFilesystemError("Error during file write", file_path);
            fclose(file);
            return false;
        }
    }

    fclose(file);
    return true;
#endif
}

/**
 * @brief Load a text file into a null-terminated string.
 * @warning The returned string is dynamically allocated. The caller is **responsible for freeing this memory** using `free()`.
 * @param file_path The path to the text file to load.
 * @return A new null-terminated string containing the file text, or NULL on failure.
 */
SITAPI char* SituationLoadFileText(const char* file_path) {
    if (!file_path) return NULL;

    unsigned int bytes_read = 0;
    unsigned char* file_data = SituationLoadFileData(file_path, &bytes_read);

    if (!file_data) {
        return NULL; // Load failed, error message is already set by the underlying function.
    }

    // Allocate a new buffer that is one byte larger for the null terminator.
    char* text_buffer = (char*)malloc(bytes_read + 1);
    if (!text_buffer) {
        // TODO: Set last error message: "Memory allocation failed"
        free(file_data);
        return NULL;
    }

    // Copy the file data and null-terminate it.
    memcpy(text_buffer, file_data, bytes_read);
    text_buffer[bytes_read] = '\0';

    free(file_data); // Free the original buffer.

    return text_buffer;
}

/**
 * @brief Saves a null-terminated string to a text file.
 * @param file_path The path to the file to save.
 * @param text The null-terminated string to write.
 * @return True on success, false on failure.
 */
SITAPI bool SituationSaveFileText(const char* file_path, const char* text) {
    if (!file_path || !text) {
        // TODO: Set last error message: "Invalid parameter"
        return false;
    }
    
    // Use strlen to get the number of bytes to write, excluding the null terminator.
    // The file on disk doesn't need to be null-terminated.
    unsigned int len = (unsigned int)strlen(text);

    return SituationSaveFileData(file_path, text, len);
}

static void _SituationCachePhysicalDisplays(void) {
    if (!sit_gs.is_initialized) return;
    if (sit_gs.cached_physical_displays_array) {
        for (int i = 0; i < sit_gs.cached_physical_display_count; ++i) {
            free(sit_gs.cached_physical_displays_array[i].available_modes);
        }
        free(sit_gs.cached_physical_displays_array);
        sit_gs.cached_physical_displays_array = NULL;
        sit_gs.cached_physical_display_count = 0;
    }
    #if defined(_WIN32)
    int win32_monitor_count = GetSystemMetrics(SM_CMONITORS);
    if (win32_monitor_count <= 0) { 
        _SituationSetError("No physical monitors reported by GetSystemMetrics(SM_CMONITORS)."); return; 
    }
    sit_gs.cached_physical_displays_array = (SituationDisplayInfo*)calloc(win32_monitor_count, sizeof(SituationDisplayInfo));
    if (!sit_gs.cached_physical_displays_array) { 
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Physical displays cache"); return; 
    }
    int glfw_monitor_count;
    GLFWmonitor** glfw_monitors = glfwGetMonitors(&glfw_monitor_count);
    _SituationMonitorEnumData enum_data = {
        .displays_array = sit_gs.cached_physical_displays_array,
        .max_displays = win32_monitor_count,
        .current_display_idx = 0,
        .glfw_monitors = glfw_monitors,
        .glfw_monitor_count = glfw_monitor_count
    };
    if (!EnumDisplayMonitors(NULL, NULL, _SituationMonitorEnumProc, (LPARAM)&enum_data)) {
        _SituationSetError("EnumDisplayMonitors failed.");
        for (int i = 0; i < enum_data.current_display_idx; ++i) free(sit_gs.cached_physical_displays_array[i].available_modes);
        free(sit_gs.cached_physical_displays_array); sit_gs.cached_physical_displays_array = NULL;
        return;
    }
    sit_gs.cached_physical_display_count = enum_data.current_display_idx;
    #else
    int glfw_count;
    GLFWmonitor** monitors = glfwGetMonitors(&glfw_count);
    if (glfw_count > 0) {
        sit_gs.cached_physical_displays_array = (SituationDisplayInfo*)calloc(glfw_count, sizeof(SituationDisplayInfo));
        if (!sit_gs.cached_physical_displays_array) { 
            _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Physical displays cache (non-Win32)"); return; 
        }
        sit_gs.cached_physical_display_count = glfw_count;
        for (int i = 0; i < glfw_count; ++i) {
            SituationDisplayInfo* disp = &sit_gs.cached_physical_displays_array[i];
            disp->situation_monitor_id = i;
            disp->glfw_monitor_handle = monitors[i];
            const char* name = glfwGetMonitorName(monitors[i]);
            if (name) { strncpy(disp->name, name, SITUATION_MAX_MONITOR_NAME_LEN-1); disp->name[SITUATION_MAX_MONITOR_NAME_LEN-1] = '\0'; }
            else { snprintf(disp->name, SITUATION_MAX_MONITOR_NAME_LEN, "GLFW Monitor %d", i); }
            disp->is_primary = (monitors[i] == glfwGetPrimaryMonitor());
            const GLFWvidmode* mode = glfwGetVideoMode(monitors[i]);
            if (mode) {
                disp->current_mode.width = mode->width;
                disp->current_mode.height = mode->height;
                disp->current_mode.refresh_rate = mode->refreshRate;
                disp->current_mode.color_depth = mode->redBits + mode->greenBits + mode->blueBits;
            }
            int vid_mode_count;
            const GLFWvidmode* vid_modes = glfwGetVideoModes(monitors[i], &vid_mode_count);
            if (vid_mode_count > 0) {
                disp->available_modes = (SituationDisplayMode*)malloc(vid_mode_count * sizeof(SituationDisplayMode));
                if (disp->available_modes) {
                    disp->available_mode_count = vid_mode_count;
                    for (int j = 0; j < vid_mode_count; ++j) {
                        disp->available_modes[j].width = vid_modes[j].width;
                        disp->available_modes[j].height = vid_modes[j].height;
                        disp->available_modes[j].refresh_rate = vid_modes[j].refreshRate;
                        disp->available_modes[j].color_depth = vid_modes[j].redBits + vid_modes[j].greenBits + vid_modes[j].blueBits;
                    }
                } else { 
                    disp->available_mode_count = 0; 
                    _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Available modes for GLFW monitor"); 
                }
            } else { disp->available_mode_count = 0; }
        }
    } else {
        _SituationSetError("No monitors reported by GLFW.");
    }
    #endif
}

/**
 * @brief Retrieves information about all connected physical displays.
 * @warning This function returns a dynamically allocated array of structs. The caller is RESPONSIBLE FOR FREEING THIS MEMORY. This requires a nested deallocation:first, loop through the array and free the `available_modes` pointer for each display, then free the top-level array itself.
 *
 * @example
 *   int display_count = 0;
 *   SituationDisplayInfo* displays = SituationGetDisplays(&display_count);
 *   if (displays) {
 *       // ... use the display info ...
 *
 *       // --- CRITICAL: Correct cleanup ---
 *       for (int i = 0; i < display_count; ++i) {
 *           free(displays[i].available_modes);
 *       }
 *       free(displays);
 *   }
 *
 * @param count Pointer to an integer that will be filled with the number of displays found.
 * @return A pointer to a newly allocated array of SituationDisplayInfo structs, or NULL on failure.
 */
SITAPI SituationDisplayInfo* SituationGetDisplays(int* count) {
    if (!sit_gs.is_initialized) { _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "GetDisplays"); if (count) *count = 0; return NULL; }
    if (!sit_gs.cached_physical_displays_array) _SituationCachePhysicalDisplays();
    if (!sit_gs.cached_physical_displays_array || sit_gs.cached_physical_display_count == 0) { 
        _SituationSetErrorFromCode(SITUATION_ERROR_DISPLAY_QUERY, "No cached displays or count is zero"); 
        if (count) *count = 0; 
        return NULL; 
    }
    SituationDisplayInfo* displays_copy = (SituationDisplayInfo*)malloc(sit_gs.cached_physical_display_count * sizeof(SituationDisplayInfo));
    if (!displays_copy) { _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Copy of display infos"); if (count) *count = 0; return NULL; }
    for (int i = 0; i < sit_gs.cached_physical_display_count; ++i) {
        memcpy(&displays_copy[i], &sit_gs.cached_physical_displays_array[i], sizeof(SituationDisplayInfo));
        if (sit_gs.cached_physical_displays_array[i].available_mode_count > 0 && sit_gs.cached_physical_displays_array[i].available_modes) {
            displays_copy[i].available_modes = (SituationDisplayMode*)malloc(displays_copy[i].available_mode_count * sizeof(SituationDisplayMode));
            if (displays_copy[i].available_modes) {
                memcpy(displays_copy[i].available_modes, sit_gs.cached_physical_displays_array[i].available_modes, displays_copy[i].available_mode_count * sizeof(SituationDisplayMode));
            } else { 
                displays_copy[i].available_modes = NULL; 
                displays_copy[i].available_mode_count = 0; 
                _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Copy of available modes for one display");
            }
        } else {
            displays_copy[i].available_modes = NULL;
            displays_copy[i].available_mode_count = 0;
        }
    }
    if (count) *count = sit_gs.cached_physical_display_count;
    return displays_copy;
}

SITAPI void SituationRefreshDisplays(void) {
    if (!sit_gs.is_initialized) { _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "RefreshDisplays"); return; }
    _SituationCachePhysicalDisplays();
}

SITAPI int _SituationGetCurrentDisplayIdentifier(void) {
    if (!sit_gs.is_initialized || !sit_gs.sit_glfw_window) { _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "GetCurrentDisplayIdentifier"); return -1; }
    GLFWmonitor* current_glfw_monitor = glfwGetWindowMonitor(sit_gs.sit_glfw_window);
    if (!current_glfw_monitor) {
        int win_x, win_y, win_w, win_h;
        glfwGetWindowPos(sit_gs.sit_glfw_window, &win_x, &win_y);
        glfwGetWindowSize(sit_gs.sit_glfw_window, &win_w, &win_h); 
        if (win_w <=0 || win_h <=0) { 
            win_w = sit_gs.main_window_width; win_h = sit_gs.main_window_height;
        }
        Rectangle window_rect = {(float)win_x, (float)win_y, (float)win_w, (float)win_h};
        current_glfw_monitor = glfwGetPrimaryMonitor();
        int max_overlap = 0;
        if (sit_gs.cached_physical_display_count == 0) _SituationCachePhysicalDisplays();
        for (int i = 0; i < sit_gs.cached_physical_display_count; ++i) {
            if (sit_gs.cached_physical_displays_array[i].glfw_monitor_handle) {
                GLFWmonitor* mon_handle = sit_gs.cached_physical_displays_array[i].glfw_monitor_handle;
                const GLFWvidmode* mode = glfwGetVideoMode(mon_handle);
                int mon_x, mon_y;
                glfwGetMonitorPos(mon_handle, &mon_x, &mon_y);
                if (mode) { 
                    Rectangle monitor_rect = {(float)mon_x, (float)mon_y, (float)mode->width, (float)mode->height};
                    float overlap_x_dim = fmaxf(0.0f, fminf(window_rect.x + window_rect.width, monitor_rect.x + monitor_rect.width) - fmaxf(window_rect.x, monitor_rect.x));
                    float overlap_y_dim = fmaxf(0.0f, fminf(window_rect.y + window_rect.height, monitor_rect.y + monitor_rect.height) - fmaxf(window_rect.y, monitor_rect.y));
                    int current_overlap_area = (int)(overlap_x_dim * overlap_y_dim);
                    if (current_overlap_area > max_overlap) {
                        max_overlap = current_overlap_area;
                        current_glfw_monitor = mon_handle;
                    }
                }
            }
        }
    }
    for (int i = 0; i < sit_gs.cached_physical_display_count; ++i) {
        if (sit_gs.cached_physical_displays_array[i].glfw_monitor_handle == current_glfw_monitor) {
            return sit_gs.cached_physical_displays_array[i].situation_monitor_id;
        }
    }
    if (current_glfw_monitor == glfwGetPrimaryMonitor() && sit_gs.cached_physical_display_count > 0) {
        for (int i = 0; i < sit_gs.cached_physical_display_count; ++i) {
            if (sit_gs.cached_physical_displays_array[i].is_primary) return sit_gs.cached_physical_displays_array[i].situation_monitor_id;
        }
    }
    return -1;
}


SITAPI SituationError SituationSetDisplayMode(int situation_monitor_id, const SituationDisplayMode* mode, bool fullscreen) {
    if (!sit_gs.is_initialized || !sit_gs.sit_glfw_window) return SITUATION_ERROR_NOT_INITIALIZED;
    if (!mode) return SITUATION_ERROR_INVALID_PARAM;
    if (situation_monitor_id < 0 || situation_monitor_id >= sit_gs.cached_physical_display_count || !sit_gs.cached_physical_displays_array) {
         _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Invalid situation_monitor_id or display cache empty");
        return SITUATION_ERROR_INVALID_PARAM;
    }
    SituationDisplayInfo* target_display_info = &sit_gs.cached_physical_displays_array[situation_monitor_id];
    GLFWmonitor* glfw_mon = target_display_info->glfw_monitor_handle;
    if (!glfw_mon) {
        _SituationSetErrorFromCode(SITUATION_ERROR_DISPLAY_QUERY, "No GLFW monitor handle for specified Situation ID. Cannot set mode via GLFW.");
        #if !defined(_WIN32)
        return SITUATION_ERROR_DISPLAY_QUERY;
        #endif
    }
#if defined(_WIN32)
    if (target_display_info->name[0] != '\0') {
        DEVMODEA dev_mode = {0};
        dev_mode.dmSize = sizeof(DEVMODEA);
        strncpy((char*)dev_mode.dmDeviceName, target_display_info->name, CCHDEVICENAME -1);
        dev_mode.dmDeviceName[CCHDEVICENAME-1] = '\0';
        dev_mode.dmPelsWidth = mode->width;
        dev_mode.dmPelsHeight = mode->height;
        dev_mode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
        if (mode->refresh_rate > 0) { dev_mode.dmDisplayFrequency = mode->refresh_rate; dev_mode.dmFields |= DM_DISPLAYFREQUENCY; }
        if (mode->color_depth > 0) { dev_mode.dmBitsPerPel = mode->color_depth; dev_mode.dmFields |= DM_BITSPERPEL; }
        LONG cds_result;
        DWORD flags = fullscreen ? CDS_FULLSCREEN : 0;
        if (fullscreen) {
             cds_result = ChangeDisplaySettingsExA(target_display_info->name, &dev_mode, NULL, flags, NULL);
        } else {
             cds_result = ChangeDisplaySettingsExA(target_display_info->name, NULL, NULL, 0, NULL); 
        }
        if (cds_result != DISP_CHANGE_SUCCESSFUL) {
            char err_detail[128];
            snprintf(err_detail, sizeof(err_detail), "Win32 ChangeDisplaySettingsExA for '%s' failed with code %ld.", target_display_info->name, cds_result);
            _SituationSetErrorFromCode(SITUATION_ERROR_DISPLAY_SET, err_detail);
            if (!glfw_mon) return SITUATION_ERROR_DISPLAY_SET;
        } else {
             SituationRefreshDisplays();
        }
    } else if (!glfw_mon) {
        _SituationSetErrorFromCode(SITUATION_ERROR_DISPLAY_QUERY, "No Win32 device name and no GLFW monitor for SetDisplayMode.");
        return SITUATION_ERROR_DISPLAY_QUERY;
    }
#endif
    if (glfw_mon) {
        if (fullscreen) {
            glfwSetWindowMonitor(sit_gs.sit_glfw_window, glfw_mon, 0, 0, mode->width, mode->height, mode->refresh_rate > 0 ? mode->refresh_rate : GLFW_DONT_CARE);
        } else {
            const GLFWvidmode* current_mon_mode = glfwGetVideoMode(glfw_mon);
            int win_x = 0, win_y = 0;
            if(current_mon_mode) { 
                int mon_x_pos, mon_y_pos;
                glfwGetMonitorPos(glfw_mon, &mon_x_pos, &mon_y_pos);
                win_x = mon_x_pos + (current_mon_mode->width - mode->width) / 2;
                win_y = mon_y_pos + (current_mon_mode->height - mode->height) / 2;
            } else {
                GLFWmonitor* primary = glfwGetPrimaryMonitor();
                const GLFWvidmode* primary_mode = glfwGetVideoMode(primary);
                if(primary_mode) {
                     win_x = (primary_mode->width - mode->width) / 2;
                     win_y = (primary_mode->height - mode->height) / 2;
                } else { win_x = 100; win_y = 100; }
            }
            glfwSetWindowMonitor(sit_gs.sit_glfw_window, NULL, win_x, win_y, mode->width, mode->height, GLFW_DONT_CARE);
        }
    } else {
        #if defined(_WIN32)
        // Error handling already done if WinAPI failed.
        #else
        return SITUATION_ERROR_DISPLAY_QUERY;
        #endif
    }
    int fb_w, fb_h;
    glfwGetFramebufferSize(sit_gs.sit_glfw_window, &fb_w, &fb_h);
    _SituationGLFWFramebufferSizeCallback(sit_gs.sit_glfw_window, fb_w, fb_h);
    SituationRefreshDisplays();
    return SITUATION_SUCCESS;
}

#if defined(SITUATION_USE_VULKAN)
/**
 * @brief [INTERNAL] Creates a VkImage and allocates its memory using VMA.
 * @details This is a core Vulkan helper function that abstracts the creation of an image and the allocation of its device memory. It uses the Vulkan Memory Allocator (VMA) to handle the memory binding, which is the recommended practice.
 *
 * @param width The width of the image in pixels.
 * @param height The height of the image in pixels.
 * @param format The pixel format of the image (e.g., VK_FORMAT_R8G8B8A8_SRGB).
 * @param tiling The tiling arrangement for texels (VK_IMAGE_TILING_OPTIMAL for GPU-only, VK_IMAGE_TILING_LINEAR for CPU access).
 * @param usage A bitmask of VkImageUsageFlagBits specifying how the image will be used (e.g., as a color attachment, a sampled texture, etc.).
 * @param memory_usage A VmaMemoryUsage hint for the allocator (e.g., VMA_MEMORY_USAGE_GPU_ONLY for high-performance device memory).
 * @param out_image A pointer to a VkImage handle that will be filled with the created image.
 * @param out_allocation A pointer to a VmaAllocation handle that will be filled with the memory allocation information for the image.
 * @return SITUATION_SUCCESS on success, or SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED on failure.
 */
static SituationError _SituationVulkanCreateImage(uint32_t width, uint32_t height, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VmaMemoryUsage memory_usage, VkImage* out_image, VmaAllocation* out_allocation) {
    VkImageCreateInfo image_info = {};
    image_info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    image_info.imageType = VK_IMAGE_TYPE_2D;
    image_info.extent.width = width;
    image_info.extent.height = height;
    image_info.extent.depth = 1;
    image_info.mipLevels = 1;
    image_info.arrayLayers = 1;
    image_info.format = format;
    image_info.tiling = tiling;
    image_info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    image_info.usage = usage;
    image_info.samples = VK_SAMPLE_COUNT_1_BIT;
    image_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    VmaAllocationCreateInfo alloc_info = {};
    alloc_info.usage = memory_usage;

    if (vmaCreateImage(sit_gs.vk.vma_allocator, &image_info, &alloc_info, out_image, out_allocation, NULL) != VK_SUCCESS) {
        return SITUATION_ERROR_VULKAN_MEMORY_ALLOC_FAILED;
    }
    return SITUATION_SUCCESS;
}

/**
 * @brief [INTERNAL] Creates a VkImageView for a given VkImage.
 * @details An image view is a mandatory component that describes how to access a VkImage and which parts of it are accessible. It specifies metadata like the format and aspect (e.g., color, depth, stencil) without which the GPU cannot interpret the image data.
 *
 * @param image The VkImage for which to create a view.
 * @param format The pixel format, which must be compatible with the format of the source image.
 * @param aspect_flags A bitmask of VkImageAspectFlagBits specifying which aspect of the image the view will access (e.g., VK_IMAGE_ASPECT_COLOR_BIT for color textures, VK_IMAGE_ASPECT_DEPTH_BIT for depth buffers).
 * @return A valid VkImageView handle on success, or VK_NULL_HANDLE on failure.
 */
static VkImageView _SituationVulkanCreateImageView(VkImage image, VkFormat format, VkImageAspectFlags aspect_flags) {
    VkImageViewCreateInfo view_info = {};
    view_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    view_info.image = image;
    view_info.viewType = VK_IMAGE_VIEW_TYPE_2D;
    view_info.format = format;
    view_info.subresourceRange.aspectMask = aspect_flags;
    view_info.subresourceRange.baseMipLevel = 0;
    view_info.subresourceRange.levelCount = 1;
    view_info.subresourceRange.baseArrayLayer = 0;
    view_info.subresourceRange.layerCount = 1;

    VkImageView image_view;
    if (vkCreateImageView(sit_gs.vk.device, &view_info, NULL, &image_view) != VK_SUCCESS) {
        return VK_NULL_HANDLE;
    }
    return image_view;
}

/**
 * @brief [Internal] Creates a Vulkan shader module from SPIR-V bytecode.
 * @param code Pointer to the SPIR-V bytecode.
 * @param code_size Size of the SPIR-V bytecode in bytes.
 * @return A valid VkShaderModule on success, or VK_NULL_HANDLE on failure.
 */
static VkShaderModule _SituationVulkanCreateShaderModule(const void* code, size_t code_size) {
    if (!code || code_size == 0) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Shader code is NULL or size is zero in _SituationVulkanCreateShaderModule.");
        return VK_NULL_HANDLE;
    }

    VkShaderModuleCreateInfo create_info = {0};
    create_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    create_info.codeSize = code_size;
    // Cast away const for pCode (Vulkan spec allows this for SPIR-V blobs)
    create_info.pCode = (const uint32_t*)code;

    VkShaderModule shader_module;
    VkResult result = vkCreateShaderModule(sit_gs.vk.device, &create_info, NULL, &shader_module);
    if (result != VK_SUCCESS) {
        char err_msg[256];
        snprintf(err_msg, sizeof(err_msg), "vkCreateShaderModule failed: VkResult = %d", (int)result);
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_SHADER_MODULE_FAILED, err_msg);
        return VK_NULL_HANDLE;
    }

    return shader_module;
}

/**
 * @brief [INTERNAL] Creates a complete Vulkan graphics pipeline from SPIR-V bytecode.
 * @details This is a generic and powerful helper function that encapsulates the complexity of Vulkan pipeline creation. It takes compiled SPIR-V, a pre-created pipeline layout, and vertex format descriptions to build a complete, ready-to-use VkPipeline object.
 *
 * @param vs_data A pointer to the raw SPIR-V bytecode for the vertex shader.
 * @param vs_size The size of the vertex shader bytecode in bytes.
 * @param fs_data A pointer to the raw SPIR-V bytecode for the fragment shader.
 * @param fs_size The size of the fragment shader bytecode in bytes.
 * @param pipelineLayout The pre-created VkPipelineLayout that defines the descriptor sets and push constants this pipeline will use.
 * @param topology The primitive topology (e.g., triangles, lines, points, triangle strip).
 * @param vertexBindingCount The number of vertex buffer bindings.
 * @param pVertexBindingDescriptions A pointer to an array of vertex binding descriptions.
 * @param vertexAttributeCount The number of vertex attributes.
 * @param pVertexAttributeDescriptions A pointer to an array of vertex attribute descriptions.
 * @return A valid VkPipeline handle on success, or VK_NULL_HANDLE on failure.
 */
static VkPipeline _SituationVulkanCreateGraphicsPipeline(
    const void* vs_data, size_t vs_size,
    const void* fs_data, size_t fs_size,
    VkPipelineLayout pipelineLayout,
    VkPrimitiveTopology topology,
    uint32_t vertexBindingCount,
    const VkVertexInputBindingDescription* pVertexBindingDescriptions,
    uint32_t vertexAttributeCount,
    const VkVertexInputAttributeDescription* pVertexAttributeDescriptions)
{
    // 1. Create Shader Modules from the raw SPIR-V data.
    VkShaderModule vs_module = _SituationVulkanCreateShaderModule(vs_data, vs_size);
    VkShaderModule fs_module = _SituationVulkanCreateShaderModule(fs_data, fs_size);

    if (vs_module == VK_NULL_HANDLE || fs_module == VK_NULL_HANDLE) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_PIPELINE_FAILED, "Failed to create shader modules from SPIR-V.");
        if(vs_module) vkDestroyShaderModule(sit_gs.vk.device, vs_module, NULL);
        if(fs_module) vkDestroyShaderModule(sit_gs.vk.device, fs_module, NULL);
        return VK_NULL_HANDLE;
    }

    VkPipelineShaderStageCreateInfo vs_stage_info = { .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, .stage = VK_SHADER_STAGE_VERTEX_BIT, .module = vs_module, .pName = "main" };
    VkPipelineShaderStageCreateInfo fs_stage_info = { .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, .stage = VK_SHADER_STAGE_FRAGMENT_BIT, .module = fs_module, .pName = "main" };
    VkPipelineShaderStageCreateInfo shader_stages[] = {vs_stage_info, fs_stage_info};

    // 2. Define the pipeline's fixed-function states.
    VkPipelineVertexInputStateCreateInfo vertex_input_info = {};
    vertex_input_info.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertex_input_info.vertexBindingDescriptionCount = vertexBindingCount;
    vertex_input_info.pVertexBindingDescriptions = pVertexBindingDescriptions;
    vertex_input_info.vertexAttributeDescriptionCount = vertexAttributeCount;
    vertex_input_info.pVertexAttributeDescriptions = pVertexAttributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo input_assembly = { .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO, .topology = topology, .primitiveRestartEnable = VK_FALSE };
    VkPipelineViewportStateCreateInfo viewport_state = { .sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO, .viewportCount = 1, .scissorCount = 1 };
    VkPipelineRasterizationStateCreateInfo rasterizer = { .sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO, .depthClampEnable = VK_FALSE, .rasterizerDiscardEnable = VK_FALSE, .polygonMode = VK_POLYGON_MODE_FILL, .lineWidth = 1.0f, .cullMode = VK_CULL_MODE_BACK_BIT, .frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE, .depthBiasEnable = VK_FALSE };
    VkPipelineMultisampleStateCreateInfo multisampling = { .sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO, .sampleShadingEnable = VK_FALSE, .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT };
    VkPipelineDepthStencilStateCreateInfo depth_stencil = { .sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO, .depthTestEnable = VK_TRUE, .depthWriteEnable = VK_TRUE, .depthCompareOp = VK_COMPARE_OP_LESS, .depthBoundsTestEnable = VK_FALSE, .stencilTestEnable = VK_FALSE };
    
    VkPipelineColorBlendAttachmentState color_blend_attachment = {};
    color_blend_attachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    color_blend_attachment.blendEnable = VK_TRUE;
    color_blend_attachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    color_blend_attachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    color_blend_attachment.colorBlendOp = VK_BLEND_OP_ADD;
    color_blend_attachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    color_blend_attachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
    color_blend_attachment.alphaBlendOp = VK_BLEND_OP_ADD;
    VkPipelineColorBlendStateCreateInfo color_blending = { .sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO, .logicOpEnable = VK_FALSE, .attachmentCount = 1, .pAttachments = &color_blend_attachment };

    VkDynamicState dynamic_states[] = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR };
    VkPipelineDynamicStateCreateInfo dynamic_state = { .sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, .dynamicStateCount = 2, .pDynamicStates = dynamic_states };

    // 3. Assemble the pipeline create info struct.
    VkGraphicsPipelineCreateInfo pipeline_info = {};
    pipeline_info.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipeline_info.stageCount = 2;
    pipeline_info.pStages = shader_stages;
    pipeline_info.pVertexInputState = &vertex_input_info;
    pipeline_info.pInputAssemblyState = &input_assembly;
    pipeline_info.pViewportState = &viewport_state;
    pipeline_info.pRasterizationState = &rasterizer;
    pipeline_info.pMultisampleState = &multisampling;
    pipeline_info.pDepthStencilState = &depth_stencil;
    pipeline_info.pColorBlendState = &color_blending;
    pipeline_info.pDynamicState = &dynamic_state;
    pipeline_info.layout = pipelineLayout;
    pipeline_info.renderPass = sit_gs.vk.main_window_render_pass;
    pipeline_info.subpass = 0;
    pipeline_info.basePipelineHandle = VK_NULL_HANDLE;

    // 4. Create the final graphics pipeline object.
    VkPipeline pipeline;
    if (vkCreateGraphicsPipelines(sit_gs.vk.device, VK_NULL_HANDLE, 1, &pipeline_info, NULL, &pipeline) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_PIPELINE_FAILED, "vkCreateGraphicsPipelines failed.");
        pipeline = VK_NULL_HANDLE; // Ensure we return NULL on failure
    }

    // 5. Clean up the temporary shader modules, as they are now baked into the pipeline.
    vkDestroyShaderModule(sit_gs.vk.device, vs_module, NULL);
    vkDestroyShaderModule(sit_gs.vk.device, fs_module, NULL);

    return pipeline;
}

#endif // SITUATION_USE_VULKAN

// ============================================================================
// Virtual Display API
// ============================================================================

/**
 * @brief Creates a new virtual display (an off-screen framebuffer).
 *
 * @details Allocates all necessary graphics resources for a new virtual display, which serves as an independent, off-screen rendering target. The created display can be rendered to and then composited onto another target (like the main window) using `SituationRenderVirtualDisplays`.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Creates a Framebuffer Object (FBO), a color texture attachment (`GL_TEXTURE_2D`), and a depth renderbuffer attachment (`GL_RENDERBUFFER`). The texture's filtering mode is set based on the `scaling_mode`.
 * - **Vulkan:** Creates a comprehensive set of resources: a `VkImage` with `VmaAllocation` for color, another for depth, a `VkImageView` for each, a dedicated `VkRenderPass`, a `VkFramebuffer` to connect them, and a `VkSampler` configured for the specified `scaling_mode`.
 *   **Critically, it also pre-allocates and caches a persistent `VkDescriptorSet`** within the returned handle. This makes compositing this display in Vulkan an extremely high-performance operation, as no descriptor sets need to be allocated or updated in the main render loop.
 *
 * @param resolution The internal resolution of the virtual display (e.g., {320.0f, 240.0f}).
 * @param frame_time_mult A multiplier for this display's internal clock, used for slow-motion or fast-forward effects.
 * @param z_order The rendering order during compositing. Lower numbers are drawn first (further back).
 * @param scaling_mode The desired scaling and filtering method for compositing.
 * @param blend_mode The desired blend mode for compositing.
 *
 * @return The integer ID (>= 0) of the newly created virtual display.
 * @return -1 if creation fails (e.g., limit reached, resource allocation failed). Check `SituationGetLastErrorMsg()` for details.
 *
 * @note The caller is **responsible** for destroying the virtual display using `SituationDestroyVirtualDisplay()` to prevent GPU memory leaks.
 */
SITAPI int SituationCreateVirtualDisplay(Vector2 resolution, double frame_time_mult, int z_order, SituationScalingMode scaling_mode, SituationBlendMode blend_mode) {
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot create virtual display");
        return -1;
    }
    if (sit_gs.active_virtual_display_count >= SITUATION_MAX_VIRTUAL_DISPLAYS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VIRTUAL_DISPLAY_LIMIT, "Maximum virtual displays reached");
        return -1;
    }

    int new_id = -1;
    for (int i = 0; i < SITUATION_MAX_VIRTUAL_DISPLAYS; ++i) {
        if (!sit_gs.virtual_display_slots_used[i]) {
            new_id = i;
            break;
        }
    }
    if (new_id == -1) return -1; // Should not happen

    SituationVirtualDisplay* vd = &sit_gs.virtual_display_slots[new_id];
    memset(vd, 0, sizeof(SituationVirtualDisplay)); // Start with a clean slate

    // --- Common Property Initialization ---
    vd->id = new_id;
    vd->resolution[0] = (resolution[0] > 0) ? resolution[0] : 1.0f;
    vd->resolution[1] = (resolution[1] > 0) ? resolution[1] : 1.0f;
    vd->frame_time_multiplier = frame_time_mult;
    vd->z_order = z_order;
    vd->scaling_mode = scaling_mode;
    vd->blend_mode = blend_mode;
    vd->opacity = 1.0f;
    vd->visible = true;
    vd->is_dirty = true;
    vd->last_update_time_seconds = glfwGetTime();

#if defined(SITUATION_USE_VULKAN)
    // =================================================================
    // --- VULKAN IMPLEMENTATION ---
    // =================================================================
    
    VkFormat color_format = VK_FORMAT_R8G8B8A8_UNORM; // A common format for render targets
    VkFormat depth_format = sit_gs.vk.depth_format; // Use same depth format as main window
    
    // --- 1. Create ColorRGBA Image Resources ---
    if (_SituationVulkanCreateImage((uint32_t)vd->resolution[0], (uint32_t)vd->resolution[1], color_format,
                                    VK_IMAGE_TILING_OPTIMAL,
                                    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, // Must be both a render target AND a texture
                                    VMA_MEMORY_USAGE_GPU_ONLY,
                                    &vd->image, &vd->image_memory) != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_FRAMEBUFFER_FAILED, "Failed to create VD color image");
        return -1; // No cleanup needed as nothing was created yet
    }
    vd->image_view = _SituationVulkanCreateImageView(vd->image, color_format, VK_IMAGE_ASPECT_COLOR_BIT);
    if (vd->image_view == VK_NULL_HANDLE) goto cleanup_vulkan;

    // --- 2. Create Depth Image Resources ---
    if (_SituationVulkanCreateImage((uint32_t)vd->resolution[0], (uint32_t)vd->resolution[1], depth_format,
                                    VK_IMAGE_TILING_OPTIMAL,
                                    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
                                    VMA_MEMORY_USAGE_GPU_ONLY,
                                    &vd->depth_image, &vd->depth_image_memory) != SITUATION_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_FRAMEBUFFER_FAILED, "Failed to create VD depth image");
        goto cleanup_vulkan;
    }
    vd->depth_image_view = _SituationVulkanCreateImageView(vd->depth_image, depth_format, VK_IMAGE_ASPECT_DEPTH_BIT);
    if (vd->depth_image_view == VK_NULL_HANDLE) goto cleanup_vulkan;

    // --- 3. Create a Sampler ---
    VkSamplerCreateInfo sampler_info = {};
    sampler_info.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    // Set filtering based on scaling mode
    sampler_info.magFilter = sampler_info.minFilter = (scaling_mode == SITUATION_SCALING_STRETCH) ? VK_FILTER_LINEAR : VK_FILTER_NEAREST;
    sampler_info.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    sampler_info.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    sampler_info.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    sampler_info.anisotropyEnable = VK_FALSE;
    sampler_info.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
    sampler_info.unnormalizedCoordinates = VK_FALSE;
    sampler_info.compareEnable = VK_FALSE;
    sampler_info.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST;
    if (vkCreateSampler(sit_gs.vk.device, &sampler_info, NULL, &vd->sampler) != VK_SUCCESS) goto cleanup_vulkan;

    // --- 4. Create a Render Pass specific to this VD ---
    VkAttachmentDescription attachments[2] = {};
    // ColorRGBA attachment
    attachments[0].format = color_format;
    attachments[0].samples = VK_SAMPLE_COUNT_1_BIT;
    attachments[0].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    attachments[0].storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    attachments[0].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    attachments[0].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    attachments[0].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    attachments[0].finalLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL; // IMPORTANT: Must be ready to be read by a shader
    // Depth attachment
    attachments[1].format = depth_format;
    attachments[1].samples = VK_SAMPLE_COUNT_1_BIT;
    attachments[1].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    attachments[1].storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    attachments[1].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    attachments[1].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    attachments[1].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    attachments[1].finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

    VkAttachmentReference color_ref = {0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL};
    VkAttachmentReference depth_ref = {1, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL};
    VkSubpassDescription subpass = {};
    subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpass.colorAttachmentCount = 1;
    subpass.pColorAttachments = &color_ref;
    subpass.pDepthStencilAttachment = &depth_ref;

    VkRenderPassCreateInfo render_pass_info = {};
    render_pass_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    render_pass_info.attachmentCount = 2;
    render_pass_info.pAttachments = attachments;
    render_pass_info.subpassCount = 1;
    render_pass_info.pSubpasses = &subpass;
    if (vkCreateRenderPass(sit_gs.vk.device, &render_pass_info, NULL, &vd->render_pass) != VK_SUCCESS) goto cleanup_vulkan;

    // --- 5. Create the Framebuffer ---
    VkImageView fb_attachments[] = {vd->image_view, vd->depth_image_view};
    VkFramebufferCreateInfo framebuffer_info = {};
    framebuffer_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    framebuffer_info.renderPass = vd->render_pass;
    framebuffer_info.attachmentCount = 2;
    framebuffer_info.pAttachments = fb_attachments;
    framebuffer_info.width = (uint32_t)vd->resolution[0];
    framebuffer_info.height = (uint32_t)vd->resolution[1];
    framebuffer_info.layers = 1;
    if (vkCreateFramebuffer(sit_gs.vk.device, &framebuffer_info, NULL, &vd->framebuffer) != VK_SUCCESS) goto cleanup_vulkan;

    // --- 6. Create the Persistent Descriptor Set for this VD ---
    VkDescriptorSetAllocateInfo alloc_info_desc = {};
    alloc_info_desc.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    alloc_info_desc.descriptorPool = sit_gs.vk.descriptor_pool; // Use the main pool
    alloc_info_desc.descriptorSetCount = 1;
    alloc_info_desc.pSetLayouts = &sit_gs.vk.image_sampler_layout; // The layout for a single sampler

    // This descriptor set will now live with the VD for its entire lifetime
    if (vkAllocateDescriptorSets(sit_gs.vk.device, &alloc_info_desc, &vd->vk.descriptor_set) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_DESCRIPTOR_FAILED, "Failed to allocate persistent descriptor set for VD.");
        goto cleanup_vulkan; // Use your existing cleanup path
    }

    VkDescriptorImageInfo image_desc_info = {};
    image_desc_info.sampler = vd->vk.sampler;
    image_desc_info.imageView = vd->vk.image_view;
    image_desc_info.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;

    VkWriteDescriptorSet write_set = {};
    write_set.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    write_set.dstSet = vd->vk.descriptor_set;
    write_set.dstBinding = SIT_SAMPLER_BINDING_VD_SOURCE; // Use the contract
    write_set.dstArrayElement = 0;
    write_set.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    write_set.descriptorCount = 1;
    write_set.pImageInfo = &image_desc_info;

    vkUpdateDescriptorSets(sit_gs.vk.device, 1, &write_set, 0, NULL);
    
    goto end_create;

cleanup_vulkan:
    _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_FRAMEBUFFER_FAILED, "Failed during VD creation, cleaning up");
    // This goto allows us to clean up all partially created resources on any failure.
    if (vd->descriptor_set != VK_NULL_HANDLE) { /* Freed with pool */ }
    if (vd->framebuffer != VK_NULL_HANDLE) vkDestroyFramebuffer(sit_gs.vk.device, vd->framebuffer, NULL);
    if (vd->render_pass != VK_NULL_HANDLE) vkDestroyRenderPass(sit_gs.vk.device, vd->render_pass, NULL);
    if (vd->sampler != VK_NULL_HANDLE) vkDestroySampler(sit_gs.vk.device, vd->sampler, NULL);
    if (vd->depth_image_view != VK_NULL_HANDLE) vkDestroyImageView(sit_gs.vk.device, vd->depth_image_view, NULL);
    if (vd->depth_image != VK_NULL_HANDLE) vmaDestroyImage(sit_gs.vk.vma_allocator, vd->depth_image, vd->depth_image_memory);
    if (vd->image_view != VK_NULL_HANDLE) vkDestroyImageView(sit_gs.vk.device, vd->image_view, NULL);
    if (vd->image != VK_NULL_HANDLE) vmaDestroyImage(sit_gs.vk.vma_allocator, vd->image, vd->image_memory);
    return -1;

#elif defined(SITUATION_USE_OPENGL)
    // =================================================================
    // --- OPENGL IMPLEMENTATION ---
    // =================================================================
    // Create all objects without binding, using Direct State Access.
    glCreateFramebuffers(1, &vd->gl.fbo_id);
    glCreateTextures(GL_TEXTURE_2D, 1, &vd->gl.texture_id);
    glCreateRenderbuffers(1, &vd->gl.depth_rbo_id);
    SIT_CHECK_GL_ERROR();

    // Configure Texture with Immutable Storage
    glTextureStorage2D(vd->gl.texture_id, 1, GL_RGBA8, (GLsizei)vd->resolution[0], (GLsizei)vd->resolution[1]);
    GLenum filter_mode = (scaling_mode == SITUATION_SCALING_STRETCH) ? GL_LINEAR : GL_NEAREST;
    glTextureParameteri(vd->gl.texture_id, GL_TEXTURE_MIN_FILTER, filter_mode);
    glTextureParameteri(vd->gl.texture_id, GL_TEXTURE_MAG_FILTER, filter_mode);
    glTextureParameteri(vd->gl.texture_id, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTextureParameteri(vd->gl.texture_id, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    SIT_CHECK_GL_ERROR();

    // Configure Renderbuffer Storage for the depth buffer
    glNamedRenderbufferStorage(vd->gl.depth_rbo_id, GL_DEPTH_COMPONENT24, (GLsizei)vd->resolution[0], (GLsizei)vd->resolution[1]);
    SIT_CHECK_GL_ERROR();

    // Attach the texture and renderbuffer to the FBO
    glNamedFramebufferTexture(vd->gl.fbo_id, GL_COLOR_ATTACHMENT0, vd->gl.texture_id, 0);
    glNamedFramebufferRenderbuffer(vd->gl.fbo_id, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, vd->gl.depth_rbo_id);
    SIT_CHECK_GL_ERROR();

    // --- Check FBO completeness ---
    GLenum status = glCheckNamedFramebufferStatus(vd->gl.fbo_id, GL_FRAMEBUFFER);
    if (status != GL_FRAMEBUFFER_COMPLETE) {
        _SituationSetErrorFromCode(SITUATION_ERROR_OPENGL_FBO_INCOMPLETE, "Failed to create a complete framebuffer for virtual display.");
        
        // Clean up the partially created GL objects to prevent leaks.
        if (vd->gl.texture_id != 0) glDeleteTextures(1, &vd->gl.texture_id);
        if (vd->gl.depth_rbo_id != 0) glDeleteRenderbuffers(1, &vd->gl.depth_rbo_id);
        if (vd->gl.fbo_id != 0) glDeleteFramebuffers(1, &vd->gl.fbo_id);

        // This is a failure, so we return -1 and do not mark the slot as used.
        return -1;
    }
    SIT_CHECK_GL_ERROR(); // Final check
#endif

end_create:
    sit_gs.virtual_display_slots_used[new_id] = true;
    sit_gs.active_virtual_display_count++;
    return new_id;
}

/**
 * @brief Destroys a virtual display and frees its associated graphics resources.
 *
 * @details Cleans up all backend-specific resources associated with the virtual display and marks its ID as available. This is the only correct way to release a virtual display.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Deletes the FBO, color texture, and depth renderbuffer.
 * - **Vulkan:** Waits for the device to be idle to ensure resources are not in use, then destroys the `VkFramebuffer`, `VkRenderPass`, `VkSampler`, `VkImageView`s, and the underlying `VkImage`s and their memory allocations. It also **frees the persistent `VkDescriptorSet`** back to its pool.
 *
 * @param display_id The ID of the virtual display to destroy.
 * @return SITUATION_SUCCESS on successful destruction.
 * @return SITUATION_ERROR_NOT_INITIALIZED if the library isn't initialized.
 * @return SITUATION_ERROR_VIRTUAL_DISPLAY_INVALID_ID if the ID is invalid or not in use.
 */
SITAPI SituationError SituationDestroyVirtualDisplay(int display_id) {
    if (!sit_gs.is_initialized) return SITUATION_ERROR_NOT_INITIALIZED;
    if (display_id < 0 || display_id >= SITUATION_MAX_VIRTUAL_DISPLAYS || !sit_gs.virtual_display_slots_used[display_id]) {
        return SITUATION_ERROR_VIRTUAL_DISPLAY_INVALID_ID;
    }
    SituationVirtualDisplay* vd = &sit_gs.virtual_display_slots[display_id];

#if defined(SITUATION_USE_VULKAN)
    // IMPORTANT: Wait for the GPU to finish all work before destroying resources it might be using.
    vkDeviceWaitIdle(sit_gs.vk.device);
    
    // This assumes the pool was created with VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT
    if (vd->vk.descriptor_set != VK_NULL_HANDLE) {
        vkFreeDescriptorSets(sit_gs.vk.device, sit_gs.vk.descriptor_pool, 1, &vd->vk.descriptor_set);
    }
    
    // Destroy Vulkan resources in the reverse order of their creation.
    // Descriptor sets are freed with their pool, so we don't free it individually here.
    vkDestroyFramebuffer(sit_gs.vk.device, vd->framebuffer, NULL);
    vkDestroyRenderPass(sit_gs.vk.device, vd->render_pass, NULL);
    vkDestroySampler(sit_gs.vk.device, vd->sampler, NULL);
    vkDestroyImageView(sit_gs.vk.device, vd->depth_image_view, NULL);
    vmaDestroyImage(sit_gs.vk.vma_allocator, vd->depth_image, vd->depth_image_memory);
    vkDestroyImageView(sit_gs.vk.device, vd->image_view, NULL);
    vmaDestroyImage(sit_gs.vk.vma_allocator, vd->image, vd->image_memory);

#elif defined(SITUATION_USE_OPENGL)
    if (vd->texture_id != 0) glDeleteTextures(1, &vd->texture_id);
    if (vd->depth_rbo_id != 0) glDeleteRenderbuffers(1, &vd->depth_rbo_id);
    if (vd->fbo_id != 0) glDeleteFramebuffers(1, &vd->fbo_id);
#endif
    
    memset(vd, 0, sizeof(SituationVirtualDisplay));
    sit_gs.virtual_display_slots_used[display_id] = false;
    sit_gs.active_virtual_display_count--;
    return SITUATION_SUCCESS;
}

/**
 * @brief Changes the scaling and filtering mode for a virtual display at runtime.
 *
 * @details Updates how the virtual display's internal texture is sampled when rendered during compositing. This allows switching between blurry (linear) and sharp (nearest-neighbor) scaling on the fly.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Directly updates the `GL_TEXTURE_MIN_FILTER` and `GL_TEXTURE_MAG_FILTER` parameters of the existing texture object.
 * - **Vulkan:** This is a more involved operation. It destroys the old `VkSampler`, creates a new one with the desired filter mode, and then updates the virtual display's persistent descriptor set to point to the new sampler.
 *
 * @param display_id The ID of the virtual display to configure.
 * @param scaling_mode The new scaling mode to apply (`SITUATION_SCALING_STRETCH`, `SITUATION_SCALING_FIT`, `SITUATION_SCALING_INTEGER`).
 * @return SITUATION_SUCCESS on successful update.
 * @return SITUATION_ERROR_NOT_INITIALIZED if the library isn't initialized.
 * @return SITUATION_ERROR_VIRTUAL_DISPLAY_INVALID_ID if the ID is invalid or not in use.
 */
SITAPI SituationError SituationSetVirtualDisplayScalingMode(int display_id, SituationScalingMode scaling_mode) {
    if (!sit_gs.is_initialized) {
        return SITUATION_ERROR_NOT_INITIALIZED;
    }
    if (display_id < 0 || display_id >= SITUATION_MAX_VIRTUAL_DISPLAYS || !sit_gs.virtual_display_slots_used[display_id]) {
        return SITUATION_ERROR_VIRTUAL_DISPLAY_INVALID_ID;
    }

    SituationVirtualDisplay* vd = &sit_gs.virtual_display_slots[display_id];

    // If the mode isn't changing, do nothing.
    if (vd->scaling_mode == scaling_mode) {
        return SITUATION_SUCCESS;
    }

    // Update the enum value in the struct.
    vd->scaling_mode = scaling_mode;

#if defined(SITUATION_USE_OPENGL)
    // =================================================================
    // --- OPENGL IMPLEMENTATION ---
    // =================================================================

    // For OpenGL, we can simply change the texture parameters on the existing texture object.
    GLenum filter_mode = (scaling_mode == SITUATION_SCALING_STRETCH) ? GL_LINEAR : GL_NEAREST;

    // Bind the texture, change its parameters, and unbind it.
    glBindTexture(GL_TEXTURE_2D, vd->texture_id);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, filter_mode);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filter_mode);
    glBindTexture(GL_TEXTURE_2D, 0);

    return SITUATION_SUCCESS;

#elif defined(SITUATION_USE_VULKAN)
    // =================================================================
    // --- VULKAN IMPLEMENTATION ---
    // =================================================================

    // For Vulkan, we must destroy the old sampler and create a new one.

    // 1. Destroy the old sampler. It's good practice to wait for the device to be idle to ensure the sampler is no longer in use, although this can be a performance hit if called frequently.
    vkDeviceWaitIdle(sit_gs.vk.device);
    vkDestroySampler(sit_gs.vk.device, vd->sampler, NULL);

    // 2. Create a new sampler with the correct filter mode.
    VkSamplerCreateInfo sampler_info = {};
    sampler_info.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    sampler_info.magFilter = sampler_info.minFilter = (scaling_mode == SITUATION_SCALING_STRETCH) ? VK_FILTER_LINEAR : VK_FILTER_NEAREST;
    sampler_info.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    sampler_info.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    sampler_info.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    sampler_info.anisotropyEnable = VK_FALSE;
    sampler_info.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
    sampler_info.unnormalizedCoordinates = VK_FALSE;
    sampler_info.compareEnable = VK_FALSE;
    sampler_info.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST;

    if (vkCreateSampler(sit_gs.vk.device, &sampler_info, NULL, &vd->sampler) != VK_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_GENERAL, "Failed to re-create sampler for scaling mode change");
        // The VD is now in a bad state with a destroyed sampler.
        return SITUATION_ERROR_VULKAN_GENERAL;
    }

    // 3. Update the existing descriptor set to point to the new sampler.
    VkDescriptorImageInfo image_desc_info = {};
    image_desc_info.sampler = vd->sampler; // Use the NEW sampler
    image_desc_info.imageView = vd->image_view;
    image_desc_info.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;

    VkWriteDescriptorSet write_set = {};
    write_set.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    write_set.dstSet = vd->descriptor_set; // The existing descriptor set
    write_set.dstBinding = 0;
    write_set.dstArrayElement = 0;
    write_set.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    write_set.descriptorCount = 1;
    write_set.pImageInfo = &image_desc_info;

    vkUpdateDescriptorSets(sit_gs.vk.device, 1, &write_set, 0, NULL);

    return SITUATION_SUCCESS;

#endif
}

static int _SituationSortVirtualDisplaysCallback(const void* a, const void* b) {
    const SituationVirtualDisplay* vdA = *(const SituationVirtualDisplay**)a; // Array of pointers
    const SituationVirtualDisplay* vdB = *(const SituationVirtualDisplay**)b;
    // Invisible displays should effectively be at the "back" or not considered for sorting if filtered earlier
    if (!vdA->visible && vdB->visible) return 1;  // Non-visible after visible
    if (vdA->visible && !vdB->visible) return -1; // Visible before non-visible
    if (!vdA->visible && !vdB->visible) return 0; // Both non-visible, order doesn't matter
    return vdA->z_order - vdB->z_order; // Sort by Z-order
}

/**
 * @brief Composites all visible virtual displays onto the current render target.
 *
 * @details This function iterates through all virtual displays marked as `visible`, sorts them by their `z_order`, and draws them as textured quads. The final position, size, opacity, and blending are controlled by the properties set via `SituationConfigureVirtualDisplay`. This function is typically called once per frame, after all individual VDs have been rendered to, to combine them into a final image.
 *
 * @par Backend-Specific Behavior & Feature Status
 *
 * @b OpenGL (Fully Featured):
 *   - **State Management:** Performs a critical state save-and-restore. It remembers the user's currently bound shader program and Vertex Array Object (VAO), performs its work with its own private resources, and then restores the user's state, guaranteeing a non-destructive operation.
 *   - **Rendering Isolation:** It binds its own private VAO (`sit_gs.gl.vd_quad_vao`), which is pre-configured for drawing textured screen-space quads. This isolates the compositing process from any vertex state the user has configured on their main VAO.
 *   - **Advanced Blending:** Fully supports all `SituationBlendMode` enums. For simple modes (Alpha, Additive, etc.), it uses fixed-function `glBlendFunc`. For advanced Photoshop-style modes (Overlay, Soft Light, etc.), it automatically switches to a specialized shader, copies the current framebuffer content to a temporary texture using `glCopyTexSubImage2D`, and performs the blend in the shader.
 *
 * @b Vulkan (High-Performance, Lacks Advanced Blending):
 *   - **Performance Model:** Implements a high-performance rendering path. It binds the compositing pipeline and the per-frame projection UBO only once before the loop.
 *   - **Persistent Descriptors:** For each virtual display, it leverages the persistent descriptor set model by recording a fast `vkCmdBindDescriptorSets` command using the VD's pre-cached `descriptor_set`. This avoids costly runtime descriptor allocation and is the optimal way to handle texture binding in Vulkan.
 *   - **Push Constants:** Per-display transformation data (model matrix) and opacity are sent efficiently via push constants, minimizing per-draw overhead.
 *   - **Feature Limitation:** The current Vulkan implementation **only supports simple blend modes** (Alpha, Additive, etc.) via its single compositing pipeline. The complex logic required for advanced, multi-pass blend modes (which involves copying the swapchain image and using multiple descriptor sets) is **not yet implemented**. Calling this function with an advanced blend mode on Vulkan will currently fall back to simple alpha blending.
 *
 * @par Usage Notes
 * - This function is typically called once per frame, after all Virtual Display content has been rendered and before the final `SituationEndFrame`.
 * - The rendering order respects the `z_order` property of each virtual display, with lower numbers being drawn first (further back).
 *
 * @param cmd The command buffer to record rendering commands into.
 *            - For **OpenGL:** This parameter is **ignored** as it is an immediate-mode API.
 *            - For **Vulkan:** This must be a valid `VkCommandBuffer` in the recording state.
 *
 * @note This function requires the library to be initialized (`SituationInit` must have been called successfully).
 * @warning This function modifies internal renderer state. The state restoration logic (especially for OpenGL) ensures the user's context is preserved, but it is a critical part of the function's contract.
 *
 * @see SituationCreateVirtualDisplay(), SituationConfigureVirtualDisplay(), SituationCmdBeginRenderPass(), SituationCmdEndRenderPass(), SituationEndFrame()
 */
SITAPI void SituationRenderVirtualDisplays(SituationCommandBuffer cmd) {
    // --- Initial Checks ---
    if (!sit_gs.is_initialized || sit_gs.active_virtual_display_count == 0) {
        sit_gs.last_vd_composite_time_ms = 0.0;
        return;
    }

    // Start timing for profiling.
    double start_time = glfwGetTime();

    // --- Step 1 & 2: Gather, Filter, and Sort (Backend-Agnostic) ---
    SituationVirtualDisplay* visible_vds_to_render[SITUATION_MAX_VIRTUAL_DISPLAYS];
    int visible_count = 0;
    for (int i = 0; i < SITUATION_MAX_VIRTUAL_DISPLAYS; ++i) {
        if (sit_gs.virtual_display_slots_used[i] && sit_gs.virtual_display_slots[i].visible &&
            sit_gs.virtual_display_slots[i].opacity > 0.001f) {

            // In OpenGL, we must also check that the texture handle is valid.
        #if defined(SITUATION_USE_OPENGL)
            if (sit_gs.virtual_display_slots[i].gl.texture_id != 0) {
                 visible_vds_to_render[visible_count++] = &sit_gs.virtual_display_slots[i];
            }
        #elif defined(SITUATION_USE_VULKAN)
            // For Vulkan, we would check its image/view handles.
            if (sit_gs.virtual_display_slots[i].vk.image_view != VK_NULL_HANDLE) {
                 visible_vds_to_render[visible_count++] = &sit_gs.virtual_display_slots[i];
            }
        #endif
        }
    }
    if (visible_count == 0) {
        sit_gs.last_vd_composite_time_ms = 0.0;
        return;
    }

    qsort(visible_vds_to_render, visible_count, sizeof(SituationVirtualDisplay*), _SituationSortVirtualDisplaysCallback);

    // --- Backend-Specific Rendering ---
#if defined(SITUATION_USE_OPENGL)
    (void)cmd; // Mark as unused for OpenGL backend.

    // --- [CRITICAL STATE SAVING] ---
    // 1. Save the currently bound program to restore it later.
    GLint last_program = 0;
    glGetIntegerv(GL_CURRENT_PROGRAM, &last_program);
    // 2. Save the currently bound VAO. While we expect global_vao_id to be bound, saving the actual state is the most robust way to restore it.
    // This handles potential edge cases or future changes.
    GLint last_vao = 0;
    glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &last_vao);
    
    // Get the dimensions of the current render target (the main window).
    float target_width = (float)sit_gs.main_window_width;
    float target_height = (float)sit_gs.main_window_height;

    // --- OpenGL State Setup for Virtual Display Compositing ---
    glDisable(GL_DEPTH_TEST); // VD compositing is typically done in screen space, depth not needed.
    
    // --- [CRITICAL VAO SWAP] ---
    // 3. Bind OUR PRIVATE VAO for compositing.
    // This VAO is pre-configured (by _SituationInitVirtualDisplayRenderer) specifically for drawing simple textured screen-space quads.
    // This isolates the internal rendering state from the user's global_vao_id.
    glBindVertexArray(sit_gs.gl.vd_quad_vao); 
    SIT_CHECK_GL_ERROR(); // Check if VAO binding was successful

    // The projection matrix for screen-space quads is set once, as it's the same for all VDs rendered to the main window.
    // (Assuming sit_gs.vd_ortho_projection is correctly updated elsewhere, e.g., on resize)

    // --- Step 3 & 4: Loop, Transform, and Draw (Partially Backend-Specific) ---
    for (int i = 0; i < visible_count; ++i) {
        const SituationVirtualDisplay* vd = visible_vds_to_render[i];

        // --- Step 3: Calculate Transformations (Backend-Agnostic) ---
        mat4 model_matrix;
        glm_mat4_identity(model_matrix);

        // This logic is identical for both backends. It calculates the final model matrix for the screen-space quad.
        switch (vd->scaling_mode) {
            case SITUATION_SCALING_STRETCH: {
                // Simple stretch to fill the target area defined by the VD's offset and resolution.
                // This is often used for UI that should scale with the window.
                mat4 T_mat, S_mat;
                glm_translate_make(T_mat, (vec3){vd->offset[0], vd->offset[1], 0.0f});
                glm_scale_make(S_mat, (vec3){vd->resolution[0], vd->resolution[1], 1.0f});
                glm_mat4_mul(T_mat, S_mat, model_matrix);
                break;
            }
            case SITUATION_SCALING_FIT: {
                // Aspect-correct scaling to fit the target, leaving letter/pillar-boxing.
                float scale_x = target_width / vd->resolution[0];
                float scale_y = target_height / vd->resolution[1];
                float final_scale = fminf(scale_x, scale_y);
                float final_width = vd->resolution[0] * final_scale;
                float final_height = vd->resolution[1] * final_scale;
                float final_x = (target_width - final_width) / 2.0f;
                float final_y = (target_height - final_height) / 2.0f;
                mat4 T_mat, S_mat;
                glm_translate_make(T_mat, (vec3){final_x, final_y, 0.0f});
                glm_scale_make(S_mat, (vec3){final_width, final_height, 1.0f});
                glm_mat4_mul(T_mat, S_mat, model_matrix);
                break;
            }
            case SITUATION_SCALING_INTEGER: {
                // Pixel-perfect integer scaling.
                float scale_x = target_width / vd->resolution[0];
                float scale_y = target_height / vd->resolution[1];
                float final_scale = fmaxf(1.0f, floorf(fminf(scale_x, scale_y)));
                float final_width = vd->resolution[0] * final_scale;
                float final_height = vd->resolution[1] * final_scale;
                float final_x = (target_width - final_width) / 2.0f;
                float final_y = (target_height - final_height) / 2.0f;
                mat4 T_mat, S_mat;
                glm_translate_make(T_mat, (vec3){final_x, final_y, 0.0f});
                glm_scale_make(S_mat, (vec3){final_width, final_height, 1.0f});
                glm_mat4_mul(T_mat, S_mat, model_matrix);
                break;
            }
        }

        // --- Step 4: Issue Draw Commands (Backend-Specific) ---

        bool use_advanced_shader = (vd->blend_mode >= SITUATION_BLEND_OVERLAY); 
        if (use_advanced_shader) {
            // --- ADVANCED SHADER PATH ---
            
            // 1. Copy current framebuffer content to our temporary texture
            glBindTexture(GL_TEXTURE_2D, sit_gs.composite_copy_texture_id);
            glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, 0, sit_gs.main_window_width, sit_gs.main_window_height);

            // 2. Use the advanced compositing shader
            glUseProgram(sit_gs.composite_shader_program_id);
            glUniformMatrix4fv(SIT_UNIFORM_LOC_PROJECTION_MATRIX, 1, GL_FALSE, (const GLfloat*)sit_gs.vd_ortho_projection);
            glUniformMatrix4fv(SIT_UNIFORM_LOC_MODEL_MATRIX, 1, GL_FALSE, (const GLfloat*)model_matrix);
            
            // 3. Bind textures: Destination (screen copy) to slot 0, Source (VD) to slot 1
            glBindTextureUnit(SIT_SAMPLER_BINDING_SOURCE_1, sit_gs.composite_copy_texture_id); // Destination
            glBindTextureUnit(SIT_SAMPLER_BINDING_SOURCE_0, vd->texture_id);                  // Source
            
            // 4. Set uniforms for the shader
            glUniform1i(SIT_UNIFORM_LOC_BLEND_MODE, vd->blend_mode);
            glUniform1f(SIT_UNIFORM_LOC_OPACITY, vd->opacity);
            
            // 5. Blending is done entirely in the shader, so we can draw opaquely.
            glDisable(GL_BLEND);
            glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

        } else {
            // --- SIMPLE SHADER PATH ---
            glUseProgram(sit_gs.vd_shader_program_id);
            glUniformMatrix4fv(SIT_UNIFORM_LOC_PROJECTION_MATRIX, 1, GL_FALSE, (const GLfloat*)sit_gs.vd_ortho_projection);
            glUniformMatrix4fv(SIT_UNIFORM_LOC_MODEL_MATRIX, 1, GL_FALSE, (const GLfloat*)model_matrix);
            glUniform1f(SIT_UNIFORM_LOC_OPACITY, vd->opacity);
            glEnable(GL_BLEND);
            switch (vd->blend_mode) {
                case SITUATION_BLEND_ALPHA:    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); break;
                case SITUATION_BLEND_ADDITIVE: glBlendFunc(GL_SRC_ALPHA, GL_ONE); break;
                case SITUATION_BLEND_MULTIPLY: glBlendFunc(GL_DST_COLOR, GL_ZERO); break;
                case SITUATION_BLEND_SCREEN:   glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_COLOR); break;
                case SITUATION_BLEND_NONE:     glDisable(GL_BLEND); break;
                default:                       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); break;
            }
            // It binds the texture data to the binding point defined by `layout(binding=...)` in the shader.
            // No `glActiveTexture` or `glUniform1i` is needed.
            glBindTextureUnit(SIT_SAMPLER_BINDING_SOURCE_0, vd->texture_id);

            // Issue the draw call.
            glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
        }
    }
    // --- End of Loop ---

    // --- [CRITICAL STATE RESTORATION] ---
    // Restore OpenGL state exactly as it was before this function was called.
    // The order of restoration can matter slightly, but restoring VAO last is common.

    // 1. Restore the shader program that was active.
    glUseProgram(last_program);
    // 2. Restore the Vertex Array Object that was active.
    // This is the crucial step to ensure the user's vertex setup is reinstated.
    glBindVertexArray(last_vao); // Restore the previously bound VAO (should be sit_gs.gl.global_vao_id)
    
    // Restore other common render states to typical defaults or their previous state.
    // These are often expected by the main application's render loop.
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_DEPTH_TEST); // Re-enable depth test for subsequent user geometry
    // Note: Viewport should already be correct for the main window target.
    // Note: Active texture unit is less critical to restore unless app relies on it post-call.
    
    SIT_CHECK_GL_ERROR(); // Check for any errors during the compositing or state restore process
#elif defined(SITUATION_USE_VULKAN)
    VkCommandBuffer vk_cmd = (VkCommandBuffer)cmd;

    // --- Setup for this frame ---
    // 1. Get the target dimensions. For now, we assume this is the main window.
    // A more advanced implementation might render VDs to other VDs.
    float target_width = (float)sit_gs.vk.swapchain_extent.width;
    float target_height = (float)sit_gs.vk.swapchain_extent.height;

    // 2. Update the UBO for this frame with the correct orthographic projection matrix for the target.
    ViewDataUBO ubo_data;
    glm_mat4_identity(ubo_data.view); // Identity view for 2D orthographic rendering
    glm_ortho(0.0f, target_width, target_height, 0.0f, -1.0f, 1.0f, ubo_data.projection);
    
    void* mapped_data;
    vmaMapMemory(sit_gs.vk.vma_allocator, sit_gs.vk.view_proj_ubo_memory[sit_gs.vk.current_frame_index], &mapped_data);
    memcpy(mapped_data, &ubo_data, sizeof(ViewDataUBO));
    vmaUnmapMemory(sit_gs.vk.vma_allocator, sit_gs.vk.view_proj_ubo_memory[sit_gs.vk.current_frame_index]);

    // --- Begin Rendering ---
    // 3. Bind the pipeline for compositing and the UBO descriptor set for this frame.
    // This is done once for all virtual displays.
    vkCmdBindPipeline(vk_cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, sit_gs.vk.vd_compositing_pipeline);
    vkCmdBindDescriptorSets(vk_cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, sit_gs.vk.vd_compositing_pipeline_layout, 0, 1, &sit_gs.vk.view_proj_ubo_descriptor_set[sit_gs.vk.current_frame_index], 0, NULL);

    // 4. Bind the screen-space quad's vertex buffer once.
    VkBuffer vertex_buffers[] = { sit_gs.vk.quad_vertex_buffer };
    VkDeviceSize offsets[] = { 0 };
    vkCmdBindVertexBuffers(vk_cmd, 0, 1, vertex_buffers, offsets);

    // --- Loop and Draw Each Virtual Display ---
    for (int i = 0; i < visible_count; ++i) {
        const SituationVirtualDisplay* vd = visible_vds_to_render[i];
        
        // --- Calculate the Model Matrix (This is the critical part you pointed out) ---
        mat4 model_matrix;
        glm_mat4_identity(model_matrix);

        switch (vd->scaling_mode) {
            case SITUATION_SCALING_STRETCH: {
                mat4 T_mat, S_mat;
                glm_translate_make(T_mat, (vec3){vd->offset[0], vd->offset[1], 0.0f});
                glm_scale_make(S_mat, (vec3){vd->resolution[0], vd->resolution[1], 1.0f});
                glm_mat4_mul(T_mat, S_mat, model_matrix);
                break;
            }
            case SITUATION_SCALING_FIT: {
                float scale_x = target_width / vd->resolution[0];
                float scale_y = target_height / vd->resolution[1];
                float final_scale = fminf(scale_x, scale_y);
                float final_width = vd->resolution[0] * final_scale;
                float final_height = vd->resolution[1] * final_scale;
                float final_x = (target_width - final_width) / 2.0f;
                float final_y = (target_height - final_height) / 2.0f;
                mat4 T_mat, S_mat;
                glm_translate_make(T_mat, (vec3){final_x, final_y, 0.0f});
                glm_scale_make(S_mat, (vec3){final_width, final_height, 1.0f});
                glm_mat4_mul(T_mat, S_mat, model_matrix);
                break;
            }
            case SITUATION_SCALING_INTEGER: {
                float scale_x = target_width / vd->resolution[0];
                float scale_y = target_height / vd->resolution[1];
                float final_scale = fmaxf(1.0f, floorf(fminf(scale_x, scale_y)));
                float final_width = vd->resolution[0] * final_scale;
                float final_height = vd->resolution[1] * final_scale;
                float final_x = (target_width - final_width) / 2.0f;
                float final_y = (target_height - final_height) / 2.0f;
                mat4 T_mat, S_mat;
                glm_translate_make(T_mat, (vec3){final_x, final_y, 0.0f});
                glm_scale_make(S_mat, (vec3){final_width, final_height, 1.0f});
                glm_mat4_mul(T_mat, S_mat, model_matrix);
                break;
            }
        }
        // --- End Matrix Calculation ---

        // 5. Bind the VD's pre-cached descriptor set for its texture (Set 1).
        // This is extremely fast as it's just recording a command. No allocation, no updates.
        vkCmdBindDescriptorSets(vk_cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, sit_gs.vk.vd_compositing_pipeline_layout, 1, 1, &vd->vk.descriptor_set, 0, NULL);
        
        // 6. Use push constants for per-draw data (model matrix and opacity).
        struct {
            mat4 model;
            float opacity;
        } push_data;

        glm_mat4_copy(model_matrix, push_data.model);
        push_data.opacity = vd->opacity;

        vkCmdPushConstants(vk_cmd, sit_gs.vk.vd_compositing_pipeline_layout, VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0, sizeof(push_data), &push_data);

        // 7. Draw the quad
        vkCmdDraw(vk_cmd, 4, 1, 0, 0);
    }
#endif
    double end_time = glfwGetTime();
    sit_gs.last_vd_composite_time_ms = (end_time - start_time) * 1000.0;
}

/**
 * @brief Configures multiple properties of an existing virtual display.
 *
 * @details Allows changing common properties like position, visibility, opacity, z-order, frame time multiplier, and blend mode in a single call.
 *
 * @param display_id The ID of the virtual display to configure.
 * @param offset The new top-left offset (in pixels) for rendering this VD onto the target.
 * @param opacity The new opacity (0.0f = transparent, 1.0f = opaque).
 * @param z_order The new rendering order (lower drawn first).
 * @param visible Whether this VD should be rendered during compositing.
 * @param frame_time_mult The new frame time multiplier for internal clock.
 * @param blend_mode The new blend mode for compositing.
 * @return SITUATION_SUCCESS on successful configuration.
 *         Returns SITUATION_ERROR_NOT_INITIALIZED if the library isn't initialized.
 *         Returns SITUATION_ERROR_VIRTUAL_DISPLAY_INVALID_ID if the ID is invalid or not in use.
 */
SituationError SituationConfigureVirtualDisplay(int display_id, Vector2 offset, float opacity, int z_order, bool visible, double frame_time_mult, SituationBlendMode blend_mode) {
    if (!sit_gs.is_initialized) return SITUATION_ERROR_NOT_INITIALIZED;
    if (display_id < 0 || display_id >= SITUATION_MAX_VIRTUAL_DISPLAYS || !sit_gs.virtual_display_slots_used[display_id]) {
        return SITUATION_ERROR_VIRTUAL_DISPLAY_INVALID_ID;
    }
    SituationVirtualDisplay* vd = &sit_gs.virtual_display_slots[display_id];
    
    bool visual_property_changed = false;
    if (vd->offset[0] != offset[0] || vd->offset[1] != offset[1]) visual_property_changed = true;
    if (fabsf(vd->opacity - opacity) > 0.001f) visual_property_changed = true; // Compare floats with tolerance
    if (vd->z_order != z_order) visual_property_changed = true;
    if (vd->visible != visible) visual_property_changed = true;
    // Resolution changes would require re-creating the FBO, not just configuring.
    // frame_time_mult doesn't make it visually dirty for compositing.

    glm_vec2_copy(offset, vd->offset);
    vd->opacity = (opacity < 0.0f) ? 0.0f : (opacity > 1.0f) ? 1.0f : opacity;
    vd->z_order = z_order;
    vd->visible = visible;
    if (frame_time_mult > 0.0) vd->frame_time_multiplier = frame_time_mult;
    vd->blend_mode = blend_mode;
    if (visual_property_changed) {
        // While compositing will pick up these changes, if the *content* of the VD
        // should react to these, the app might need to mark it dirty.
        // For now, configuring doesn't automatically mark the *content* dirty.
        // The compositing stage will use the new properties.
    }
    return SITUATION_SUCCESS;
}

/**
 * @brief Retrieves a pointer to the internal state structure of a virtual display.
 *
 * @details Provides direct access to the `SituationVirtualDisplay` struct for advanced querying of properties not covered by specific getter functions. Use with caution.
 *
 * @param display_id The ID of the virtual display.
 * @return A pointer to the `SituationVirtualDisplay` struct.
 *         Returns NULL if the library isn't initialized or the ID is invalid/not in use.
 *         Check `SituationGetLastErrorMsg()` if NULL is returned unexpectedly.
 */
SITAPI SituationVirtualDisplay* SituationGetVirtualDisplay(int display_id) {
    if (!sit_gs.is_initialized || display_id < 0 || display_id >= SITUATION_MAX_VIRTUAL_DISPLAYS || !sit_gs.virtual_display_slots_used[display_id]) {
        _SituationSetErrorFromCode(SITUATION_ERROR_VIRTUAL_DISPLAY_INVALID_ID, "GetVirtualDisplay");
        return NULL;
    }
    return &sit_gs.virtual_display_slots[display_id];
}

/**
 * @brief Marks a virtual display as needing to be re-rendered.
 *
 * @details Sets the internal 'dirty' flag. The `SituationRenderVirtualDisplays` function uses this flag to determine if a VD needs its content re-rendered before compositing.
 *          Rendering to a VD's target (e.g., using `SituationBeginVirtualDisplayFrame`/`SituationEndVirtualDisplayFrame`) should automatically mark it dirty, but this function allows manual control.
 *
 * @param display_id The ID of the virtual display.
 * @param is_dirty True to mark as dirty (needs redraw), False to mark as clean.
 */
SITAPI void SituationSetVirtualDisplayDirty(int display_id, bool is_dirty) {
    if (!sit_gs.is_initialized || display_id < 0 || display_id >= SITUATION_MAX_VIRTUAL_DISPLAYS || !sit_gs.virtual_display_slots_used[display_id]) {
        return;
    }
    sit_gs.virtual_display_slots[display_id].is_dirty = is_dirty;
}

/**
 * @brief Checks if a virtual display is marked as needing to be re-rendered.
 *
 * Queries the internal 'dirty' flag of the virtual display.
 *
 * @param display_id The ID of the virtual display.
 * @return True if the display is marked dirty, False otherwise or if the ID is invalid.
 */
SITAPI bool SituationIsVirtualDisplayDirty(int display_id) {
    if (!sit_gs.is_initialized || display_id < 0 || display_id >= SITUATION_MAX_VIRTUAL_DISPLAYS || !sit_gs.virtual_display_slots_used[display_id]) {
        return false; // Or some error indication
    }
    return sit_gs.virtual_display_slots[display_id].is_dirty;
}

/**
 * @brief Gets the time taken for the last `SituationRenderVirtualDisplays` call.
 *
 * Useful for profiling the performance impact of the virtual display compositing pass.
 *
 * @return The time in milliseconds for the last composite operation.
 *         Returns 0.0 if no compositing has occurred yet or if there were no visible VDs.
 */
SITAPI double SituationGetLastVDCompositeTimeMS(void) {
    if (!sit_gs.is_initialized) return 0.0;
    return sit_gs.last_vd_composite_time_ms;
}

/**
 * @brief Gets the internal resolution of a virtual display.
 *
 * Retrieves the width and height used when the virtual display was created.
 *
 * @param display_id The ID of the virtual display.
 * @param[out] width A pointer to store the width. Ignored if NULL.
 * @param[out] height A pointer to store the height. Ignored if NULL.
 * @return SITUATION_SUCCESS if the ID is valid and values were retrieved.
 *         Returns SITUATION_ERROR_NOT_INITIALIZED if the library isn't initialized.
 *         Returns SITUATION_ERROR_VIRTUAL_DISPLAY_INVALID_ID if the ID is invalid or not in use.
 */
SITAPI void SituationGetVirtualDisplaySize(int display_id, int* width, int* height) {
    if (!sit_gs.is_initialized || !width || !height) { *width = 0; *height = 0; return; }
    if (display_id < 0) { *width = sit_gs.main_window_width; *height = sit_gs.main_window_height; return; }
    SituationVirtualDisplay* vd = SituationGetVirtualDisplay(display_id);
    if (vd) { *width = (int)vd->resolution[0]; *height = (int)vd->resolution[1]; } else { *width = 0; *height = 0; }
}

/**
 * @brief Loads a 3D model from a GLTF (.gltf, .glb) file.
 * @details This is a high-level convenience function that orchestrates the entire loading process.
 *          It parses the model file, automatically loads all associated image files as textures, creates the necessary GPU meshes for each component, and packages everything into a single, easy-to-use `SituationModel` handle.
 * @param file_path The path to the .gltf or .glb file to be loaded.
 * @return A `SituationModel` object containing all loaded resources. On failure, the `id` member of the returned struct will be 0.
 * @note This function requires the `cgltf.h` library to be included with the `CGLTF_IMPLEMENTATION` define in the user's project. If not provided, this
 *       function will fail and set an appropriate error.
 */
SITAPI SituationModel SituationLoadModel(const char* file_path) {
#if defined(CGLTF_IMPLEMENTATION)
    SituationModel model = {0};
    cgltf_options options = {0};
    cgltf_data* data = NULL;
    
    // 1. Parse the GLTF file using cgltf
    cgltf_result result = cgltf_parse_file(&options, file_path, &data);
    if (result != cgltf_result_success) {
        _SituationSetError("Failed to parse GLTF file.");
        return model;
    }
    result = cgltf_load_buffers(&options, data, file_path);
    if (result != cgltf_result_success) {
        _SituationSetError("Failed to load GLTF buffers.");
        cgltf_free(data);
        return model;
    }

    // 2. Load all textures referenced by the model
    //    We need to store them in a temporary array to associate them with materials later.
    model.texture_count = data->textures_count;
    model.all_model_textures = calloc(model.texture_count, sizeof(SituationTexture));
    // Get the base path of the model file to resolve relative texture paths
    char* base_path = SituationGetBasePathFromFile(file_path); // A new filesystem helper
    for (int i = 0; i < data->textures_count; ++i) {
        const char* texture_uri = data->textures[i].image->uri;
        if (texture_uri) {
            char* full_texture_path = SituationJoinPath(base_path, texture_uri);
            // Load texture with mipmaps enabled by default
            model.all_model_textures[i] = SituationCreateTexture(SituationLoadImage(full_texture_path), true);
            free(full_texture_path);
        }
    }
    free(base_path);

    // 3. Process each mesh in the GLTF file
    model.mesh_count = data->meshes_count;
    model.meshes = calloc(model.mesh_count, sizeof(SituationModelMesh));
    for (int i = 0; i < data->meshes_count; ++i) {
        cgltf_mesh* gltf_mesh = &data->meshes[i];
        SituationModelMesh* sit_mesh = &model.meshes[i];
        
        // --- For each primitive in the mesh (GLTF can have multiple primitives per mesh) ---
        // This example simplifies and assumes one primitive per mesh.
        cgltf_primitive* prim = &gltf_mesh->primitives[0];

        // a. Extract vertex data (positions, normals, texcoords) from cgltf accessors.
        //    This is the most complex part. You need to read data from the buffers pointed to by prim->attributes and create a single, interleaved vertex buffer.
        float* vertex_data;
        uint32_t* index_data;
        int vertex_count, index_count;
        // ... (call a helper: _SituationProcessGltfPrimitive(prim, &vertex_data, ...)) ...

        // b. Create the GPU mesh resource
        sit_mesh->gpu_mesh = SituationCreateMesh(vertex_data, vertex_count, sizeof(MyVertexFormat), index_data, index_count);
        free(vertex_data);
        free(index_data);

        // c. Process material data
        cgltf_material* mat = prim->material;
        if (mat && mat->has_pbr_metallic_roughness) {
            cgltf_pbr_metallic_roughness* pbr = &mat->pbr_metallic_roughness;
            // Copy factors
            memcpy(sit_mesh->base_color_factor, pbr->base_color_factor, sizeof(vec4));
            sit_mesh->metallic_factor = pbr->metallic_factor;
            sit_mesh->roughness_factor = pbr->roughness_factor;
            
            // Assign texture handles by finding them in our pre-loaded array
            if (pbr->base_color_texture.texture) {
                int tex_index = pbr->base_color_texture.texture - data->textures;
                sit_mesh->base_color_texture = model.all_model_textures[tex_index];
            }
            // ... do the same for normal, metallic/roughness, etc. ...
        }
    }
    
    // 4. Cleanup and return
    cgltf_free(data);
    model.id = (uint32_t)(uintptr_t)model.meshes; // Use pointer as a simple ID
    return model;
#else
    (void)file_path;
    _SituationSetError("Model loading not available. Please implement cgltf.h.");
    return (SituationModel){0};
#endif
}


/**
 * @brief Unloads a model and frees all of its associated GPU and CPU resources.
 * @details This is the only correct way to clean up a model loaded with `SituationLoadModel`.
 *          It systematically performs the following actions:
 *          1. Iterates through every sub-mesh in the model and calls `SituationDestroyMesh` to free its GPU vertex/index buffers.
 *          2. Iterates through every texture loaded with the model and calls `SituationDestroyTexture` to free its GPU resources.
 *          3. Frees the CPU memory used for the arrays that held the mesh and texture handles.
 *          4. Invalidates the user's `SituationModel` handle by zeroing it out.
 *
 * @param[in,out] model A pointer to the `SituationModel` object to be unloaded. The handle becomes invalid after this call.
 *
 * @note Failure to call this function on a loaded model will result in significant GPU and CPU memory leaks.
 *       It is essential for proper resource management.
 * @note It is safe to call this function on a NULL pointer or an already-unloaded model (where `model->id` is 0);
 *       it will simply do nothing.
 */
SITAPI void SituationUnloadModel(SituationModel* model) {
    // --- 1. Validate Handle ---
    // Safely handle NULL pointers or already-invalidated handles to prevent crashes.
    if (!model || model->id == 0) {
        return;
    }

    // --- 2. Unload all GPU Mesh Resources ---
    // Check if the meshes array was allocated before proceeding.
    if (model->meshes) {
        for (int i = 0; i < model->mesh_count; i++) {
            // Delegate destruction of individual GPU buffers to the dedicated function.
            // This correctly handles backend-specific cleanup and resource tracking removal.
            SituationDestroyMesh(&model->meshes[i].gpu_mesh);
        }
        // Free the CPU memory for the array of mesh structs.
        free(model->meshes);
    }

    // --- 3. Unload all GPU Texture Resources ---
    // Check if the textures array was allocated before proceeding.
    if (model->all_model_textures) {
        for (int i = 0; i < model->texture_count; i++) {
            // Delegate destruction of individual GPU textures to the dedicated function.
            SituationDestroyTexture(&model->all_model_textures[i]);
        }
        // Free the CPU memory for the array of texture handles.
        free(model->all_model_textures);
    }

    // --- 4. Invalidate the User-Facing Handle ---
    // Zero out the entire struct to prevent accidental use of dangling pointers or stale handles.
    // This correctly sets model->id to 0.
    memset(model, 0, sizeof(SituationModel));
}

/**
 * @brief Records commands to draw a complete 3D model with a given transformation.
 * @details This is a high-level drawing command that iterates through all sub-meshes of a model.
 *          For each sub-mesh, it binds the material-specific textures and sets material properties via push constants before issuing a draw call for the mesh's geometry.
 *
 * @par Shader Contract Prerequisites
 *   For this function to work correctly, the caller is **responsible** for binding a compatible PBR-style shader *before* calling it. The shader must expect:
 *   - **Textures** at the binding points defined in the Shader Contract (e.g., `SIT_SAMPLER_BINDING_ALBEDO` at binding 0).
 *   - **Push Constants** with a layout matching the internal `PBRModelPushConstants` struct, containing the model matrix, base color factor, and metallic/roughness factors.
 *   - **Camera Data** from a previously bound UBO (e.g., at `SIT_UBO_BINDING_VIEW_DATA`).
 *
 * @param cmd The command buffer for the current frame.
 * @param model The `SituationModel` handle to draw. Must be a valid, loaded model.
 * @param transform The root model-to-world transformation matrix (position, rotation, scale) to apply to the entire model.
 *
 * @note This function is a high-level convenience wrapper. It can generate many state changes (texture binds) if the model has many unique materials, which may have performance implications.
 */
SITAPI void SituationDrawModel(SituationCommandBuffer cmd, SituationModel model, mat4 transform) {
    if (!sit_gs.is_initialized || model.id == 0) {
        return;
    }
    
    // This struct defines the layout of data sent to the shader via push constants.
    // It must match the `layout(push_constant)` block in the bound shader.
    typedef struct {
        mat4 model_matrix;
        vec4 base_color_factor;
        vec4 pbr_factors; // .x = metallic, .y = roughness
    } PBRModelPushConstants;

    // Iterate through every sub-mesh that makes up the complete model.
    for (int i = 0; i < model.mesh_count; ++i) {
        SituationModelMesh* mesh = &model.meshes[i];

        // --- 1. Bind Material Textures ---
        // For each texture type, check if the handle is valid before binding.
        // This makes the function robust for models that don't use all texture maps.
        if (mesh->base_color_texture.id != 0) { SituationCmdBindTexture(cmd, SIT_SAMPLER_BINDING_ALBEDO, mesh->base_color_texture); }
        if (mesh->normal_texture.id != 0) { SituationCmdBindTexture(cmd, SIT_SAMPLER_BINDING_NORMAL, mesh->normal_texture); }
        if (mesh->metallic_roughness_texture.id != 0) { SituationCmdBindTexture(cmd, SIT_SAMPLER_BINDING_PBR_MAP, mesh->metallic_roughness_texture); }
        if (mesh->occlusion_texture.id != 0) {
            // Note: Your shader contract doesn't have a dedicated occlusion binding.
            // Reusing PBR_MAP binding for example purposes, but a real implementation would add a new binding point.
            // SituationCmdBindTexture(cmd, SIT_SAMPLER_BINDING_OCCLUSION, mesh->occlusion_texture);
        }
        if (mesh->emissive_texture.id != 0) {
            SituationCmdBindTexture(cmd, SIT_SAMPLER_BINDING_EMISSIVE, mesh->emissive_texture);
        }

        // --- 2. Prepare and Set Per-Mesh Uniforms (via Push Constants) ---
        PBRModelPushConstants constants;
        
        // Apply the root transformation for the entire model.
        // NOTE: A more advanced implementation would also apply the mesh's local transform from the GLTF node hierarchy here.
        glm_mat4_copy(transform, constants.model_matrix);
        
        // Copy the material's PBR factor values.
        glm_vec4_copy(mesh->base_color_factor, constants.base_color_factor);
        constants.pbr_factors[0] = mesh->metallic_factor;
        constants.pbr_factors[1] = mesh->roughness_factor;
        constants.pbr_factors[2] = 0.0f; // Unused
        constants.pbr_factors[3] = 0.0f; // Unused

        // Send the data to the GPU. Assumes the bound shader expects this data at offset 0.
        SituationCmdSetPushConstant(cmd, 0, &constants, sizeof(PBRModelPushConstants));

        // --- 3. Issue the Draw Call for this Mesh's Geometry ---
        // This binds the vertex/index buffers and executes the draw.
        SituationCmdDrawMesh(cmd, mesh->gpu_mesh);
    }
}

/**
 * @brief Saves a model's structure and geometry to a human-readable GLTF 2.0 file.
 * @details This is a powerful utility for debugging, asset inspection, or exporting procedurally generated content. It writes the model's scene graph, materials, and texture references to a JSON-based `.gltf` file, and all binary vertex and index data to an accompanying `.bin` file.
 * @param model The `SituationModel` object to save.
 * @param file_path The destination path for the output `.gltf` file. The `.bin` file will be created in the same directory with a corresponding name.
 * @return `true` if the model was saved successfully, `false` otherwise.
 * @note This is an advanced utility with two important requirements:
 *       1. It requires both `cgltf.h` and `cgltf_write.h` to be available in the project.
 *       2. It relies on being able to read geometry data back from the GPU, which can be a slow operation. For best results, use this for debugging or development tools rather than as a frequent runtime operation.
 */
SITAPI bool SituationSaveModelAsGltf(SituationModel model, const char* file_path) {
#if defined(CGLTF_IMPLEMENTATION) && defined(CGLTF_WRITE_H)
    if (model.id == 0) return false;

    // This is a simplified outline. A full implementation is very involved.
    
    // 1. Setup cgltf_data structure
    cgltf_data* data = calloc(1, sizeof(cgltf_data));
    data->meshes_count = model.mesh_count;
    data->meshes = calloc(model.mesh_count, sizeof(cgltf_mesh));
    // ... allocate memory for materials, textures, accessors, buffer_views, buffers ...
    
    // This will hold all vertex/index data for the entire model
    cgltf_buffer* main_buffer = &data->buffers[0];
    
    // 2. Loop through each SituationModelMesh
    for (int i = 0; i < model.mesh_count; ++i) {
        SituationModelMesh* sit_mesh = &model.meshes[i];
        cgltf_mesh* gltf_mesh = &data->meshes[i];
        
        // a. Get CPU-side vertex and index data for this mesh.
        //    *** CRITICAL: This requires a new function to read back GPU data ***
        void* vertex_data;
        void* index_data;
        int vertex_count, index_count, vertex_stride;
        // This function would be slow!
        SituationGetMeshData(sit_mesh->gpu_mesh, &vertex_data, &vertex_count, &vertex_stride, &index_data, &index_count);

        // b. Append this data to a giant CPU buffer that will become the .bin file.
        //    Update buffer_views and accessors to point to the correct offsets and strides
        //    within this giant buffer. This involves a lot of pointer arithmetic and bookkeeping.

        // c. Create a cgltf_material for this mesh's material.
        //    Copy the PBR factors and texture indices into the cgltf struct.
    }

    // 3. Write the file
    cgltf_options options = {0};
    options.type = cgltf_file_type_gltf; // Human-readable .gltf + .bin
    cgltf_result result = cgltf_write_file(&options, file_path, data);

    // 4. Cleanup
    cgltf_free(data);

    return result == cgltf_result_success;
#else
    (void)model; (void)file_path;
    _SituationSetError("Model saving not available. Please implement cgltf.h and cgltf_write.h.");
    return false;
#endif
}


/**
 * @brief [High-Level] Loads, compiles, and creates a graphics shader pipeline from GLSL source files.
 * @details This is the recommended high-level function for loading shaders from disk. It acts as a convenience wrapper, performing a multi-step process:
 *          1. Reads the vertex and fragment shader source code from the specified files using `SituationLoadFileText`.
 *          2. Passes the in-memory source code to `SituationLoadShaderFromMemory` for compilation and GPU resource creation.
 *          3. Cleans up the temporary memory buffers used to hold the source code.
 *
 * @param vs_path The file system path to the vertex shader GLSL source file (e.g., "shaders/pbr.vert").
 * @param fs_path The file system path to the fragment shader GLSL source file (e.g., "shaders/pbr.frag").
 *
 * @return A `SituationShader` handle.
 *         - On success, the `id` member of the returned struct will be non-zero, and the shader is ready for use.
 *         - On failure (e.g., file not found, compilation error), an invalid handle (`id == 0`) is returned.
 *           Use `SituationGetLastErrorMsg()` to get a detailed error description.
 *
 * @note The caller is **responsible** for destroying the returned shader using `SituationUnloadShader()` to prevent GPU memory leaks.
 * @warning This function is not thread-safe and must be called from the main thread that initialized the library.
 *
 * @see SituationLoadShaderFromMemory()
 * @see SituationUnloadShader()
 */
SITAPI SituationShader SituationLoadShader(const char* vs_path, const char* fs_path) {
    SituationShader shader = {0}; // Always initialize to an invalid state.

    // --- 1. Pre-condition Checks ---
    if (!sit_gs.is_initialized) { _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot load shader."); return shader; }
    if (!vs_path || !fs_path) { _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Shader paths cannot be NULL."); return shader; }
    
    // --- 2. Load Vertex Shader Source from File ---
    char* vs_code = SituationLoadFileText(vs_path);
    if (!vs_code) {
        // Error is already set by SituationLoadFileText. The message will be specific (e.g., "File not found"), which is more useful than a generic error here.
        return shader;
    }

    // --- 3. Load Fragment Shader Source from File ---
    char* fs_code = SituationLoadFileText(fs_path);
    if (!fs_code) {
        // CRITICAL: Clean up the successfully loaded vertex shader code to prevent a memory leak.
        free(vs_code);
        // Error is already set by SituationLoadFileText.
        return shader;
    }

    // --- 4. Delegate to the Memory-Based Creation Function ---
    // This function handles the actual compilation and GPU object creation.
    // It will set a detailed error on failure (e.g., compilation error).
    shader = SituationLoadShaderFromMemory(vs_code, fs_code);

    // --- 5. Clean Up Temporary Memory Buffers ---
    // The source code strings are no longer needed after the shader is created.
    free(vs_code);
    free(fs_code);

    // --- 6. Return Result ---
    // The returned handle will be valid (id != 0) if compilation was successful, or invalid (id == 0) if it failed.
    return shader;
}

/**
 * @brief [Core] Creates a graphics shader pipeline from GLSL source code provided as C strings.
 * @details This is the core function for creating graphics pipelines. It takes in-memory GLSL source code for vertex and fragment shaders, orchestrates the backend-specific compilation and linking process, and returns a handle to the final,
 * ready-to-use GPU pipeline object. It also registers the new resource with the internal resource manager for leak detection at shutdown.
 *
 * @par Backend-Specific Compilation
 * - **OpenGL:** The GLSL source strings are passed directly to the OpenGL driver for compilation (`glCompileShader`) and linking (`glLinkProgram`) into a shader program object.
 *     If `SITUATION_ENABLE_SHADER_COMPILER` is defined and the `GL_ARB_gl_spirv` extension is available, the source may first be compiled to SPIR-V for consistency with Vulkan.
 * - **Vulkan:** This backend **requires** `SITUATION_ENABLE_SHADER_COMPILER`. The function uses `shaderc` to compile both the vertex and fragment GLSL sources into separate SPIR-V binary blobs. These blobs are then used to construct a complete `VkPipeline` object, including its `VkPipelineLayout`.
 *
 * @param vs_code The null-terminated string containing the vertex shader source code.
 * @param fs_code The null-terminated string containing the fragment shader source code.
 *
 * @return A `SituationShader` handle.
 *         - On success, the `id` member will be non-zero, and the handle is ready for use with `SituationCmdBindPipeline`.
 *         - On failure (e.g., a syntax error in the shader code, a linking error, or a resource allocation failure), an invalid handle (`id == 0`) is returned. Use `SituationGetLastErrorMsg()` to retrieve the detailed error log from the compiler/linker.
 *
 * @note The caller is **responsible** for destroying the returned shader using `SituationUnloadShader()` to prevent GPU memory leaks.
 * @warning This function is not thread-safe and must be called from the main thread that initialized the library.
 *
 * @see SituationLoadShader(), SituationUnloadShader(), SituationCmdBindPipeline()
 */
SITAPI SituationShader SituationLoadShaderFromMemory(const char* vs_code, const char* fs_code) {
    SituationShader shader = {0};
    if (!sit_gs.is_initialized) { _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot load shader."); return shader; }
    if (!vs_code || !fs_code) { _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Shader source code cannot be NULL"); return shader; }

// --- Backend-Specific Shader Creation Logic ---
#if defined(SITUATION_ENABLE_SHADER_COMPILER)
    // --- PATH A: Unified SPIR-V Pipeline (Vulkan or modern OpenGL) ---
    // Use descriptive but generic names for memory-based compilation errors.
    _SituationSpirvBlob vs_spirv = _SituationVulkanCompileGLSLtoSPIRV(vs_code, "memory.vert", shaderc_vertex_shader);
    _SituationSpirvBlob fs_spirv = _SituationVulkanCompileGLSLtoSPIRV(fs_code, "memory.frag", shaderc_fragment_shader);
    
    if (vs_spirv.data && fs_spirv.data) {
    #if defined(SITUATION_USE_VULKAN)
        VkDescriptorSetLayout layouts[] = { sit_gs.vk.view_data_ubo_layout, sit_gs.vk.image_sampler_layout };
        VkPushConstantRange push_constant_range = { .stageFlags = VK_SHADER_STAGE_ALL_GRAPHICS, .offset = 0, .size = 128 };
        VkPipelineLayoutCreateInfo pipeline_layout_info = { .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, .setLayoutCount = 2, .pSetLayouts = layouts, .pushConstantRangeCount = 1, .pPushConstantRanges = &push_constant_range };
        
        if (vkCreatePipelineLayout(sit_gs.vk.device, &pipeline_layout_info, NULL, &shader.vk_pipeline_layout) == VK_SUCCESS) {
            VkVertexInputBindingDescription binding_desc = { .binding = 0, .stride = (3 + 3 + 2) * sizeof(float), .inputRate = VK_VERTEX_INPUT_RATE_VERTEX };
            VkVertexInputAttributeDescription attr_descs[3] = {
                { .binding = 0, .location = SIT_ATTR_POSITION,   .format = VK_FORMAT_R32G32B32_SFLOAT, .offset = 0 },
                { .binding = 0, .location = SIT_ATTR_NORMAL,     .format = VK_FORMAT_R32G32B32_SFLOAT, .offset = 3 * sizeof(float) },
                { .binding = 0, .location = SIT_ATTR_TEXCOORD_0, .format = VK_FORMAT_R32G32_SFLOAT,    .offset = 6 * sizeof(float) }
            };
            shader.vk_pipeline = _SituationVulkanCreateGraphicsPipeline(vs_spirv.data, vs_spirv.size, fs_spirv.data, fs_spirv.size, shader.vk_pipeline_layout, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, 1, &binding_desc, 3, attr_descs);
            if (shader.vk_pipeline != VK_NULL_HANDLE) {
                shader.id = (uint32_t)(uintptr_t)shader.vk_pipeline;
            } else {
                vkDestroyPipelineLayout(sit_gs.vk.device, shader.vk_pipeline_layout, NULL);
                shader.vk_pipeline_layout = VK_NULL_HANDLE;
            }
        } else {
             _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_PIPELINE_FAILED, "Failed to create pipeline layout for user shader.");
        }
    #elif defined(SITUATION_USE_OPENGL)
        SituationError err;
        shader.gl_program_id = _SituationCreateGLShaderProgramFromSpirv(&vs_spirv, &fs_spirv, &err);
        if(err == SITUATION_SUCCESS) {
            shader.id = shader.gl_program_id;
        }
    #endif
    }
    _SituationFreeSpirvBlob(&vs_spirv);
    _SituationFreeSpirvBlob(&fs_spirv);
#else 
    // --- PATH B: Legacy OpenGL GLSL Source Pipeline ---
    #if defined(SITUATION_USE_OPENGL)
        SituationError err;
        shader.gl_program_id = _SituationCreateGLShaderProgram(vs_code, fs_code, &err);
        if (err == SITUATION_SUCCESS) {
            shader.id = shader.gl_program_id;
            // --- Create the uniform map for this shader ---
            shader.uniform_map = _sit_uniform_map_create(); 
        }
    #elif defined(SITUATION_USE_VULKAN)
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_IMPLEMENTED, "Loading GLSL from memory requires the shader compiler to be enabled for the Vulkan backend.");
    #endif
#endif

    // --- Resource Manager: Add to tracking list ---
    if (shader.id != 0) {
        _SituationShaderNode* node = (_SituationShaderNode*)malloc(sizeof(_SituationShaderNode));
        if (node) {
            node->shader = shader;
            node->next = sit_gs.all_shaders;
            sit_gs.all_shaders = node;
        } else {
            _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Resource tracking node for shader");
            SituationUnloadShader(&shader); // Clean up the GPU resource we just made
            return (SituationShader){0};
        }
    }

    return shader;
}


/**
 * @brief [Core] Creates a compute pipeline directly from GLSL source code provided as a C string.
 * @details This is the core function for creating compute shaders. It compiles the provided GLSL source and creates the corresponding backend-specific GPU pipeline object. It also registers the new resource with the internal resource manager for leak detection at shutdown.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Compiles the GLSL source into an OpenGL Compute Program. If `SITUATION_ENABLE_SHADER_COMPILER` and `GL_ARB_gl_spirv` are available, it may compile to SPIR-V first for consistency with Vulkan.
 * - **Vulkan:** This backend **requires** `SITUATION_ENABLE_SHADER_COMPILER`. The function uses `shaderc` to compile the GLSL source into a SPIR-V binary blob, which is then used to create a `VkPipeline`.
 *
 * @param compute_shader_source A null-terminated C string containing the GLSL source code for the compute shader.
 *
 * @return A `SituationComputePipeline` handle.
 *         - On success, the `id` member will be non-zero, and the handle is ready for use.
 *         - On failure (e.g., compilation error, GPU resource allocation failure), an invalid handle (`id == 0`) is returned.
 *           Use `SituationGetLastErrorMsg()` to get a detailed error description.
 *
 * @note The caller is **responsible** for destroying the returned pipeline using `SituationDestroyComputePipeline()` to prevent GPU and CPU memory leaks.
 * @par Resource Tracking and Potential Leaks:
 * If this function succeeds (returns a handle with `.id != 0`), the underlying GPU resources are valid.
 * However, an internal CPU memory allocation for resource tracking might fail. In this rare case:
 * - A warning will be printed to `stderr` (e.g., "WARNING: Potential leak of Vulkan compute pipeline handle...").
 * - The valid GPU resource handle is still returned.
 * - It is the caller's **absolute responsibility** to call `SituationDestroyComputePipeline()` on the returned handle to prevent a GPU resource leak, as the library's automatic shutdown cleanup will not track this specific resource.
 * @warning This function is not thread-safe and must be called from the main thread that initialized the library.
 */
SITAPI SituationComputePipeline SituationCreateComputePipelineFromMemory(const char* compute_shader_source, SituationComputeLayoutType layout_type) {
    SituationComputePipeline pipeline = {0}; // Always initialize to an invalid state.

    // --- 1. Pre-condition Checks ---
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot create compute pipeline.");
        return pipeline;
    }
    if (!compute_shader_source) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Compute shader source cannot be NULL.");
        return pipeline;
    }

    // --- 2. Backend-Specific Pipeline Creation ---
#if defined(SITUATION_USE_OPENGL)
    // The layout_type parameter is specific to Vulkan's explicit pipeline layout system.
    // In OpenGL, the layout is implicitly defined by the shader source itself.
    // We acknowledge the parameter to match the unified API signature but do not use it.
    (void)layout_type;

    SituationError err = SITUATION_SUCCESS;

    // The OpenGL backend has a preferred modern path and a legacy fallback path.
    // Path 1 (Preferred): Compile GLSL to SPIR-V for consistency with the Vulkan backend.
    // Path 2 (Fallback): Compile GLSL source directly if SPIR-V is unsupported or disabled.

#if defined(SITUATION_ENABLE_SHADER_COMPILER)
    // The shader compiler is enabled, so we can attempt the modern SPIR-V path.
    if (GLAD_GL_ARB_gl_spirv) { // Check if the current OpenGL driver supports SPIR-V.
        
        // Compile the GLSL source to a SPIR-V binary blob.
        _SituationSpirvBlob cs_spirv = _SituationVulkanCompileGLSLtoSPIRV(compute_shader_source, "compute.comp", shaderc_compute_shader);

        if (cs_spirv.data) {
            // SPIR-V compilation was successful. Create the OpenGL program from the binary.
            pipeline.gl_program_id = _SituationCreateGLComputeProgram((const void*)&cs_spirv, SITUATION_GL_SHADER_SOURCE_TYPE_SPIRV, &err);
            _SituationFreeSpirvBlob(&cs_spirv); // Clean up the temporary SPIR-V blob.
        } else {
            // Compilation to SPIR-V failed. This is a hard error.
            // The compiler helper has already set a detailed error message.
            return pipeline; // Return the invalid (zeroed) handle.
        }
    } else {
        // The driver does not support SPIR-V. Fall back to the traditional GLSL source path.
        pipeline.gl_program_id = _SituationCreateGLComputeProgram((const void*)compute_shader_source, SITUATION_GL_SHADER_SOURCE_TYPE_GLSL, &err);
    }
#else
    // The shader compiler is disabled. The only available path is to compile GLSL source directly.
    pipeline.gl_program_id = _SituationCreateGLComputeProgram((const void*)compute_shader_source, SITUATION_GL_SHADER_SOURCE_TYPE_GLSL, &err);
#endif

    // --- Handle Creation Result and Resource Tracking ---
    if (err == SITUATION_SUCCESS && pipeline.gl_program_id != 0) {
        // Success: The OpenGL program object was created successfully.
        
        // Assign a unique public ID for the resource manager (using 64-bit for consistency).
        pipeline.id = (uint64_t)pipeline.gl_program_id;

        // Add the new pipeline to the internal tracking list for leak detection.
        _SituationComputePipelineNode* node = (_SituationComputePipelineNode*)malloc(sizeof(_SituationComputePipelineNode));
        if (node) {
            node->pipeline = pipeline;
            node->next = sit_gs.all_compute_pipelines;
            sit_gs.all_compute_pipelines = node;
        } else {
            // This is a non-fatal but serious issue: the GPU resource was created but we failed to track it. We must warn the user that they are now responsible for cleanup.
            _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Failed to allocate resource tracking node for compute pipeline.");
            fprintf(stderr,
                "SITUATION WARNING: GPU compute pipeline created successfully but failed to add to resource tracker.\n"
                "         This is a potential memory leak. You MUST call SituationDestroyComputePipeline() on the returned handle to free GPU resources.\n");
        }
    }
    // If _SituationCreateGLComputeProgram failed, it returned 0 and set the 'err' code and a detailed message.
    // The 'pipeline' struct remains invalid (zeroed), which is the correct state to return.
    // No 'else' block is needed as the function will simply fall through and return the invalid handle.

#elif defined(SITUATION_USE_VULKAN)
    // The Vulkan backend requires the shader compiler to be enabled to handle GLSL source.
    #if !defined(SITUATION_ENABLE_SHADER_COMPILER)
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_IMPLEMENTED, "Vulkan backend requires SITUATION_ENABLE_SHADER_COMPILER to create pipelines from source code.");
        return pipeline; // Return the invalid (zeroed) pipeline handle
    #else

    // 1. --- Compile GLSL source to SPIR-V bytecode ---
    _SituationSpirvBlob cs_spirv = _SituationVulkanCompileGLSLtoSPIRV(compute_shader_source, "compute.comp", shaderc_compute_shader);

    // If compilation fails, the helper function sets the error and returns an empty blob.
    if (cs_spirv.data == NULL) {
        // No need to set an error here; it's already done by the compiler helper.
        return pipeline; // Return the invalid (zeroed) pipeline handle
    }

    // 2. --- Select the pre-created Pipeline Layout ---
    // Validate the user-provided layout type to prevent out-of-bounds access.
    if (layout_type < 0 || layout_type >= (sizeof(sit_gs.vk.compute_layouts) / sizeof(sit_gs.vk.compute_layouts[0]))) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "An invalid SituationComputeLayoutType was specified.");
        _SituationFreeSpirvBlob(&cs_spirv); // Clean up the compiled SPIR-V
        return pipeline;
    }
    VkPipelineLayout selected_layout = sit_gs.vk.compute_layouts[layout_type];

    // 3. --- Create the Vulkan Pipeline from SPIR-V and the selected layout ---
    pipeline = _SituationVulkanCreateComputePipeline(cs_spirv.data, cs_spirv.size, selected_layout);

    // Always free the temporary SPIR-V blob now that it has been consumed by the pipeline creation.
    _SituationFreeSpirvBlob(&cs_spirv);

    // 4. --- Handle Creation Result and Resource Tracking ---
    if (pipeline.vk_pipeline != VK_NULL_HANDLE) {
        // Success: The pipeline and layout handles are valid.
        
        // Assign a unique public ID for the resource manager.
        pipeline.id = (uint64_t)(uintptr_t)pipeline.vk_pipeline; // Using 64-bit ID

        // Add the new pipeline to the internal tracking list for leak detection.
        _SituationComputePipelineNode* node = (_SituationComputePipelineNode*)malloc(sizeof(_SituationComputePipelineNode));
        if (node) {
            node->pipeline = pipeline;
            node->next = sit_gs.all_compute_pipelines;
            sit_gs.all_compute_pipelines = node;
        } else {
            // This is a non-fatal but serious issue: the GPU resource was created but we failed to track it. Warn the user they are now responsible for cleanup.
            _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Failed to allocate resource tracking node for compute pipeline.");
            fprintf(stderr,
                "SITUATION WARNING: GPU compute pipeline created successfully but failed to add to resource tracker.\n"
                "         This is a potential memory leak. You MUST call SituationDestroyComputePipeline() on the returned handle to free GPU resources.\n");
        }
    }
    // If _SituationVulkanCreateComputePipeline failed, it returned a zeroed 'pipeline' struct and set the error.
    // There is nothing more to do here; we simply return the invalid handle.

    return pipeline;

    #endif // SITUATION_ENABLE_SHADER_COMPILER
#endif // SITUATION_USE_OPENGL / SITUATION_USE_VULKAN

    // --- 3. Return Result ---
    return pipeline;
}

/**
 * @brief Destroys a graphics shader pipeline and frees all of its associated GPU and CPU resources.
 * @details This is the only correct way to release a shader created with `SituationLoadShader` or `SituationLoadShaderFromMemory`. It handles the full cleanup process:
 *          1. Removes the shader from the internal resource tracking list to prevent false leak warnings at shutdown.
 *          2. Destroys all backend-specific GPU objects (OpenGL program, Vulkan pipeline and layout).
 *          3. Frees any associated CPU-side resources (like the OpenGL uniform location cache).
 *          4. Invalidates the user's handle by zeroing it out to prevent accidental use of stale data.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Destroys the internal uniform location cache (`_sit_uniform_map_destroy`), then deletes the shader program object (`glDeleteProgram`).
 * - **Vulkan:** Waits for the GPU to become idle to ensure the pipeline is not in use, then destroys both the `VkPipeline` and its associated `VkPipelineLayout`.
 *
 * @param[in,out] shader A pointer to the `SituationShader` handle to be destroyed. The contents of the struct will be zeroed out, invalidating the handle for future use.
 *
 * @note It is safe to call this function on a NULL pointer or an already-unloaded shader handle (where `shader->id` is 0); it will simply do nothing.
 * @warning This function can cause a GPU stall on the Vulkan backend due to `vkDeviceWaitIdle`.
 *          Avoid unloading shaders frequently in performance-critical loops.
 */
SITAPI void SituationUnloadShader(SituationShader* shader) {
    // --- 1. Input Validation ---
    // Safely handle NULL pointers or already-invalidated handles to prevent crashes.
    if (!shader || shader->id == 0) {
        return;
    }

    // --- 2. Resource Manager: Remove from internal tracking list ---
    _SituationShaderNode* current = sit_gs.all_shaders;
    _SituationShaderNode* prev = NULL;
    while (current != NULL) {
        // Compare by the unique ID.
        if (current->shader.id == shader->id) {
            if (prev) {
                prev->next = current->next; // Unlink from middle/end of the list
            } else {
                sit_gs.all_shaders = current->next; // Unlink from the head of the list
            }
            free(current); // Free the tracking node itself
            break; // Found and removed, can exit the loop
        }
        prev = current;
        current = current->next;
    }

    // --- 3. Backend-Specific Destruction ---
#if defined(SITUATION_USE_OPENGL)
    // For OpenGL, we must free the CPU-side uniform map and the GPU program object.
    if (shader->uniform_map) {
        _sit_uniform_map_destroy(shader->uniform_map);
    }
    if (glIsProgram(shader->id)) {
        glDeleteProgram(shader->id);
    }
    SIT_CHECK_GL_ERROR();

#elif defined(SITUATION_USE_VULKAN)
    // For Vulkan, we must ensure the GPU is finished before destroying the pipeline and its layout.
    if (sit_gs.vk.device) {
        vkDeviceWaitIdle(sit_gs.vk.device);
    }

    if (shader->vk_pipeline != VK_NULL_HANDLE) {
        vkDestroyPipeline(sit_gs.vk.device, shader->vk_pipeline, NULL);
    }
    if (shader->vk_pipeline_layout != VK_NULL_HANDLE) {
        vkDestroyPipelineLayout(sit_gs.vk.device, shader->vk_pipeline_layout, NULL);
    }
#endif

    // --- 4. Invalidate the User-Facing Handle ---
    // Zero out the entire struct passed by the user to prevent accidental use of dangling pointers or stale handles.
    // This correctly sets shader->id to 0.
    memset(shader, 0, sizeof(SituationShader));
}

/**
 * @brief Sets the value of a standalone uniform variable within a graphics shader program.
 * @details This function provides a convenient way to pass data to shaders, primarily for the OpenGL backend where standalone uniforms are common. It automatically caches uniform locations for high performance on subsequent calls.
 *
 * @par Backend-Specific Behavior & Usage
 * - **OpenGL:** This is the primary, high-performance method for setting per-draw-call data that is not part of a larger UBO.
 *      On the first call for a given `uniform_name`, it queries the uniform's location using `glGetUniformLocation` and caches it in an internal hash map. Subsequent calls for the same uniform are extremely fast as they use the cached location, avoiding repeated string lookups.
 *      It uses the appropriate `glUniform*` function based on the provided `type`.
 *
 * - **Vulkan:** This function is **not recommended** for the Vulkan backend and will return `SITUATION_ERROR_NOT_IMPLEMENTED`.
 *      Vulkan's architecture is optimized for passing data via Uniform Buffer Objects (UBOs) for per-frame data and **Push Constants** for small, high-frequency per-draw data. For Vulkan, you should use `SituationCmdBindUniformBuffer` and `SituationCmdSetPushConstant` instead.
 *
 * @param shader The `SituationShader` handle whose uniform you want to set.
 * @param uniform_name The null-terminated string name of the uniform variable in the GLSL code (e.g., "u_modelMatrix").
 * @param data A pointer to the data to be sent to the uniform (e.g., a `mat4`, `vec4`, `float`).
 * @param type An enum `SituationUniformType` that specifies the data type of the uniform. This determines which underlying API function is called.
 *
 * @return `SITUATION_SUCCESS` on success.
 * @return `SITUATION_ERROR_NOT_INITIALIZED` if the library is not initialized.
 * @return `SITUATION_ERROR_INVALID_PARAM` if any of the input parameters are invalid.
 * @return `SITUATION_ERROR_NOT_IMPLEMENTED` if called on the Vulkan backend.
 * @return `SITUATION_ERROR_OPENGL_GENERAL` if an OpenGL error occurs.
 *
 * @note In OpenGL, if the specified `uniform_name` does not exist in the shader or is optimized out by the compiler, this function will silently do nothing and return `SITUATION_SUCCESS`. This is standard behavior for `glGetUniformLocation`.
 *
 * @see SituationCmdSetPushConstant(), SituationCmdBindUniformBuffer()
 */
SITAPI SituationError SituationSetShaderUniform(SituationShader shader, const char* uniform_name, const void* data, SituationUniformType type) {
    if (!sit_gs.is_initialized) return SITUATION_ERROR_NOT_INITIALIZED;
    if (shader.id == 0 || !uniform_name || !data) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Invalid shader, name, or data for SetShaderUniform.");
        return SITUATION_ERROR_INVALID_PARAM;
    }

#if defined(SITUATION_USE_OPENGL)
    if (!shader.uniform_map) {
        _SituationSetErrorFromCode(SITUATION_ERROR_GENERAL, "Shader uniform map not initialized.");
        return SITUATION_ERROR_GENERAL;
    }
    
    // 1. Check the cache (hash map) first
    GLint location = _sit_uniform_map_get(shader.uniform_map, uniform_name);

    // 2. If not in cache, query OpenGL and add it to the cache
    if (location == -1) {
        // Ensure the correct shader is active before querying its uniforms
        glUseProgram(shader.id);
        location = glGetUniformLocation(shader.id, uniform_name);
        
        if (location != -1) {
            _sit_uniform_map_set(shader.uniform_map, uniform_name, location);
        } else {
            // This is not a fatal library error. The shader simply doesn't have this uniform.
            // Silently ignoring it is often the desired behavior.
            return SITUATION_SUCCESS;
        }
    }
    
    // 3. Set the uniform value based on its type
    // glUseProgram is already called if we had to query, but it's safe to call again.
    glUseProgram(shader.id);
    switch(type) {
        case SIT_UNIFORM_FLOAT: glUniform1fv(location, 1, (const GLfloat*)data); break;
        case SIT_UNIFORM_VEC2:  glUniform2fv(location, 1, (const GLfloat*)data); break;
        case SIT_UNIFORM_VEC3:  glUniform3fv(location, 1, (const GLfloat*)data); break;
        case SIT_UNIFORM_VEC4:  glUniform4fv(location, 1, (const GLfloat*)data); break;
        case SIT_UNIFORM_INT:   glUniform1iv(location, 1, (const GLint*)data); break;
        case SIT_UNIFORM_IVEC2: glUniform2iv(location, 1, (const GLint*)data); break;
        case SIT_UNIFORM_IVEC3: glUniform3iv(location, 1, (const GLint*)data); break;
        case SIT_UNIFORM_IVEC4: glUniform4iv(location, 1, (const GLint*)data); break;
        case SIT_UNIFORM_MAT4:  glUniformMatrix4fv(location, 1, GL_FALSE, (const GLfloat*)data); break;
        default: return SITUATION_ERROR_INVALID_PARAM;
    }
    SIT_CHECK_GL_ERROR();

#elif defined(SITUATION_USE_VULKAN)
    // Named uniforms are not the primary way of passing data in Vulkan. Push constants and UBOs are preferred.
    // This function is considered an OpenGL-specific convenience.
    _SituationSetErrorFromCode(SITUATION_ERROR_NOT_IMPLEMENTED, "Use SituationCmdSetPushConstant or UBOs for Vulkan.");
    return SITUATION_ERROR_NOT_IMPLEMENTED;
#endif

    return SITUATION_SUCCESS;
}

/**
 * @brief [DEPRECATED] Inserts a coarse-grained memory barrier.
 * @details This function provides a simple, but less optimal, way to synchronize memory.
 *          It is recommended to use the more explicit and performant `SituationCmdPipelineBarrier()` instead.
 *
 * @param cmd The command buffer to record the barrier into. (Ignored in OpenGL).
 * @param barrier_bits A bitmask of `SITUATION_BARRIER_*_BIT` flags specifying the types of memory access to synchronize.
 *
 * @deprecated Use SituationCmdPipelineBarrier() for more precise and optimal synchronization.
 */
SITAPI void SituationMemoryBarrier(SituationCommandBuffer cmd, uint32_t barrier_bits) {
    if (!sit_gs.is_initialized || barrier_bits == 0) {
        return;
    }

#if defined(SITUATION_USE_OPENGL)
    (void)cmd;
    // The previous mapping logic for OpenGL is still valid for this coarse barrier.
    GLbitfield gl_barrier_bits = 0;
    if (barrier_bits & SITUATION_BARRIER_VERTEX_ATTRIB_ARRAY_BIT)  gl_barrier_bits |= GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT;
    if (barrier_bits & SITUATION_BARRIER_INDEX_BUFFER_BIT)         gl_barrier_bits |= GL_ELEMENT_ARRAY_BARRIER_BIT;
    if (barrier_bits & SITUATION_BARRIER_UNIFORM_BUFFER_BIT)       gl_barrier_bits |= GL_UNIFORM_BARRIER_BIT;
    if (barrier_bits & SITUATION_BARRIER_TEXTURE_FETCH_BIT)        gl_barrier_bits |= GL_TEXTURE_FETCH_BARRIER_BIT;
    if (barrier_bits & SITUATION_BARRIER_SHADER_IMAGE_ACCESS_BIT)  gl_barrier_bits |= GL_SHADER_IMAGE_ACCESS_BARRIER_BIT;
    if (barrier_bits & SITUATION_BARRIER_COMMAND_BIT)              gl_barrier_bits |= GL_COMMAND_BARRIER_BIT;
    if (barrier_bits & SITUATION_BARRIER_SHADER_STORAGE_BIT)       gl_barrier_bits |= GL_SHADER_STORAGE_BARRIER_BIT;
    if (barrier_bits & SITUATION_BARRIER_ALL_BARRIER_BITS)         gl_barrier_bits = GL_ALL_BARRIER_BITS;

    if (gl_barrier_bits != 0) {
        glMemoryBarrier(gl_barrier_bits);
    }
#elif defined(SITUATION_USE_VULKAN)
    // For this deprecated function, we issue a very broad, "sledgehammer" barrier.
    // It's not optimal but guarantees correctness for simple use cases.
    VkMemoryBarrier memory_barrier = {0};
    memory_barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
    memory_barrier.srcAccessMask = VK_ACCESS_MEMORY_WRITE_BIT;
    memory_barrier.dstAccessMask = VK_ACCESS_MEMORY_READ_BIT;

    vkCmdPipelineBarrier(
        (VkCommandBuffer)cmd,
        VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, // Wait for ALL previous stages
        VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, // Unblock ALL subsequent stages
        0,
        1, &memory_barrier,
        0, NULL,
        0, NULL
    );
#endif
}

//==================================================================================
// Window and Display Module
//==================================================================================

/**
 * @brief Checks if the window is currently in exclusive fullscreen mode.
 * @return `true` if the window is in fullscreen mode, `false` otherwise.
 * @see SituationToggleFullscreen()
 */
SITAPI bool SituationIsWindowFullscreen(void) {
    if (!SituationIsInitialized()) return false;
    return (glfwGetWindowMonitor(sit_gs.sit_glfw_window) != NULL);
}

/**
 * @brief Checks if the window is currently hidden (not visible).
 * @return `true` if the window is hidden, `false` otherwise.
 */
SITAPI bool SituationIsWindowHidden(void) {
    if (!SituationIsInitialized()) return false;
    return (glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_VISIBLE) == GLFW_FALSE);
}

/**
 * @brief Checks if the window is currently minimized (iconified).
 * @return `true` if the window is minimized, `false` otherwise.
 * @see SituationMinimizeWindow()
 */
SITAPI bool SituationIsWindowMinimized(void) {
    if (!SituationIsInitialized()) return false;
    return (glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_ICONIFIED) == GLFW_TRUE);
}

/**
 * @brief Checks if the window is currently maximized.
 * @return `true` if the window is maximized, `false` otherwise.
 * @see SituationMaximizeWindow()
 */
SITAPI bool SituationIsWindowMaximized(void) {
    if (!SituationIsInitialized()) return false;
    return (glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_MAXIMIZED) == GLFW_TRUE);
}

/**
 * @brief Checks if the window was resized during the last frame's event polling.
 * @details This is a single-frame "event" flag, ideal for triggering resolution-dependent updates in your main loop. It is reset to `false` at the beginning of each frame by `SituationPollInputEvents()`.
 * @return `true` if a resize event occurred, `false` otherwise.
 */
SITAPI bool SituationIsWindowResized(void) {
    if (!SituationIsInitialized()) return false;
    return sit_gs.was_window_resized_last_frame;
}

/**
 * @brief Checks if a specific window state is currently active.
 * @details This function queries the underlying windowing system for the *actual*, current state of the window, which may differ from the target state set in the profiles.
 * @param flag The `SITUATION_FLAG_*` define to check.
 * @return `true` if the flag corresponds to an active window state, `false` otherwise.
 * @see SituationGetCurrentActualWindowStateFlags()
 */
SITAPI bool SituationIsWindowState(uint32_t flag) {
    if (!SituationIsInitialized()) return false;
    return (SituationGetCurrentActualWindowStateFlags() & flag) != 0;
}

/**
 * @brief Sets one or more window state flags for the current focus profile.
 * @details This function modifies the window's target state by adding the specified flags to the active profile (either the "focused" or "unfocused" profile). It then immediately applies this new profile, causing the window's state to change.
 *
 * @param flags A bitmask of `SITUATION_FLAG_*` defines (e.g., `SITUATION_FLAG_WINDOW_TOPMOST | SITUATION_FLAG_WINDOW_UNDECORATED`).
 * @see SituationClearWindowState(), SituationApplyCurrentProfileWindowState()
 */
SITAPI void SituationSetWindowState(uint32_t flags) {
    if (!SituationIsInitialized()) return;
    uint32_t* profile = sit_gs.current_window_focus_state ? &sit_gs.active_profile_window_flags : &sit_gs.inactive_profile_window_flags;
    *profile |= flags;
    SituationApplyCurrentProfileWindowState();
}

/**
 * @brief Clears one or more window state flags from the current focus profile.
 * @details This function modifies the window's target state by removing the specified flags from the active profile (either the "focused" or "unfocused" profile). It then immediately applies this new profile.
 *
 * @param flags A bitmask of `SITUATION_FLAG_*` defines to remove.
 * @see SituationSetWindowState(), SituationApplyCurrentProfileWindowState()
 */
SITAPI void SituationClearWindowState(uint32_t flags) {
    if (!SituationIsInitialized()) return;
    uint32_t* profile = sit_gs.current_window_focus_state ? &sit_gs.active_profile_window_flags : &sit_gs.inactive_profile_window_flags;
    *profile &= ~flags;
    SituationApplyCurrentProfileWindowState();
}

/**
 * @brief Toggles the window between exclusive fullscreen and windowed mode.
 * @details This is a high-level convenience function that toggles the `SITUATION_FLAG_FULLSCREEN_MODE` in the current window profile and applies the change.
 *          When entering fullscreen, it uses the current monitor's native resolution. When returning to windowed mode, it restores the window's previous size and position.
 * @see SituationToggleBorderlessWindowed(), SituationIsWindowFullscreen()
 */
SITAPI void SituationToggleFullscreen(void) {
    // This existing function in your library already does exactly what's needed.
    SituationToggleWindowStateFlags(SITUATION_FLAG_FULLSCREEN_MODE);
}

/**
 * @brief Toggles the window between a standard decorated style and a borderless, fullscreen-windowed style.
 * @details This is ideal for creating an immersive, "fake fullscreen" experience. When entering borderless mode, it saves the current window position, removes decorations, and resizes the window to fill the current monitor. When exiting, it restores decorations and the original size/position.
 * @see SituationToggleFullscreen()
 */
SITAPI void SituationToggleBorderlessWindowed(void) {
    if (!SituationIsInitialized()) return;

    if (!sit_gs.is_borderless_active) {
        // --- ENTERING BORDERLESS ---
        // Save current windowed size and position
        glfwGetWindowPos(sit_gs.sit_glfw_window, &sit_gs.windowed_x, &sit_gs.windowed_y);
        glfwGetWindowSize(sit_gs.sit_glfw_window, &sit_gs.windowed_w, &sit_gs.windowed_h);

        // Get monitor info
        GLFWmonitor* monitor = glfwGetPrimaryMonitor(); // Or find current monitor
        const GLFWvidmode* mode = glfwGetVideoMode(monitor);
        if (!mode) return; // Cannot proceed

        // Set window to be undecorated and match monitor size/pos
        glfwSetWindowAttrib(sit_gs.sit_glfw_window, GLFW_DECORATED, GLFW_FALSE);
        glfwSetWindowMonitor(sit_gs.sit_glfw_window, NULL, 0, 0, mode->width, mode->height, 0);
        sit_gs.is_borderless_active = true;
    } else {
        // --- LEAVING BORDERLESS ---
        // Restore decoration and previous size/pos
        glfwSetWindowAttrib(sit_gs.sit_glfw_window, GLFW_DECORATED, GLFW_TRUE);
        glfwSetWindowMonitor(sit_gs.sit_glfw_window, NULL, sit_gs.windowed_x, sit_gs.windowed_y, sit_gs.windowed_w, sit_gs.windowed_h, 0);
        sit_gs.is_borderless_active = false;
    }
}

/**
 * @brief Maximizes the application window to fill the available work area of the monitor.
 * @details This function will have no effect if the window is not resizable.
 * @see SituationMinimizeWindow(), SituationRestoreWindow(), SituationIsWindowMaximized()
 */
SITAPI void SituationMaximizeWindow(void) {
    if (!SituationIsInitialized()) return;
    glfwMaximizeWindow(sit_gs.sit_glfw_window);
}

/**
 * @brief Minimizes (iconifies) the application window, hiding it from the screen.
 * @details When minimized, the application will typically be paused automatically to conserve resources.
 * @see SituationMaximizeWindow(), SituationRestoreWindow(), SituationIsWindowMinimized()
 */
SITAPI void SituationMinimizeWindow(void) {
    if (!SituationIsInitialized()) return;
    glfwIconifyWindow(sit_gs.sit_glfw_window);
}

/**
 * @brief Restores a minimized or maximized window to its normal, windowed state.
 * @details If the window is minimized, it will be un-hidden. If it is maximized, it will return to its previous non-maximized size and position.
 * @see SituationMaximizeWindow(), SituationMinimizeWindow()
 */
SITAPI void SituationRestoreWindow(void) {
    if (!SituationIsInitialized()) return;
    glfwRestoreWindow(sit_gs.sit_glfw_window);
}

/**
 * @brief Sets multiple images of different sizes as the application's icon.
 * @details The operating system will automatically select the most appropriate image size for display in various contexts (e.g., title bar, taskbar, Alt-Tab switcher).
 *          Common sizes to provide are 16x16, 32x32, and 48x48.
 * @param images A pointer to an array of `SituationImage` structs.
 * @param count The number of images in the array.
 * @see SituationSetWindowIcon()
 */
SITAPI void SituationSetWindowIcons(SituationImage *images, int count) {
    if (!SituationIsInitialized() || !images || count <= 0) return;

    GLFWimage* glfw_images = (GLFWimage*)malloc(count * sizeof(GLFWimage));
    if (!glfw_images) return;

    for (int i = 0; i < count; i++) {
        glfw_images[i].width = images[i].width;
        glfw_images[i].height = images[i].height;
        glfw_images[i].pixels = (unsigned char*)images[i].data;
    }

    glfwSetWindowIcon(sit_gs.sit_glfw_window, count, glfw_images);
    free(glfw_images);
}

/**
 * @brief Sets a single image as the application's icon in the title bar and taskbar.
 * @details For best results across different operating systems and display scales, it is recommended to use `SituationSetWindowIcons` with multiple sizes.
 * @param image A `SituationImage` containing the icon's pixel data.
 * @see SituationSetWindowIcons()
 */
SITAPI void SituationSetWindowIcon(SituationImage image) {
    SituationSetWindowIcons(&image, 1);
}

/**
 * @brief Sets the text that appears in the window's title bar.
 * @param title A null-terminated, UTF-8 encoded string for the new window title.
 */
SITAPI void SituationSetWindowTitle(const char *title) {
    if (!SituationIsInitialized()) return;
    glfwSetWindowTitle(sit_gs.sit_glfw_window, title);
}

/**
 * @brief Sets the position of the top-left corner of the window on the desktop.
 * @param x The new x-coordinate on the virtual screen.
 * @param y The new y-coordinate on the virtual screen.
 * @see SituationGetWindowPosition()
 */
SITAPI void SituationSetWindowPosition(int x, int y) {
    if (!SituationIsInitialized()) return;
    glfwSetWindowPos(sit_gs.sit_glfw_window, x, y);
}

/**
 * @brief Sets the dimensions of the window's client area (the drawable region).
 * @param width The new width of the client area in screen coordinates.
 * @param height The new height of the client area in screen coordinates.
 * @see SituationGetWindowSize()
 */
SITAPI void SituationSetWindowSize(int width, int height) {
    if (!SituationIsInitialized()) return;
    glfwSetWindowSize(sit_gs.sit_glfw_window, width, height);
}

SITAPI void SituationSetWindowMonitor(int monitor_id) {
    if (!SituationIsInitialized()) return;

    int display_count = 0;
    SituationDisplayInfo* displays = SituationGetDisplays(&display_count); // Uses your existing function
    if (!displays) return;

    if (monitor_id >= 0 && monitor_id < display_count) {
        SituationDisplayInfo* target_display = &displays[monitor_id];
        if (target_display->glfw_monitor_handle) {
            // Go fullscreen on the target monitor using its current mode
            glfwSetWindowMonitor(sit_gs.sit_glfw_window,
                                 target_display->glfw_monitor_handle,
                                 0, 0, // Position is relative to monitor in fullscreen
                                 target_display->current_mode.width,
                                 target_display->current_mode.height,
                                 target_display->current_mode.refresh_rate);
        }
    }

    // CRITICAL: Free the memory allocated by SituationGetDisplays
    for (int i = 0; i < display_count; ++i) {
        free(displays[i].available_modes);
    }
    free(displays);
}

/**
 * @brief Sets the minimum allowed size for the window's client area.
 * @details The user will not be able to resize the window smaller than these dimensions.
 * @param width The minimum width in screen coordinates.
 * @param height The minimum height in screen coordinates.
 * @see SituationSetWindowMaxSize()
 */

SITAPI void SituationSetWindowMinSize(int width, int height) {
    if (!SituationIsInitialized()) return;
    // Get max size to avoid overwriting it
    int maxW, maxH;
    glfwGetWindowSizeLimits(sit_gs.sit_glfw_window, NULL, NULL, &maxW, &maxH);
    glfwSetWindowSizeLimits(sit_gs.sit_glfw_window, width, height, maxW, maxH);
}

/**
 * @brief Sets the maximum allowed size for the window's client area.
 * @details The user will not be able to resize the window larger than these dimensions.
 * @param width The maximum width in screen coordinates.
 * @param height The maximum height in screen coordinates.
 * @see SituationSetWindowMinSize()
 */
SITAPI void SituationSetWindowMaxSize(int width, int height) {
    if (!SituationIsInitialized()) return;
    // Get min size to avoid overwriting it
    int minW, minH;
    glfwGetWindowSizeLimits(sit_gs.sit_glfw_window, &minW, &minH, NULL, NULL);
    glfwSetWindowSizeLimits(sit_gs.sit_glfw_window, minW, minH, width, height);
}

/**
 * @brief Sets the opacity of the entire window.
 * @details This allows for translucent or "ghosted" window effects.
 * @param opacity A value from `0.0f` (fully transparent) to `1.0f` (fully opaque). Values outside this range will be clamped.
 */
SITAPI void SituationSetWindowOpacity(float opacity) {
    if (!SituationIsInitialized()) return;
    // Clamp opacity between 0.0 and 1.0
    float clamped_opacity = (opacity < 0.0f) ? 0.0f : (opacity > 1.0f) ? 1.0f : opacity;
    glfwSetWindowOpacity(sit_gs.sit_glfw_window, clamped_opacity);
}

/**
 * @brief Attempts to bring the application window to the foreground and give it input focus.
 * @details The operating system's window manager ultimately decides whether to grant focus, but this function signals the application's intent to become the active window.
 * @see SituationHasWindowFocus()
 */
SITAPI void SituationSetWindowFocused(void) {
    if (!SituationIsInitialized()) return;
    glfwFocusWindow(sit_gs.sit_glfw_window);
}

/**
 * @brief Checks if the window currently has input focus.
 * @details The application's internal "paused" state may change based on focus.
 * @return `true` if the window is the active, focused window on the desktop, `false` otherwise.
 * @see SituationSetWindowFocused()
 */
SITAPI bool SituationHasWindowFocus(void) {
    if (!sit_gs.is_initialized) return false;
    return sit_gs.current_window_focus_state;
}

/**
 * @brief Gets the current width of the window in screen coordinates (logical size).
 * @details This value represents the size of the window as perceived by the OS's window manager.
 *          On HiDPI displays, this may be different from the actual pixel width of the framebuffer.
 * @return The current window width in screen coordinates.
 * @see SituationGetRenderWidth()
 */
SITAPI int SituationGetScreenWidth(void) {
    if (!SituationIsInitialized()) return 0;
    // We already cache this in our global state, but glfwGetWindowSize is the source of truth.
    int width, height;
    glfwGetWindowSize(sit_gs.sit_glfw_window, &width, &height);
    return width;
}

/**
 * @brief Gets the current height of the window in screen coordinates (logical size).
 * @details This value represents the size of the window as perceived by the OS's window manager.
 *          On HiDPI displays, this may be different from the actual pixel height of the framebuffer.
 * @return The current window height in screen coordinates.
 * @see SituationGetRenderHeight()
 */
SITAPI int SituationGetScreenHeight(void) {
    if (!SituationIsInitialized()) return 0;
    int width, height;
    glfwGetWindowSize(sit_gs.sit_glfw_window, &width, &height);
    return height;
}

/**
 * @brief Gets the current width of the rendering framebuffer in pixels (HiDPI-aware).
 * @details This is the actual pixel dimension you should use for setting viewports, creating render targets, and calculating projection matrices. On a 200% scaled display, this value may be twice `SituationGetScreenWidth()`.
 * @return The current backbuffer width in pixels.
 * @see SituationGetScreenWidth()
 */
SITAPI int SituationGetRenderWidth(void) {
    if (!SituationIsInitialized()) return 0;
    // This is the framebuffer size, which correctly handles DPI scaling.
    int width, height;
    glfwGetFramebufferSize(sit_gs.sit_glfw_window, &width, &height);
    return width;
}

/**
 * @brief Gets the current height of the rendering framebuffer in pixels (HiDPI-aware).
 * @details This is the actual pixel dimension you should use for setting viewports, creating
 *          render targets, and calculating projection matrices.
 * @return The current backbuffer height in pixels.
 * @see SituationGetScreenHeight()
 */
SITAPI int SituationGetRenderHeight(void) {
    if (!SituationIsInitialized()) return 0;
    int width, height;
    glfwGetFramebufferSize(sit_gs.sit_glfw_window, &width, &height);
    return height;
}

// --- Monitor Information ---

/**
 * @brief Gets the number of connected monitors.
 * @return The number of detected physical displays.
 */
SITAPI int SituationGetMonitorCount(void) {
    if (!SituationIsInitialized()) return 0;
    // Ensure cache is populated if it hasn't been already
    if (sit_gs.cached_physical_display_count == 0) {
        _SituationCachePhysicalDisplays();
    }
    return sit_gs.cached_physical_display_count;
}

/**
 * @brief Gets the index of the monitor the window is currently on.
 * @return The index of the current monitor.
 */
SITAPI int SituationGetCurrentMonitor(void) {
    // This is a direct 1:1 mapping to your existing, more descriptively named function.
    return _SituationGetCurrentDisplayIdentifier();
}

/**
 * @brief Gets the position of the specified monitor on the desktop.
 * @param monitor_id The index of the monitor (from 0 to GetMonitorCount()-1).
 * @return A Vector2 with the monitor's top-left XY coordinates.
 */
SITAPI Vector2 SituationGetMonitorPosition(int monitor_id) {
    Vector2 pos = {0.0f, 0.0f};
    if (!SituationIsInitialized()) return pos;

    if (sit_gs.cached_physical_display_count == 0) _SituationCachePhysicalDisplays();
    if (monitor_id < 0 || monitor_id >= sit_gs.cached_physical_display_count) return pos;

    SituationDisplayInfo* disp = &sit_gs.cached_physical_displays_array[monitor_id];
    if (disp->glfw_monitor_handle) {
        int x, y;
        glfwGetMonitorPos(disp->glfw_monitor_handle, &x, &y);
        pos[0] = (float)x;
        pos[1] = (float)y;
    }
    return pos;
}

/**
 * @brief Gets the width of the monitor's current video mode.
 * @param monitor_id The index of the monitor.
 * @return The width of the monitor in pixels.
 */
SITAPI int SituationGetMonitorWidth(int monitor_id) {
    if (!SituationIsInitialized()) return 0;
    if (sit_gs.cached_physical_display_count == 0) _SituationCachePhysicalDisplays();
    if (monitor_id < 0 || monitor_id >= sit_gs.cached_physical_display_count) return 0;
    // This data is already in our excellent cache.
    return sit_gs.cached_physical_displays_array[monitor_id].current_mode.width;
}

/**
 * @brief Gets the height of the monitor's current video mode.
 * @param monitor_id The index of the monitor.
 * @return The height of the monitor in pixels.
 */
SITAPI int SituationGetMonitorHeight(int monitor_id) {
    if (!SituationIsInitialized()) return 0;
    if (sit_gs.cached_physical_display_count == 0) _SituationCachePhysicalDisplays();
    if (monitor_id < 0 || monitor_id >= sit_gs.cached_physical_display_count) return 0;
    return sit_gs.cached_physical_displays_array[monitor_id].current_mode.height;
}

/**
 * @brief Gets the physical width of the monitor in millimeters.
 * @param monitor_id The index of the monitor.
 * @return The physical width of the monitor.
 */
SITAPI int SituationGetMonitorPhysicalWidth(int monitor_id) {
    if (!SituationIsInitialized()) return 0;
    if (sit_gs.cached_physical_display_count == 0) _SituationCachePhysicalDisplays();
    if (monitor_id < 0 || monitor_id >= sit_gs.cached_physical_display_count) return 0;

    SituationDisplayInfo* disp = &sit_gs.cached_physical_displays_array[monitor_id];
    if (disp->glfw_monitor_handle) {
        int width_mm, height_mm;
        glfwGetMonitorPhysicalSize(disp->glfw_monitor_handle, &width_mm, &height_mm);
        return width_mm;
    }
    return 0;
}

/**
 * @brief Gets the physical height of the monitor in millimeters.
 * @param monitor_id The index of the monitor.
 * @return The physical height of the monitor.
 */
SITAPI int SituationGetMonitorPhysicalHeight(int monitor_id) {
    if (!SituationIsInitialized()) return 0;
    if (sit_gs.cached_physical_display_count == 0) _SituationCachePhysicalDisplays();
    if (monitor_id < 0 || monitor_id >= sit_gs.cached_physical_display_count) return 0;

    SituationDisplayInfo* disp = &sit_gs.cached_physical_displays_array[monitor_id];
    if (disp->glfw_monitor_handle) {
        int width_mm, height_mm;
        glfwGetMonitorPhysicalSize(disp->glfw_monitor_handle, &width_mm, &height_mm);
        return height_mm;
    }
    return 0;
}

/**
 * @brief Gets the refresh rate of the monitor's current video mode.
 * @param monitor_id The index of the monitor.
 * @return The refresh rate in Hz.
 */
SITAPI int SituationGetMonitorRefreshRate(int monitor_id) {
    if (!SituationIsInitialized()) return 0;
    if (sit_gs.cached_physical_display_count == 0) _SituationCachePhysicalDisplays();
    if (monitor_id < 0 || monitor_id >= sit_gs.cached_physical_display_count) return 0;
    return sit_gs.cached_physical_displays_array[monitor_id].current_mode.refresh_rate;
}

/**
 * @brief Gets the human-readable UTF-8 name of the monitor.
 * @param monitor_id The index of the monitor.
 * @return A const string with the monitor's name.
 */
SITAPI const char* SituationGetMonitorName(int monitor_id) {
    if (!SituationIsInitialized()) return "N/A";
    if (sit_gs.cached_physical_display_count == 0) _SituationCachePhysicalDisplays();
    if (monitor_id < 0 || monitor_id >= sit_gs.cached_physical_display_count) return "Invalid ID";
    return sit_gs.cached_physical_displays_array[monitor_id].name;
}

// --- Window Properties ---

/**
 * @brief Gets the window's top-left position on the virtual desktop.
 * @return A `Vector2` containing the window's top-left (x, y) coordinates in screen space.
 * @see SituationSetWindowPosition()
 */
SITAPI Vector2 SituationGetWindowPosition(void) {
    Vector2 pos = {0.0f, 0.0f};
    if (!SituationIsInitialized()) return pos;
    int x, y;
    glfwGetWindowPos(sit_gs.sit_glfw_window, &x, &y);
    pos[0] = (float)x;
    pos[1] = (float)y;
    return pos;
}

/**
 * @brief Gets the DPI scaling factor for the window's content area.
 * @details On a standard 96 DPI display, this will be (1.0, 1.0). On a "Retina" or other HiDPI display scaled to 200%, this will be (2.0, 2.0). This factor represents the ratio
 *          between screen coordinates and framebuffer pixels.
 * @return A `Vector2` containing the horizontal and vertical content scale factors.
 */
SITAPI Vector2 SituationGetWindowScaleDPI(void) {
    Vector2 scale = {1.0f, 1.0f};
    if (!SituationIsInitialized()) return scale;
    glfwGetWindowContentScale(sit_gs.sit_glfw_window, &scale[0], &scale[1]);
    return scale;
}

/**
 * @brief Sets a callback function to be executed when the window gains or loses input focus.
 * @details The operating system's window manager ultimately decides whether to grant focus, but this function signals the application's intent to become the active window.
 * @param callback The function pointer to your callback. Pass `NULL` to clear the callback.
 * @param user_data A custom pointer that will be passed to your callback function.
 * @see SituationHasWindowFocus()
 */
SITAPI void SituationSetFocusCallback(SituationFocusCallback callback, void* user_data) {
    sit_gs.focus_callback_fn = callback;
    sit_gs.focus_callback_user_ptr = user_data;
}

/**
 * @brief Sets a set of window state profiles for specific window behavior during different states.
 * @details This sets profiles for an active (focused) and inactive (unfocused) window, letting the application dynamically change its state based on focus to conserve power or avoid unwanted behavior.
 * @param active_flags A bitmask of `SITUATION_FLAG_*` defines to set when the window has focus.
 * @param inactive_flags A bitmask of `SITUATION_FLAG_*` defines to set when the window does not have focus.
 * @see SituationClearWindowState(), SituationApplyCurrentProfileWindowState()
 */
SITAPI SituationError SituationSetWindowStateProfiles(uint32_t active_flags, uint32_t inactive_flags) {
    if (!sit_gs.is_initialized) return SITUATION_ERROR_NOT_INITIALIZED;
    sit_gs.active_profile_window_flags = active_flags;
    sit_gs.inactive_profile_window_flags = inactive_flags;
    return SituationApplyCurrentProfileWindowState();
}

/**
 * @brief Manually applies the appropriate window state profile based on the current focus.
 * @details This function is the core of the profile management system. It checks if the window currently has focus and then applies the full set of flags defined in either the "active" or "inactive" profile, which were previously set by `SituationSetWindowStateProfiles`.
 *          This function is called automatically when focus changes, but can also be called manually if you need to force a re-application of the current profile's state. It orchestrates all the underlying calls to change window attributes like fullscreen, decoration, topmost, etc.
 *
 * @par Execution Order
 *   To prevent conflicts, state changes are applied in a specific order:
 *   1. Fullscreen/windowed mode is handled first, as it is the most significant state change.
 *   2. Attributes like decoration, topmost, and resizability are applied next.
 *   3. Finally, states like minimized or maximized are applied.
 *
 * @return SITUATION_SUCCESS on success, or an error code if setting any of the flags fails.
 * @see SituationSetWindowStateProfiles(), SituationToggleWindowStateFlags()
 */
SITAPI SituationError SituationApplyCurrentProfileWindowState(void) {
    if (!sit_gs.is_initialized || !sit_gs.sit_glfw_window) return SITUATION_ERROR_NOT_INITIALIZED;

    uint32_t target_flags = sit_gs.current_window_focus_state ? sit_gs.active_profile_window_flags : sit_gs.inactive_profile_window_flags;
    bool is_currently_fullscreen = (glfwGetWindowMonitor(sit_gs.sit_glfw_window) != NULL);

    // Handle fullscreen/windowed transition first, as it can affect other attributes or require specific order.
    if (target_flags & SITUATION_FLAG_FULLSCREEN_MODE) {
        if (!is_currently_fullscreen) {
            int monitor_id = _SituationGetCurrentDisplayIdentifier(); 
            if (monitor_id == -1) { // If no specific monitor, try primary
                if (sit_gs.cached_physical_display_count > 0) {
                    for(int i=0; i < sit_gs.cached_physical_display_count; ++i) {
                        if(sit_gs.cached_physical_displays_array[i].is_primary) {
                            monitor_id = sit_gs.cached_physical_displays_array[i].situation_monitor_id;
                            break;
                        }
                    }
                    if (monitor_id == -1) monitor_id = sit_gs.cached_physical_displays_array[0].situation_monitor_id; // Fallback to first
                }
            }
            
            if (monitor_id != -1 && sit_gs.cached_physical_displays_array) {
                SituationDisplayInfo* disp = &sit_gs.cached_physical_displays_array[monitor_id];
                // Use monitor's current native resolution for fullscreen typically, or a user-defined one.
                // Here, using its current mode ensures it fills that monitor.
                SituationSetDisplayMode(monitor_id, &disp->current_mode, true); 
            } else { // Absolute fallback: use GLFW primary monitor with its current mode
                GLFWmonitor* primary = glfwGetPrimaryMonitor();
                const GLFWvidmode* mode = glfwGetVideoMode(primary);
                if (primary && mode) {
                    glfwSetWindowMonitor(sit_gs.sit_glfw_window, primary, 0, 0, mode->width, mode->height, mode->refreshRate);
                } else {
                     _SituationSetErrorFromCode(SITUATION_ERROR_DISPLAY_QUERY, "Cannot enter fullscreen, primary monitor info unavailable.");
                     // Potentially skip fullscreen attempt or return error
                }
            }
        }
    } else { // Not fullscreen mode - ensure windowed
        if (is_currently_fullscreen) {
            // Revert to windowed, using stored main_window_width/height
            // And try to center on primary monitor (or current monitor if identifiable)
            int current_mon_id = _SituationGetCurrentDisplayIdentifier();
            GLFWmonitor* target_mon_for_windowed = NULL;
            if (current_mon_id != -1 && sit_gs.cached_physical_displays_array) {
                target_mon_for_windowed = sit_gs.cached_physical_displays_array[current_mon_id].glfw_monitor_handle;
            }
            if (!target_mon_for_windowed) target_mon_for_windowed = glfwGetPrimaryMonitor();

            const GLFWvidmode* mode = glfwGetVideoMode(target_mon_for_windowed);
            int win_x = 100, win_y = 100; // Default position
            if (mode) {
                int mon_x_pos, mon_y_pos;
                glfwGetMonitorPos(target_mon_for_windowed, &mon_x_pos, &mon_y_pos);
                win_x = mon_x_pos + (mode->width - sit_gs.main_window_width) / 2;
                win_y = mon_y_pos + (mode->height - sit_gs.main_window_height) / 2;
            }
            glfwSetWindowMonitor(sit_gs.sit_glfw_window, NULL, win_x, win_y, sit_gs.main_window_width, sit_gs.main_window_height, 0);
        }
    }
    
    // Apply other attributes AFTER fullscreen is handled.
    // Some attributes might be hints and only work at creation, or might be ignored in fullscreen.
    // GLFW_FLOATING, GLFW_DECORATED, GLFW_RESIZABLE are settable post-creation via glfwSetWindowAttrib.
    glfwSetWindowAttrib(sit_gs.sit_glfw_window, GLFW_FLOATING, (target_flags & SITUATION_FLAG_WINDOW_TOPMOST) ? GLFW_TRUE : GLFW_FALSE);
    glfwSetWindowAttrib(sit_gs.sit_glfw_window, GLFW_DECORATED, (target_flags & SITUATION_FLAG_WINDOW_UNDECORATED) ? GLFW_FALSE : GLFW_TRUE);
    glfwSetWindowAttrib(sit_gs.sit_glfw_window, GLFW_RESIZABLE, (target_flags & SITUATION_FLAG_WINDOW_RESIZABLE) ? GLFW_TRUE : GLFW_FALSE);
    
    // Hidden state
    if (target_flags & SITUATION_FLAG_WINDOW_HIDDEN) { 
        if(glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_VISIBLE)) glfwHideWindow(sit_gs.sit_glfw_window); 
    } else { 
        if(!glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_VISIBLE)) glfwShowWindow(sit_gs.sit_glfw_window); 
    }

    // Minimized/Maximized state (mutually exclusive from user's perspective of "restored")
    if (target_flags & SITUATION_FLAG_WINDOW_MINIMIZED) {
        if (!glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_ICONIFIED)) glfwIconifyWindow(sit_gs.sit_glfw_window);
    } else if (target_flags & SITUATION_FLAG_WINDOW_MAXIMIZED) { // Only consider maximize if not minimizing
        if (glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_ICONIFIED)) glfwRestoreWindow(sit_gs.sit_glfw_window); // Must restore if iconified
        if (!glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_MAXIMIZED)) glfwMaximizeWindow(sit_gs.sit_glfw_window);
    } else { // Not minimized and not maximized -> should be "normal" restored state
        if (glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_ICONIFIED) || glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_MAXIMIZED)) {
            glfwRestoreWindow(sit_gs.sit_glfw_window);
        }
    }
    
    // VSync hint
    if (target_flags & SITUATION_FLAG_VSYNC_HINT) glfwSwapInterval(1); else glfwSwapInterval(0);
    
    // Borderless windowed requires undecorated and specific size/pos, often set at creation or with fullscreen toggle logic.
    // If SITUATION_FLAG_BORDERLESS_WINDOWED_MODE is set:
    // Ensure undecorated, ensure not fullscreen, set window to monitor size/pos.
    // This is complex and might conflict with simple SITUATION_FLAG_WINDOW_UNDECORATED.
    // For now, assume SITUATION_FLAG_WINDOW_UNDECORATED covers the "no border" part.
    // True borderless windowed fullscreen usually means:
    // Undecorated, same size as monitor, positioned at monitor's 0,0.
    // This is not handled explicitly here beyond the UNDECORATED flag.
    
    // MSAA is a creation hint, cannot be changed on the fly easily.

    // Call framebuffer size callback manually to update viewport and projection immediately after potential size/monitor changes
    int fb_w, fb_h;
    glfwGetFramebufferSize(sit_gs.sit_glfw_window, &fb_w, &fb_h);
    _SituationGLFWFramebufferSizeCallback(sit_gs.sit_glfw_window, fb_w, fb_h);

    return SITUATION_SUCCESS;
}

/**
 * @brief Toggles window state using flags in the current focus profile
 * @details Allows you to toggle individual flags in the current profile (focused or unfocused) and apply the changes immediately.
 *
 * @param flags_to_toggle A bitmask of `SITUATION_FLAG_*` defines to toggle (flip) in the profile.
 */
SITAPI SituationError SituationToggleWindowStateFlags(SituationWindowStateFlags flags_to_toggle) {
    if (!sit_gs.is_initialized) return SITUATION_ERROR_NOT_INITIALIZED;
    uint32_t* profile_to_modify = sit_gs.current_window_focus_state ? &sit_gs.active_profile_window_flags : &sit_gs.inactive_profile_window_flags;
    
    // Special handling for mutually exclusive flags like MINIMIZED/MAXIMIZED/FULLSCREEN
    if (flags_to_toggle & SITUATION_FLAG_FULLSCREEN_MODE) {
        // If toggling fullscreen ON, turn off maximized/minimized in the profile
        if (!(*profile_to_modify & SITUATION_FLAG_FULLSCREEN_MODE)) { // Means we are turning it ON
            *profile_to_modify &= ~(SITUATION_FLAG_WINDOW_MAXIMIZED | SITUATION_FLAG_WINDOW_MINIMIZED);
        }
    } else if (flags_to_toggle & SITUATION_FLAG_WINDOW_MAXIMIZED) {
        if (!(*profile_to_modify & SITUATION_FLAG_WINDOW_MAXIMIZED)) { // Turning Maximized ON
            *profile_to_modify &= ~(SITUATION_FLAG_FULLSCREEN_MODE | SITUATION_FLAG_WINDOW_MINIMIZED);
        }
    } else if (flags_to_toggle & SITUATION_FLAG_WINDOW_MINIMIZED) {
         if (!(*profile_to_modify & SITUATION_FLAG_WINDOW_MINIMIZED)) { // Turning Minimized ON
            *profile_to_modify &= ~(SITUATION_FLAG_FULLSCREEN_MODE | SITUATION_FLAG_WINDOW_MAXIMIZED);
        }
    }
    // Regular toggle for the requested flag
    *profile_to_modify ^= (uint32_t)flags_to_toggle;
    return SituationApplyCurrentProfileWindowState();
}

/**
 * @brief Gets a bitmask representing the window's *actual*, current state.
 * @details This function queries the underlying windowing system (GLFW) for the real-time status of various window attributes (e.g., is it *really* maximized, is it *really* fullscreen) and combines them into a single bitmask of `SITUATION_FLAG_*` flags.
 *          This is useful for debugging or for comparing the window's actual state against the *target* state defined in the window profiles.
 *
 * @return A `uint32_t` bitmask composed of `SITUATION_FLAG_*` defines that reflect the current window state. Returns 0 if the library is not initialized.
 * @see SituationIsWindowState()
 */
SITAPI uint32_t SituationGetCurrentActualWindowStateFlags(void) {
    if (!sit_gs.is_initialized || !sit_gs.sit_glfw_window) return 0;
    uint32_t flags = 0;
    if (glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_FLOATING)) flags |= SITUATION_FLAG_WINDOW_TOPMOST;
    if (glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_VISIBLE) == GLFW_FALSE) flags |= SITUATION_FLAG_WINDOW_HIDDEN;
    if (glfwGetWindowMonitor(sit_gs.sit_glfw_window) != NULL) flags |= SITUATION_FLAG_FULLSCREEN_MODE;
    if (glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_DECORATED) == GLFW_FALSE) flags |= SITUATION_FLAG_WINDOW_UNDECORATED;
    // SITUATION_FLAG_WINDOW_ALWAYS_RUN - Not directly queryable
    if (glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_ICONIFIED)) flags |= SITUATION_FLAG_WINDOW_MINIMIZED;
    if (glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_MAXIMIZED)) flags |= SITUATION_FLAG_WINDOW_MAXIMIZED;
    if (glfwGetWindowAttrib(sit_gs.sit_glfw_window, GLFW_RESIZABLE)) flags |= SITUATION_FLAG_WINDOW_RESIZABLE;
    
    // SITUATION_FLAG_MSAA_4X_HINT: Can't query samples from default FBO easily after creation.
    // SITUATION_FLAG_VSYNC_HINT: glfwSwapInterval state is not directly queryable.
    // We can store the last set VSync state if needed.
    // For now, reflect profile if desired, or accept it's not fully queryable.

    // Borderless check: if undecorated, not fullscreen, and window size matches monitor size.
    // This is a heuristic and can be complex.
    if ((flags & SITUATION_FLAG_WINDOW_UNDECORATED) && !(flags & SITUATION_FLAG_FULLSCREEN_MODE)) {
        int win_w, win_h, mon_w = 0, mon_h = 0;
        glfwGetWindowSize(sit_gs.sit_glfw_window, &win_w, &win_h);
        int mon_id = _SituationGetCurrentDisplayIdentifier();
        if (mon_id != -1 && sit_gs.cached_physical_displays_array) {
            mon_w = sit_gs.cached_physical_displays_array[mon_id].current_mode.width;
            mon_h = sit_gs.cached_physical_displays_array[mon_id].current_mode.height;
        }
        if (win_w == mon_w && win_h == mon_h) {
            flags |= SITUATION_FLAG_BORDERLESS_WINDOWED_MODE;
        }
    }
    return flags;
}

// --- Application Pause/Resume Implementation ---
/**
 * @brief Pauses the library's internal, time-dependent subsystems.
 * @details This function sets an internal flag that signals the application is in a paused state. Its primary effect is to pause the audio device, stopping all sound playback.
 *          This function is called automatically when the window is minimized (via the `_SituationGLFWWindowIconifyCallback`) and can also be called manually by the user to implement an in-game pause menu or similar functionality.
 *
 * @note This function only affects library subsystems. It does not stop the main application loop from running. It is the developer's responsibility to check `SituationIsAppPaused()` in their main loop and halt their own game logic and updates accordingly.
 *
 * @see SituationResumeApp(), SituationIsAppPaused(), SituationPauseAudioDevice()
 */
SITAPI void SituationPauseApp(void) { // Largely same logic
    if (!sit_gs.is_initialized || sit_gs.is_app_internally_paused) return;
    sit_gs.is_app_internally_paused = true;
    SituationPauseAudioDevice();
    // Minimizing window on pause is now handled by profile flags in ApplyCurrentProfileWindowState,
    // triggered by focus loss or explicit call.
    // Or if iconify callback calls this, it might re-apply inactive profile which could include minimize.
}

/**
 * @brief Resumes the library's internal, time-dependent subsystems from a paused state.
 * @details This function clears the internal paused-state flag and resumes any subsystems that were halted by `SituationPauseApp()`, most notably by resuming audio playback on the main audio device.
 *          This function is called automatically when a minimized window is restored and can also be called manually by the user to un-pause the application.
 *
 * @see SituationPauseApp(), SituationIsAppPaused(), SituationResumeAudioDevice()
 */
SITAPI void SituationResumeApp(void) { // Largely same logic
    if (!sit_gs.is_initialized || !sit_gs.is_app_internally_paused) return;
    sit_gs.is_app_internally_paused = false;
    SituationResumeAudioDevice();
    // Window restoration handled by profile or iconify callback.
}

/**
 * @brief Checks if the application is currently in an internally-paused state.
 * @details This function queries the flag set by `SituationPauseApp()` and `SituationResumeApp()`. It is intended to be used in the main application loop to control whether game logic, physics, or animations should be updated.
 *
 * @example
 *   // In your main loop, after updating timers:
 *   if (!SituationIsAppPaused()) {
 *       UpdatePhysics(delta_time);
 *       UpdateAnimations(delta_time);
 *   }
 *
 * @return `true` if the application is paused, `false` otherwise.
 * @return `true` if the library has not yet been initialized.
 *
 * @see SituationPauseApp(), SituationResumeApp()
 */
SITAPI bool SituationIsAppPaused(void) {
    if (!sit_gs.is_initialized) return true;
    return sit_gs.is_app_internally_paused;
}

//==================================================================================
// Image Module Implementation
//==================================================================================
/**
 * @brief Loads an image from a file into a CPU-side memory buffer.
 * @details This function uses the stb_image library to load a wide variety of common image formats (PNG, JPG, BMP, etc.) from the file system. The image is always converted to a 32-bit RGBA format for consistency across the library.
 *
 * @warning This function requires the `stb_image.h` implementation to be included in the project. If not available, the function will fail and set an error.
 * @warning This function allocates new memory for the `image.data`. The caller is **responsible** for freeing this memory by calling `SituationUnloadImage()` on the returned `SituationImage`. Failure to do so will result in a memory leak.
 *
 * @param fileName The file system path to the image file to load.
 *
 * @return A new `SituationImage` containing the pixel data, width, and height.
 * @return A zeroed (invalid) `SituationImage` if the file cannot be found, the format is unsupported, or a memory allocation error occurs.
 *
 * @see SituationUnloadImage(), SituationLoadImageFromMemory(), SituationCreateTexture()
 */
SITAPI SituationImage SituationLoadImage(const char *fileName) {
    SituationImage image = {0};
#if defined(STB_IMAGE_IMPLEMENTATION)
    int channels;
    // We force 4 channels (RGBA) for consistency across the library.
    image.data = stbi_load(fileName, &image.width, &image.height, &channels, 4);
    if (image.data == NULL) {
        _SituationSetErrorFromCode(SITUATION_ERROR_FILE_ACCESS, "Failed to load image file or format not supported.");
        image.width = 0;
        image.height = 0;
    }
#else
    _SituationSetError("Image loading not available. Please implement stb_image.h.");
#endif
    return image;
}

/**
 * @brief Loads an image from a memory buffer into a `SituationImage`.
 * @details This function is useful for loading image data that is already in memory, such as data embedded in the executable or loaded from a custom archive file. It uses stb_image to auto-detect the format (PNG, JPG, etc.) from the buffer and decodes it. The image is always converted to a 32-bit RGBA format.
 *
 * @warning This function requires the `stb_image.h` implementation to be included in the project.
 * @warning This function allocates new memory for the `image.data`. The caller is **responsible** for freeing this memory by calling `SituationUnloadImage()`.
 *
 * @param fileType A hint for the file format (e.g., ".png"). This is currently ignored as stb_image auto-detects the format from the data.
 * @param fileData A pointer to the buffer containing the raw, compressed image file data.
 * @param dataSize The size of the `fileData` buffer in bytes.
 *
 * @return A new `SituationImage` containing the decoded pixel data, width, and height.
 * @return A zeroed (invalid) `SituationImage` if the data is corrupt, the format is unsupported, or a memory allocation error occurs.
 *
 * @see SituationUnloadImage(), SituationLoadImage()
 */
SITAPI SituationImage SituationLoadImageFromMemory(const char *fileType, const unsigned char *fileData, int dataSize) {
    (void)fileType; // fileType is mainly for hinting, stbi_load_from_memory auto-detects.
    SituationImage image = {0};
#if defined(STB_IMAGE_IMPLEMENTATION)
    int channels;
    image.data = stbi_load_from_memory(fileData, dataSize, &image.width, &image.height, &channels, 4);
    if (image.data == NULL) {
        _SituationSetError("Failed to load image from memory or format not supported.");
        image.width = 0;
        image.height = 0;
    }
#else
    _SituationSetError("Image loading not available. Please implement stb_image.h.");
#endif
    return image;
}

/**
 * @brief Unloads an image's pixel data from memory.
 * @details This function is the only correct way to free the memory associated with a SituationImage, as it uses the library's internal memory management functions (`SIT_FREE`), ensuring compatibility regardless of how dependencies were configured.
 *
 * @param image The image to unload. Its data pointer becomes invalid after this call.
 */
SITAPI void SituationUnloadImage(SituationImage image) {
    // We are using the same family of memory functions that were used to allocate the data, whether it came from stb_image or GenImage functions.
    if (image.data) {
        SIT_FREE(image.data);
    }
}

/**
 * @brief Checks if a `SituationImage` handle contains valid, usable data.
 * @details A valid image is defined as having a non-NULL data pointer and both width and height greater than zero.
 *
 * @param image The `SituationImage` to check.
 *
 * @return `true` if the image is valid, `false` otherwise.
 */
SITAPI bool SituationIsImageValid(SituationImage image) {
    return (image.data != NULL && image.width > 0 && image.height > 0);
}

/**
 * @brief Saves a CPU-side `SituationImage` to a file on disk.
 * @details This function determines the output format based on the file extension of `fileName`.
 *
 * @par Supported Formats
 *   - **`.png`:** Provides high-quality, compressed output. Requires the `stb_image_write.h` implementation to be included in the project.
 *   - **`.bmp`:** Provides uncompressed output. This is supported natively by the library as a fallback.
 *
 * @param image The `SituationImage` to save. The image must be valid.
 * @param fileName The destination file path, including the desired extension (e.g., "output/my_image.png").
 *
 * @return `true` if the image was successfully saved, `false` otherwise. An error will be set on failure (e.g., unsupported format, file I/O error).
 *
 * @see SituationLoadImage(), SituationTakeScreenshot()
 */
SITAPI bool SituationExportImage(SituationImage image, const char *fileName) {
    if (!SituationIsImageValid(image) || !fileName) return false;

    const char *ext = SituationGetFileExtension(fileName);
    bool success = false;

    if (ext != NULL && (strcmp(ext, ".png") == 0 || strcmp(ext, ".PNG") == 0)) {
#if defined(STB_IMAGE_WRITE_IMPLEMENTATION)
        success = (stbi_write_png(fileName, image.width, image.height, 4, image.data, image.width * 4) != 0);
#else
        _SituationSetError("PNG export not available. Please implement stb_image_write.h.");
#endif
    } else if (ext != NULL && (strcmp(ext, ".bmp") == 0 || strcmp(ext, ".BMP") == 0)) {
        // We already have a BMP writer for screenshots, let's reuse it.
        success = _SituationSaveImageBMP(fileName, &image);
    } else {
        _SituationSetError("Unsupported image export format. Use .png or .bmp.");
    }
    return success;
}

/**
 * @brief Creates a new `SituationImage` by making a deep copy of another.
 * @details This function allocates a new memory buffer and copies the entire pixel data from the source image into it, creating a completely independent duplicate.
 *
 * @warning This function allocates new memory for the returned image's `data`. The caller is **responsible** for freeing this memory by calling `SituationUnloadImage()`.
 *
 * @param image The source `SituationImage` to copy.
 *
 * @return A new, independent `SituationImage`.
 * @return A zeroed (invalid) `SituationImage` if the source image is invalid or if memory allocation fails.
 *
 * @see SituationUnloadImage(), SituationImageCrop()
 */
SITAPI SituationImage SituationImageCopy(SituationImage image) {
    SituationImage new_image = {0};
    if (!SituationIsImageValid(image)) return new_image;

    size_t data_size = image.width * image.height * 4;
    new_image.data = malloc(data_size);

    if (new_image.data) {
        memcpy(new_image.data, image.data, data_size);
        new_image.width = image.width;
        new_image.height = image.height;
    }
    return new_image;
}

/**
 * @brief Draws a portion of a source image onto a destination image with an opaque copy (blit).
 * @details This function performs a fast, direct memory copy of a rectangular region of pixels from a source image to a destination image. It does not perform any alpha blending; the source pixels completely overwrite the destination pixels.
 *
 * @par Boundary Handling
 *   The function is robust against invalid coordinates. It automatically calculates the intersection of the source rectangle (clamped to the source image's bounds) and the destination area (clamped to the destination image's bounds) and will only copy the overlapping region. This prevents any out-of-bounds memory access.
 *
 * @param[in,out] dst A pointer to the destination `SituationImage` to be modified.
 * @param src The source `SituationImage` to draw from.
 * @param srcRect The rectangular region within the source image to copy.
 * @param dstPos The top-left `(x, y)` position on the destination image where the `srcRect` will be drawn.
 *
 * @note For drawing with transparency, use `SituationImageDrawAlpha()`.
 *
 * @see SituationImageDrawAlpha()
 */
SITAPI void SituationImageDraw(SituationImage *dst, SituationImage src, Rectangle srcRect, Vector2 dstPos) {
    // 1. --- Initial Validation ---
    if (!SituationIsImageValid(*dst) || !SituationIsImageValid(src)) { return; }

    // 2. --- Calculate the Intersection Rectangle (The core of the logic) ---
    
    // First, clip the source rectangle to the source image's bounds.
    int srcClipX = (srcRect.x < 0) ? 0 : srcRect.x;
    int srcClipY = (srcRect.y < 0) ? 0 : srcRect.y;
    int srcClipW = (srcRect.x + srcRect.width > src.width) ? (src.width - srcRect.x) : srcRect.width;
    int srcClipH = (srcRect.y + srcRect.height > src.height) ? (src.height - srcRect.y) : srcRect.height;
    
    // --- [INTEGER CONVERSION] ---
    // All pixel calculations must use integers. Round the float inputs ONCE.
    int i_dstX = (int)roundf(dstPos.x);
    int i_dstY = (int)roundf(dstPos.y);
    int i_srcX = (int)roundf(srcRect.x);
    int i_srcY = (int)roundf(srcRect.y);
    int i_srcW = (int)roundf(srcRect.width);
    int i_srcH = (int)roundf(srcRect.height);

    // Adjust destination position if source rectangle was clipped from the top-left.
    int dstClipX = i_dstX + (srcClipX - i_srcX);
    int dstClipY = i_dstY + (srcClipY - i_srcY);

    // Now, clip the destination rectangle to the destination image's bounds.
    if (dstClipX < 0) {
        srcClipW += dstClipX; // Reduce width
        srcClipX -= dstClipX; // Move source start point forward
        dstClipX = 0;
    }
    if (dstClipY < 0) {
        srcClipH += dstClipY; // Reduce height
        srcClipY -= dstClipY; // Move source start point down
        dstClipY = 0;
    }
    
    // Final width/height check against destination's right/bottom edges.
    if (dstClipX + srcClipW > dst->width) {
        srcClipW = dst->width - dstClipX;
    }
    if (dstClipY + srcClipH > dst->height) {
        srcClipH = dst->height - dstClipY;
    }

    // 3. --- Final Check & Pixel Copy ---
    if (srcClipW <= 0 || srcClipH <= 0) {
        return;
    }

    unsigned char *srcPixels = (unsigned char*)src.data;
    unsigned char *dstPixels = (unsigned char*)dst.data;
    const int pixelSize = 4;

    size_t rowWidthInBytes = (size_t)srcClipW * pixelSize;

    // The loop itself doesn't need to change, as it uses the clipped integer values.
    for (int y = 0; y < srcClipH; ++y) {
        unsigned char* srcRowStart = srcPixels + (((size_t)srcClipY + y) * src.width + (size_t)srcClipX) * pixelSize;
        unsigned char* dstRowStart = dstPixels + (((size_t)dstClipY + y) * dst->width + (size_t)dstClipX) * pixelSize;
        memcpy(dstRowStart, srcRowStart, rowWidthInBytes);
    }
}

/**
 * @brief Generates a new CPU-side image filled with a single, solid color.
 * @details This function allocates a new memory buffer and creates a `SituationImage` of the specified dimensions. Every pixel in the image is set to the provided color. This is a common utility for creating placeholder textures, background layers, or base images for further drawing operations.
 *
 * @par Performance Note
 *   The function uses an optimized path that packs the RGBA color into a 32-bit integer and fills the memory buffer in a single loop, which is significantly faster than setting each channel of each pixel individually.
 *
 * @warning This function allocates new memory for the `image.data`. The caller is **responsible** for freeing this memory by calling `SituationUnloadImage()` on the returned `SituationImage`. Failure to do so will result in a memory leak.
 *
 * @param width The width of the image to generate in pixels.
 * @param height The height of the image to generate in pixels.
 * @param color The `ColorRGBA` to fill the image with.
 *
 * @return A new `SituationImage`.
 * @return A zeroed (invalid) `SituationImage` if the width or height are invalid, or if memory allocation fails.
 *
 * @see SituationUnloadImage(), SituationGenImageGradient()
 */
SITAPI SituationImage SituationGenImageColor(int width, int height, ColorRGBA color) {
    SituationImage image = {0};
    image.width = width;
    image.height = height;
    size_t data_size = width * height * 4;
    image.data = malloc(data_size);

    if (image.data) {
        unsigned int* pixels = (unsigned int*)image.data;
        // Pack color into an integer for fast filling
        unsigned int c = (unsigned int)color.a << 24 | (unsigned int)color.b << 16 | (unsigned int)color.g << 8 | (unsigned int)color.r;
        for (int i = 0; i < width * height; ++i) {
            pixels[i] = c;
        }
    }
    return image;
}

/**
 * Generates an image with a 4-corner color gradient.
 * @param width The width of the image to generate.
 * @param height The height of the image to generate.
 * @param tl The color for the Top-Left corner.
 * @param tr The color for the Top-Right corner.
 * @param bl The color for the Bottom-Left corner.
 * @param br The color for the Bottom-Right corner.
 * @return A SituationImage containing the gradient. The data must be freed later.
 */
SITAPI SituationImage SituationGenImageGradient(int width, int height, ColorRGBA tl, ColorRGBA tr, ColorRGBA bl, ColorRGBA br) {
    SituationImage image = {0};
    image.width = width;
    image.height = height;
    image.data = malloc(width * height * 4); // 4 bytes per pixel (RGBA)

    if (image.data) {
        unsigned char* pixels = (unsigned char*)image.data;

        for (int y = 0; y < height; ++y) {
            // Vertical ratio (0.0 at top, 1.0 at bottom)
            float ratio_y = (height > 1) ? (float)y / (float)(height - 1) : 0.0f;

            for (int x = 0; x < width; ++x) {
                // Horizontal ratio (0.0 at left, 1.0 at right)
                float ratio_x = (width > 1) ? (float)x / (float)(width - 1) : 0.0f;

                // 1. Interpolate horizontally along the top edge
                float top_r = (float)tl.r * (1.0f - ratio_x) + (float)tr.r * ratio_x;
                float top_g = (float)tl.g * (1.0f - ratio_x) + (float)tr.g * ratio_x;
                float top_b = (float)tl.b * (1.0f - ratio_x) + (float)tr.b * ratio_x;
                float top_a = (float)tl.a * (1.0f - ratio_x) + (float)tr.a * ratio_x;

                // 2. Interpolate horizontally along the bottom edge
                float bottom_r = (float)bl.r * (1.0f - ratio_x) + (float)br.r * ratio_x;
                float bottom_g = (float)bl.g * (1.0f - ratio_x) + (float)br.g * ratio_x;
                float bottom_b = (float)bl.b * (1.0f - ratio_x) + (float)br.b * ratio_x;
                float bottom_a = (float)bl.a * (1.0f - ratio_x) + (float)br.a * ratio_x;

                // 3. Interpolate vertically between the two results from above
                unsigned char r = (unsigned char)(top_r * (1.0f - ratio_y) + bottom_r * ratio_y);
                unsigned char g = (unsigned char)(top_g * (1.0f - ratio_y) + bottom_g * ratio_y);
                unsigned char b = (unsigned char)(top_b * (1.0f - ratio_y) + bottom_b * ratio_y);
                unsigned char a = (unsigned char)(top_a * (1.0f - ratio_y) + bottom_a * ratio_y);
                
                // Set the pixel color
                int index = (y * width + x) * 4;
                pixels[index + 0] = r;
                pixels[index + 1] = g;
                pixels[index + 2] = b;
                pixels[index + 3] = a;
            }
        }
    }
    return image;
}

/**
 * @brief Crops an image in-place to a specified rectangular region.
 * @details This is a destructive operation that modifies the provided `SituationImage` struct.
 *          It allocates a new memory buffer for the cropped pixel data, copies the relevant pixels from the original image, frees the old image data, and then updates the image's `data`, `width`, and `height` members to reflect the new, smaller dimensions.
 *
 * @par Boundary Handling
 *   The function safely handles crop rectangles that are partially or fully outside the original image's bounds. The rectangle is automatically clamped to the valid area of the source image before the crop is performed.
 *   If the resulting intersection is empty (width or height is zero or less), the function does nothing.
 *
 * @param[in,out] image A pointer to the `SituationImage` to be modified.
 * @param crop A `Rectangle` struct defining the desired area to keep. The `x` and `y` coordinates are the top-left corner of the crop region.
 *
 * @note If the crop operation fails due to a memory allocation error, the original image is left unmodified.
 *
 * @see SituationImageResize(), SituationImageCopy()
 */
SITAPI void SituationImageCrop(SituationImage *image, Rectangle crop) {
    if (!SituationIsImageValid(*image) || crop.width <= 0 || crop.height <= 0) return;

    int x = (int)crop.x;
    int y = (int)crop.y;
    int w = (int)crop.width;
    int h = (int)crop.height;

    // Clamp crop rectangle to image bounds
    if (x < 0) { w += x; x = 0; }
    if (y < 0) { h += y; y = 0; }
    if (x + w > image->width) w = image->width - x;
    if (y + h > image->height) h = image->height - y;
    if (w <= 0 || h <= 0) return;

    void* cropped_data = malloc(w * h * 4);
    if (!cropped_data) return;

    unsigned char* src = (unsigned char*)image->data;
    unsigned char* dst = (unsigned char*)cropped_data;
    for (int j = 0; j < h; ++j) {
        memcpy(dst + (j * w * 4), src + ((y + j) * image->width + x) * 4, w * 4);
    }

    SituationUnloadImage(*image); // Free the old image data
    image->data = cropped_data;
    image->width = w;
    image->height = h;
}

/**
 * @brief Resizes an image in-place to new dimensions using a high-quality algorithm.
 * @details This is a destructive operation that modifies the provided `SituationImage` struct. It allocates a new memory buffer for the resized pixel data, performs the scaling, frees the old image data, and then updates the image's `data`, `width`, and `height` members.
 *
 * @par Resizing Algorithm
 *   This function uses the `stb_image_resize` library, specifically the `stbir_resize_uint8_srgb` function. This ensures a high-quality, perceptually correct resize by operating in a linear color space, which is the proper way to handle sRGB images. This prevents the common issue of resized images appearing too dark or having incorrect color tones.
 *
 * @warning This function requires the `stb_image_resize.h` implementation to be included in the project. If not available, the function will do nothing and set an error.
 * @warning If the resize operation fails (e.g., due to a memory allocation error), the original image is left unmodified.
 *
 * @param[in,out] image A pointer to the `SituationImage` to be modified.
 * @param newWidth The target width of the image in pixels. Must be greater than 0.
 * @param newHeight The target height of the image in pixels. Must be greater than 0.
 *
 * @see SituationImageCrop(), SituationImageCopy()
 */
SITAPI void SituationImageResize(SituationImage *image, int newWidth, int newHeight) {
    // 1. --- Validation ---
    if (!SituationIsImageValid(*image) || newWidth <= 0 || newHeight <= 0) { return; }
    if (image->width == newWidth && image->height == newHeight) { return; }

#if defined(STB_IMAGE_RESIZE_IMPLEMENTATION)
    // 2. --- Allocate Memory for the New Image ---
    unsigned char *newData = (unsigned char*)malloc((size_t)newWidth * (size_t)newHeight * 4);
    if (!newData) {
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Image resize buffer");
        return;
    }

    // 3. --- Call the Correct STB Resize Function ---
    // This now uses the exact signature you provided.
    unsigned char* result = stbir_resize_uint8_srgb(
        (const unsigned char*)image->data, // Input pixels
        image->width,                      // Input width
        image->height,                     // Input height
        image->width * 4,                  // Input stride (bytes per row)
        newData,                           // Output pixels buffer
        newWidth,                          // Output width
        newHeight,                         // Output height
        newWidth * 4,                      // Output stride
        STBIR_RGBA                         // The pixel layout (4 channels, RGBA order)
    );

    // 4. --- Update the SituationImage Struct ---
    // The new API returns a pointer to the output buffer on success, or NULL on failure.
    if (result) {
        free(image->data); // Free the old image data
        image->data = newData;
        image->width = newWidth;
        image->height = newHeight;
    } else {
        // The resize failed. Clean up and leave the original image untouched.
        _SituationSetError("stb_image_resize failed.");
        free(newData);
    }
#else
    _SituationSetError("Image resizing not available. Please implement stb_image_resize.h.");
#endif
}

/**
 * @brief Flips an image in-place either vertically, horizontally, or both.
 * @details This is a destructive operation that directly modifies the pixel data of the provided `SituationImage`. The function uses optimized memory operations to perform the flip efficiently.
 *
 * @par Flip Modes
 *   - **`SIT_FLIP_VERTICAL`:** Flips the image top-to-bottom. The top row of pixels becomes the bottom row, and so on. This is commonly needed to correct the orientation of images read from GPU framebuffers (like with `glReadPixels`).
 *   - **`SIT_FLIP_HORIZONTAL`:** Flips the image left-to-right, creating a mirror image.
 *   - **`SIT_FLIP_BOTH`:** Performs both a vertical and a horizontal flip. This is equivalent to rotating the image by 180 degrees.
 *
 * @param[in,out] image A pointer to the `SituationImage` to be modified.
 * @param mode The `SituationImageFlipMode` enum specifying the type of flip to perform.
 */
SITAPI void SituationImageFlip(SituationImage *image, SituationImageFlipMode mode) {
    if (!image || !SituationIsImageValid(*image)) {
        // Added a check for the image pointer itself
        return;
    }

    // Use a switch to handle the different flip modes
    switch (mode) {
        case SIT_FLIP_VERTICAL: {
            // This is your original, optimized logic.
            int row_size = image->width * 4;
            unsigned char* row_buffer = (unsigned char*)malloc(row_size);
            if (!row_buffer) return;

            for (int y = 0; y < image->height / 2; ++y) {
                unsigned char* top_row = (unsigned char*)image->data + (y * row_size);
                unsigned char* bottom_row = (unsigned char*)image->data + ((image->height - 1 - y) * row_size);
                
                // Swap the entire rows
                memcpy(row_buffer, top_row, row_size);
                memcpy(top_row, bottom_row, row_size);
                memcpy(bottom_row, row_buffer, row_size);
            }
            free(row_buffer);
            break;
        }

        case SIT_FLIP_HORIZONTAL: {
            // For horizontal flip, we swap pixels within each row.
            const int pixel_size = 4; // RGBA
            unsigned char pixel_buffer[4]; // Buffer for a single pixel

            for (int y = 0; y < image->height; ++y) {
                // Get a pointer to the start of the current row
                unsigned char* row = (unsigned char*)image->data + (y * image->width * pixel_size);
                
                for (int x = 0; x < image->width / 2; ++x) {
                    unsigned char* left_pixel = row + (x * pixel_size);
                    unsigned char* right_pixel = row + ((image->width - 1 - x) * pixel_size);

                    // Swap the left and right pixels
                    memcpy(pixel_buffer, left_pixel, pixel_size);
                    memcpy(left_pixel, right_pixel, pixel_size);
                    memcpy(right_pixel, pixel_buffer, pixel_size);
                }
            }
            break;
        }

        case SIT_FLIP_BOTH: {
            // The simplest way to flip both is to perform one flip after the other.
            // This is equivalent to a 180-degree rotation.
            SituationImageFlip(image, SIT_FLIP_VERTICAL);
            SituationImageFlip(image, SIT_FLIP_HORIZONTAL);
            break;
        }
    }
}

/**
 * @brief Converts a color from the standard RGBA color space to the HSV (Hue, Saturation, Value) color space.
 * @details This function transforms a color from its red, green, and blue components into a more intuitive cylindrical-coordinate representation. This is extremely useful for programmatic color manipulation, such as shifting hues, desaturating, or brightening/darkening colors.
 *
 * @par Color Space Details
 *   - **Hue (H):** Represents the pure color (e.g., red, yellow, green). It is returned as an angle from `0.0f` to `360.0f` degrees.
 *   - **Saturation (S):** Represents the intensity or purity of the color. It ranges from `0.0f` (grayscale/achromatic) to `1.0f` (fully saturated, pure color).
 *   - **Value (V):** Represents the brightness of the color. It ranges from `0.0f` (black) to `1.0f` (full brightness).
 *
 * @param rgb The source `ColorRGBA` struct to convert. The alpha component is ignored.
 * @return A `ColorHSV` struct containing the equivalent H, S, and V values.
 *
 * @note The alpha component of the input `ColorRGBA` is not used in this conversion.
 *
 * @see SituationHsvToRgb(), SituationImageAdjustHSV()
 */
SITAPI ColorHSV SituationRgbToHsv(ColorRGBA rgb) {
    ColorHSV hsv;
    float r = rgb.r / 255.0f;
    float g = rgb.g / 255.0f;
    float b = rgb.b / 255.0f;
    float max = _SituationFMax3(r, g, b);
    float min = _SituationFMin3(r, g, b);
    float delta = max - min;
    hsv.v = max; // Value is the max of the components
    if (max == 0.0f) {
        hsv.s = 0.0f; // Saturation
    } else {
        hsv.s = delta / max;
    }
    if (delta == 0.0f) {
        hsv.h = 0.0f; // Hue is undefined for grayscale, set to 0
    } else {
        if (max == r)      hsv.h = 60.0f * fmodf(((g - b) / delta), 6.0f);
        else if (max == g) hsv.h = 60.0f * (((b - r) / delta) + 2.0f);
        else if (max == b) hsv.h = 60.0f * (((r - g) / delta) + 4.0f);
    }    
    if (hsv.h < 0.0f) {
        hsv.h += 360.0f;
    }
    return hsv;
}

/**
 * @brief Converts a color from the HSV (Hue, Saturation, Value) color space back to the standard RGBA color space.
 * @details This is the inverse operation of `SituationRgbToHsv`. It transforms a color defined by its hue, saturation, and brightness back into its red, green, and blue components, which are required for display on a screen.
 *
 * @param hsv The source `ColorHSV` struct to convert.
 *            - `h` (Hue) is expected to be in the range [0.0, 360.0]. Values outside this range will be wrapped.
 *            - `s` (Saturation) and `v` (Value) are expected to be in the range [0.0, 1.0]. Values outside this range will be clamped.
 *
 * @return A `ColorRGBA` struct containing the equivalent R, G, and B values. The alpha component is always set to `255` (fully opaque).
 *
 * @see SituationRgbToHsv(), SituationImageAdjustHSV()
 */
SITAPI ColorRGBA SituationHsvToRgb(ColorHSV hsv) {
    ColorRGBA rgb;
    float c = hsv.v * hsv.s;
    float x = c * (1.0f - fabsf(fmodf(hsv.h / 60.0f, 2.0f) - 1.0f));
    float m = hsv.v - c;
    float r = 0, g = 0, b = 0;
    int sector = (int)(hsv.h / 60.0f) % 6;
    switch (sector) {
        case 0: r = c; g = x; b = 0; break;
        case 1: r = x; g = c; b = 0; break;
        case 2: r = 0; g = c; b = x; break;
        case 3: r = 0; g = x; b = c; break;
        case 4: r = x; g = 0; b = c; break;
        case 5: r = c; g = 0; b = x; break;
    }
    rgb.r = (unsigned char)((r + m) * 255.0f);
    rgb.g = (unsigned char)((g + m) * 255.0f);
    rgb.b = (unsigned char)((b + m) * 255.0f);
    rgb.a = 255; // Alpha is not part of HSV
    return rgb;
}


/**
 * @brief Converts a color from the YPQA (Luma, Phase, Quadrature, Alpha) color space back to the standard RGBA color space.
 * @details This is the inverse operation of `SituationColorToYPQ`. It reconstructs the red, green, and blue components from the color's brightness (Y) and its chroma information (P and Q), and preserves the alpha channel. The conversion uses the standard NTSC YIQ-to-RGB matrix.
 *
 * @param ypq_color The source `ColorYPQA` struct to convert.
 *
 * @return A `ColorRGBA` struct containing the equivalent R, G, B, and A values. The function includes clamping to ensure the resulting RGB values are within the valid [0-255] range, as certain YPQ combinations can represent out-of-gamut colors.
 *
 * @see SituationColorToYPQ()
 */
SITAPI ColorRGBA SituationColorFromYPQ(ColorYPQA ypq_color) {
    // 1. Map YPQ parameters to YIQ components based on 8-8-8 bit ranges

    // Y (Luminance): Scale 0-255 (8 bits) to 0.0-1.0
    double y_yiq = (double)ypq_color.y / 255.0;

    // P (Phase Angle): Scale 0-255 (8 bits) to 0 - 2*PI radians
    // P determines the direction (hue) on the I-Q plane
    double angle = ((double)ypq_color.p / 255.0) * 2.0 * M_PI;

    // Q (Amplitude/Saturation): Scale 0-255 (8 bits) to 0.0-1.0
    // Q determines the distance from the center (grayscale) point
    double amplitude = (double)ypq_color.q / 255.0;

    // Calculate I and Q based on angle and amplitude
    // These MAX values represent the theoretical maximum excursion of I and Q
    // for a YIQ signal within the valid RGB gamut
    const double MAX_I = 0.595715671472;
    const double MAX_Q = 0.522591049541;
    double i_yiq = amplitude * cos(angle) * MAX_I;
    double q_yiq = amplitude * sin(angle) * MAX_Q;

    // 2. Convert YIQ to linear RGB using standard NTSC matrix
    double r_lin = y_yiq + 0.95568806036115671171 * i_yiq + 0.62082467141531188082 * q_yiq;
    double g_lin = y_yiq - 0.27178838506206335708 * i_yiq - 0.64860590248778682744 * q_yiq;
    double b_lin = y_yiq - 1.1081773266826619523 * i_yiq + 1.7025019884020956631 * q_yiq;

    // 3. Clamp linear RGB values to the valid 0.0 - 1.0 range
    // This is crucial as the conversion can produce out-of-gamut values
    r_lin = fmax(0.0, fmin(1.0, r_lin));
    g_lin = fmax(0.0, fmin(1.0, g_lin));
    b_lin = fmax(0.0, fmin(1.0, b_lin));

    // 4. Optional Gamma Correction (currently disabled)
    /*
    const double display_gamma = 2.2; // Typical sRGB gamma
    const double display_gamma_inv = 1.0 / display_gamma;
    r_lin = pow(r_lin, display_gamma_inv);
    g_lin = pow(g_lin, display_gamma_inv);
    b_lin = pow(b_lin, display_gamma_inv);
    */

    // 5. Scale to 0-255 for uint8_t output and create Color struct
    // Add 0.5 before casting for proper rounding
    ColorRGBA result;
    result.r = (unsigned char)(r_lin * 255.0 + 0.5);
    result.g = (unsigned char)(g_lin * 255.0 + 0.5);
    result.b = (unsigned char)(b_lin * 255.0 + 0.5);
    result.a = ypq_color.a;
    
    // Preserve the original alpha value from the YPQ struct
    return result;
}

/**
 * @brief Converts a color from the standard RGBA color space to the YPQA (Luma, Phase, Quadrature, Alpha) color space.
 * @details This function transforms a color into a representation that separates brightness (luma) from color information (chroma). This is analogous to the YIQ color space used in NTSC television broadcasting. This separation is highly useful for effects that modify brightness independently of color, or for creating unique procedural color palettes.
 *
 * @par Color Space Details
 *   - **Y (Luma):** Represents the brightness or grayscale intensity of the color. Stored as an `unsigned char` [0-255].
 *   - **P (Phase):** Represents the hue of the color as an angle on the chroma plane. Stored as an `unsigned char` [0-255], mapping to a full 360-degree rotation.
 *   - **Q (Quadrature):** Represents the saturation or intensity of the color as the distance from the grayscale center on the chroma plane. Stored as an `unsigned char` [0-255].
 *   - **A (Alpha):** The original alpha channel is preserved directly.
 *
 * @param color The source `ColorRGBA` struct to convert.
 * @return A `ColorYPQA` struct containing the equivalent Y, P, Q, and A values.
 *
 * @see SituationColorFromYPQ()
 */
SITAPI ColorYPQA SituationColorToYPQ(ColorRGBA color) {
    // 1. Convert source RGBA (0-255) to normalized floating point (0.0-1.0).
    double r = (double)color.r / 255.0;
    double g = (double)color.g / 255.0;
    double b = (double)color.b / 255.0;
    
    // 2. Convert linear RGB to YIQ components using the standard NTSC matrix.
    double y_yiq = 0.299 * r + 0.587 * g + 0.114 * b;
    double i_yiq = 0.596 * r - 0.274 * g - 0.322 * b;
    double q_yiq = 0.211 * r - 0.523 * g + 0.312 * b;
    
    // 3. Convert Cartesian I,Q components to polar coordinates (angle, amplitude).
    const double MAX_I = 0.595715671472;
    const double MAX_Q = 0.522591049541;
        
    // Normalize I,Q by their maximum values
    double i_norm = i_yiq / MAX_I;
    double q_norm = q_yiq / MAX_Q;

    // Calculate amplitude (chroma/saturation)
    double amplitude = sqrt(i_norm * i_norm + q_norm * q_norm);
    amplitude = fmin(1.0, amplitude);

    // Calculate angle (phase/hue)
    double angle = atan2(q_norm, i_norm);
    if (angle < 0.0) {
        angle += 2.0 * M_PI;
    }
    
    // 4. Scale the normalized Y, P, Q values back to 8-bit [0-255] ranges.
    ColorYPQA result;
    result.y = (unsigned char)(y_yiq * 255.0 + 0.5);
    result.p = (unsigned char)((angle / (2.0 * M_PI)) * 255.0 + 0.5);
    result.q = (unsigned char)(amplitude * 255.0 + 0.5);
    result.a = color.a; // Preserve the original alpha channel.
    
    return result;
}

/**
 * @brief Adjusts the Hue, Saturation, and Value (Brightness) of an entire image in-place.
 * @details This function iterates through every pixel of an image, converts it to the HSV color space, applies the specified transformations, and converts it back to RGBA. This provides a powerful and intuitive way to perform color correction and grading on CPU-side images.
 *
 * @param[in,out] image A pointer to the `SituationImage` to be modified.
 * @param hue_shift The amount to shift the hue of every pixel, in degrees. This value is added to the existing hue, wrapping around the 360-degree color wheel (e.g., a shift of 30 will turn red into orange).
 * @param sat_factor A multiplier for the saturation of every pixel.
 *                   - `1.0f` = No change.
 *                   - `0.0f` = Fully desaturate the image (grayscale).
 *                   - `2.0f` = Double the saturation (more vivid colors).
 * @param val_factor A multiplier for the value (brightness) of every pixel.
 *                   - `1.0f` = No change.
 *                   - `0.5f` = Halve the brightness.
 *                   - `1.5f` = Increase brightness by 50%.
 * @param mix The blend factor between the original and the fully adjusted color, from `0.0f` (no change) to `1.0f` (fully adjusted). This allows you to fade the effect in or out.
 *
 * @note This is a destructive operation that modifies the image's pixel data directly.
 * @note The alpha channel of the image is preserved and not affected by this function.
 *
 * @see SituationRgbToHsv(), SituationHsvToRgb()
 */
SITAPI void SituationImageAdjustHSV(SituationImage *image, float hue_shift, float sat_factor, float val_factor, float mix) {
    if (!SituationIsImageValid(*image)) return;
    
    // Clamp mix factor to a safe range [0, 1]
    mix = fmaxf(0.0f, fminf(1.0f, mix));

    unsigned char* pixels = (unsigned char*)image->data;
    int pixel_count = image->width * image->height;

    for (int i = 0; i < pixel_count; ++i) {
        // Step 1: Get original pixel and convert to HSV
        ColorRGBA original_rgb = { pixels[i*4+0], pixels[i*4+1], pixels[i*4+2], pixels[i*4+3] };
        ColorHSV hsv = SituationRgbToHsv(original_rgb);

        // Step 2: Apply adjustments to H, S, V
        // Adjust Hue (wraps around 360 degrees)
        hsv.h = fmodf(hsv.h + hue_shift, 360.0f);
        if (hsv.h < 0.0f) hsv.h += 360.0f;

        // Adjust Saturation and Value (multiplicative)
        hsv.s *= sat_factor;
        hsv.v *= val_factor;

        // Clamp S and V to the valid [0, 1] range
        hsv.s = fmaxf(0.0f, fminf(1.0f, hsv.s));
        hsv.v = fmaxf(0.0f, fminf(1.0f, hsv.v));

        // Step 3: Convert the adjusted HSV back to RGB
        ColorRGBA adjusted_rgb = SituationHsvToRgb(hsv);

        // Step 4: Linearly interpolate (mix) between original and adjusted color
        pixels[i*4 + 0] = (unsigned char)((float)original_rgb.r * (1.0f - mix) + (float)adjusted_rgb.r * mix);
        pixels[i*4 + 1] = (unsigned char)((float)original_rgb.g * (1.0f - mix) + (float)adjusted_rgb.g * mix);
        pixels[i*4 + 2] = (unsigned char)((float)original_rgb.b * (1.0f - mix) + (float)adjusted_rgb.b * mix);
        // Alpha channel is preserved from the original
        pixels[i*4 + 3] = original_rgb.a;
    }
}

/**
 * @brief Loads a TrueType (.ttf) or OpenType (.otf) font file from disk for CPU-side rendering.
 * @details This function reads the entire font file into a memory buffer and initializes an `stb_truetype` context for it. The resulting `SituationFont` handle is a CPU-side resource used by the `SituationImageDraw*` text rendering functions.
 *
 * @par Memory Management
 *   The function allocates two separate blocks of memory that are stored within the returned `SituationFont` struct: one for the raw font file data and another for the `stbtt_fontinfo` context. This memory is held for the lifetime of the font and **must** be released by calling `SituationUnloadFont`.
 *
 * @param fileName The file system path to the font file (e.g., "assets/fonts/myfont.ttf").
 *
 * @return A `SituationFont` handle containing the necessary data for text rendering.
 * @return A zeroed (invalid) `SituationFont` struct if the file cannot be found, if memory allocation fails, or if the file is not a valid font. An error message will be set internally.
 *
 * @note This function is for CPU-side text rendering onto `SituationImage` objects. It is distinct from any GPU-based font atlas creation that might be used for high-performance in-game text.
 * @warning Failure to call `SituationUnloadFont` on a successfully loaded font will result in a memory leak.
 *
 * @see SituationUnloadFont(), SituationImageDrawText(), SituationMeasureText()
 */
SITAPI SituationFont SituationLoadFont(const char *fileName) {
    SituationFont font = {0};
    long size = 0;
    FILE *fontFile = fopen(fileName, "rb");

    if (!fontFile) {
        // You should have some logging here
        return font;
    }

    fseek(fontFile, 0, SEEK_END);
    size = ftell(fontFile);
    fseek(fontFile, 0, SEEK_SET);

    // 1. Load the entire font file into a buffer.
    // We must keep this buffer alive as long as we use the font.
    unsigned char *fontBuffer = (unsigned char*)malloc(size);
    if (!fontBuffer) {
        fclose(fontFile);
        return font;
    }
    
    fread(fontBuffer, 1, size, fontFile);
    fclose(fontFile);

    // 2. Allocate and initialize the stbtt_fontinfo struct.
    stbtt_fontinfo *info = (stbtt_fontinfo*)malloc(sizeof(stbtt_fontinfo));
    if (!info) {
        free(fontBuffer);
        return font;
    }

    // 3. Initialize stb_truetype with our buffer.
    if (!stbtt_InitFont(info, fontBuffer, 0)) {
        // The font file is invalid or not a TrueType font.
        free(info);
        free(fontBuffer);
        return font;
    }

    font.fontData = fontBuffer;
    font.stbFontInfo = info;
    return font;
}

/**
 * @brief Frees all CPU memory associated with a loaded `SituationFont`.
 * @details This is the designated cleanup function for a `SituationFont` handle created by `SituationLoadFont`. It safely frees both the raw font file data buffer and the `stbtt_fontinfo` context struct.
 *
 * @param font The `SituationFont` handle to unload. The pointers within the struct become invalid after this call.
 *
 * @note It is safe to call this function on a zeroed or partially loaded `SituationFont` struct; it will only attempt to free non-NULL pointers.
 *
 * @see SituationLoadFont()
 */
SITAPI void SituationUnloadFont(SituationFont font) {
    if (font.stbFontInfo) free(font.stbFontInfo);
    if (font.fontData) free(font.fontData);
}

/**
 * @brief [INTERNAL] Saves a `SituationImage` to a file in the uncompressed 24/32-bit BMP format.
 * @details This is a low-level, self-contained utility for writing bitmap files. It manually constructs the necessary BMP file and info headers, converts the image's in-memory RGBA pixel data to the BGRA format required by the BMP standard, and writes the complete file to disk using `SituationSaveFileData`.
 *          This function serves as a native, dependency-free fallback for image exporting when more advanced libraries like `stb_image_write.h` are not available for PNG encoding.
 *
 * @param fileName The destination file path for the `.bmp` file.
 * @param image A pointer to the `SituationImage` containing the pixel data to be saved.
 *
 * @return `true` if the BMP file was successfully written to disk.
 * @return `false` if any step fails (e.g., invalid parameters, memory allocation for the file buffer fails, or the final file write operation fails). An error message is set on failure.
 *
 * @note This function is for internal use by `SituationExportImage` and `SituationTakeScreenshot`. It should not be called directly.
 * @note The function does not perform vertical flipping; it assumes the input image data has the correct orientation (origin at the top-left).
 *
 * @see SituationExportImage(), SituationTakeScreenshot(), SituationSaveFileData()
 */
static bool _SituationSaveImageBMP(const char* fileName, const SituationImage* image) {
    if (!fileName || !image || !image->data) return false;

    int imageSize = image->width * image->height * 4;
    // BMP file format requires headers
    int fileSize = 54 + imageSize; // 54 bytes for headers

    // BMP File Header (14 bytes)
    char fileHeader[14] = {
        'B', 'M',           // Signature
        0, 0, 0, 0,         // File size in bytes
        0, 0, 0, 0,         // Reserved
        54, 0, 0, 0         // Offset to pixel data
    };
    // BMP Info Header (40 bytes)
    char infoHeader[40] = {
        40, 0, 0, 0,        // Header size
        0, 0, 0, 0,         // Image width
        0, 0, 0, 0,         // Image height
        1, 0,               // Number of color planes
        32, 0,              // Bits per pixel (RGBA = 32)
        0, 0, 0, 0,         // Compression method (0=BI_RGB)
        0, 0, 0, 0,         // Image size (can be 0 for BI_RGB)
        0, 0, 0, 0,         // Horizontal resolution (pixels per meter)
        0, 0, 0, 0,         // Vertical resolution
        0, 0, 0, 0,         // Number of colors in palette (0 for 32-bit)
        0, 0, 0, 0,         // Number of important colors (0 = all)
    };

    // Fill in the dynamic header fields
    fileHeader[2] = (char)(fileSize);
    fileHeader[3] = (char)(fileSize >> 8);
    fileHeader[4] = (char)(fileSize >> 16);
    fileHeader[5] = (char)(fileSize >> 24);

    infoHeader[4] = (char)(image->width);
    infoHeader[5] = (char)(image->width >> 8);
    infoHeader[6] = (char)(image->width >> 16);
    infoHeader[7] = (char)(image->width >> 24);
    infoHeader[8] = (char)(image->height);
    infoHeader[9] = (char)(image->height >> 8);
    infoHeader[10] = (char)(image->height >> 16);
    infoHeader[11] = (char)(image->height >> 24);

    // Create a single buffer for the entire file
    unsigned char *fileBuffer = (unsigned char *)malloc(fileSize);
    if (!fileBuffer) {
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "BMP file buffer");
        return false;
    }

    memcpy(fileBuffer, fileHeader, 14);
    memcpy(fileBuffer + 14, infoHeader, 40);

    // Copy pixel data, converting RGBA to BGRA as required by BMP
    for (int y = 0; y < image->height; y++) {
        for (int x = 0; x < image->width; x++) {
            int i = (y * image->width + x) * 4;
            int out_i = 54 + i;
            unsigned char* pixel = (unsigned char*)image.data + i;
            fileBuffer[out_i + 0] = pixel[2]; // Blue
            fileBuffer[out_i + 1] = pixel[1]; // Green
            fileBuffer[out_i + 2] = pixel[0]; // Red
            fileBuffer[out_i + 3] = pixel[3]; // Alpha
        }
    }

    // Save the buffer to disk using our existing library function
    bool success = SituationSaveFileData(fileName, fileBuffer, fileSize);
    free(fileBuffer);

    if (!success) {
        _SituationSetFilesystemError("Failed to save BMP file data to disk", fileName);
    }
    return success;
}

/**
 * @brief [INTERNAL] Blends a source color onto a destination color using standard alpha blending.
 * @details This helper function implements the "Normal" blend mode (`SRC over DST`). It calculates the final color by interpolating between the source and destination based on the source's alpha channel, which is modulated by an additional blend factor.
 *
 * @par Blending Formula
 *   - `FinalColor.rgb = Src.rgb * BlendAlpha + Dst.rgb * (1 - BlendAlpha)`
 *   - `FinalColor.a   = Dst.a + Src.a * BlendAlpha` (approximated for additive alpha)
 *   - where `BlendAlpha = (Src.a / 255.0) * alpha`
 *
 * This function is used by the CPU-side image drawing routines to composite pixels with transparency.
 *
 * @param dst The destination color that will be drawn onto.
 * @param src The source color to blend.
 * @param alpha An additional blend factor (0.0f to 1.0f) to modulate the source's alpha.
 *
 * @return The resulting `ColorRGBA` struct after blending.
 *
 * @note This function is for internal use by the `SituationImageDraw*` functions.
 */
static inline ColorRGBA _SituationColorAlphaBlend(ColorRGBA dst, ColorRGBA src, float alpha) {
    if (alpha <= 0.0f) return dst;
    if (alpha >= 1.0f) return (ColorRGBA){src.r, src.g, src.b, (unsigned char)_SituationClampf((float)dst.a + src.a, 0, 255)};

    float srcA = (float)src.a / 255.0f;
    float blendAlpha = srcA * alpha;

    ColorRGBA result;
    result.r = (unsigned char)((float)src.r * blendAlpha + (float)dst.r * (1.0f - blendAlpha));
    result.g = (unsigned char)((float)src.g * blendAlpha + (float)dst.g * (1.0f - blendAlpha));
    result.b = (unsigned char)((float)src.b * blendAlpha + (float)dst.b * (1.0f - blendAlpha));
    // The final alpha is a bit more complex, we want to add the new shape's alpha to the existing alpha
    result.a = (unsigned char)_SituationClampf((float)dst.a + ((float)src.a * alpha), 0, 255);
    
    return result;
}

/**
 * @brief Draws a portion of a source image onto a destination image with alpha blending and tinting.
 * @details This function composites a rectangular region from a source image onto a destination image, respecting the alpha channel of both the source pixels and the provided `tint` color. This is the primary function for drawing sprites or UI elements with transparency.
 *
 * @par Blending Formula
 *   The function uses a standard "Normal" blend mode (SRC over DST). The final color is calculated pixel by pixel:
 *   - `FinalColor.rgb = TintedSrc.rgb * FinalAlpha + Dst.rgb * (1 - FinalAlpha)`
 *   - `TintedSrc.rgb = (Src.rgb / 255) * (Tint.rgb / 255)`
 *   - `FinalAlpha = (Src.a / 255) * (Tint.a / 255)`
 *
 * @par Boundary Handling
 *   Like `SituationImageDraw`, this function is robust against invalid coordinates and will only draw the overlapping area between the source and destination rectangles, preventing out-of-bounds memory access.
 *
 * @param[in,out] dst A pointer to the destination `SituationImage` to be modified.
 * @param src The source `SituationImage` to draw from.
 * @param srcRect The rectangular region within the source image to use.
 * @param dstPos The top-left `(x, y)` position on the destination image where drawing should start.
 * @param tint The color to modulate the source image with as it's drawn. White `{255,255,255,255}` results in no color change.
 *
 * @see SituationImageDraw()
 */
SITAPI void SituationImageDrawAlpha(SituationImage *dst, SituationImage src, Rectangle srcRect, Vector2 dstPos, ColorRGBA tint) {
    // 1. --- Validation and Intersection Calculation ---
    // (This is the same robust boundary-checking logic from our previous `SituationImageDraw` discussion)
    if (!SituationIsImageValid(*dst) || !SituationIsImageValid(src)) return;

    int srcClipX = (srcRect.x < 0) ? 0 : srcRect.x;
    int srcClipY = (srcRect.y < 0) ? 0 : srcRect.y;
    int srcClipW = (srcRect.x + srcRect.width > src.width) ? (src.width - srcRect.x) : srcRect.width;
    int srcClipH = (srcRect.y + srcRect.height > src.height) ? (src.height - srcRect.y) : srcRect.height;

    int dstClipX = (int)dstPos.x + (srcClipX - srcRect.x);
    int dstClipY = (int)dstPos.y + (srcClipY - srcRect.y);
    
    if (dstClipX < 0) { srcClipW += dstClipX; srcClipX -= dstClipX; dstClipX = 0; }
    if (dstClipY < 0) { srcClipH += dstClipY; srcClipY -= dstClipY; dstClipY = 0; }
    if (dstClipX + srcClipW > dst->width)  { srcClipW = dst->width - dstClipX; }
    if (dstClipY + srcClipH > dst->height) { srcClipH = dst->height - dstClipY; }

    if (srcClipW <= 0 || srcClipH <= 0) return;

    // 2. --- Pixel-by-Pixel Blending Loop ---
    unsigned char *srcPixels = (unsigned char*)src.data;
    unsigned char *dstPixels = (unsigned char*)dst->data;
    const int pixelSize = 4;

    for (int y = 0; y < srcClipH; ++y) {
        for (int x = 0; x < srcClipW; ++x) {
            // Get pointers to the source and destination pixels for this iteration
            unsigned char* srcPixel = srcPixels + (((size_t)srcClipY + y) * src.width + ((size_t)srcClipX + x)) * pixelSize;
            unsigned char* dstPixel = dstPixels + (((size_t)dstClipY + y) * dst->width + ((size_t)dstClipX + x)) * pixelSize;

            // Get the source alpha. This is the key component.
            // We also factor in the tint's alpha.
            unsigned int srcAlpha = ((unsigned int)srcPixel[3] * (unsigned int)tint.a) / 255;
            
            if (srcAlpha == 0) continue; // Source pixel is fully transparent, do nothing.

            // Apply the tint to the source RGB channels
            unsigned int srcR = ((unsigned int)srcPixel[0] * (unsigned int)tint.r) / 255;
            unsigned int srcG = ((unsigned int)srcPixel[1] * (unsigned int)tint.g) / 255;
            unsigned int srcB = ((unsigned int)srcPixel[2] * (unsigned int)tint.b) / 255;

            if (srcAlpha == 255) {
                // Opaque: a simple overwrite is fastest
                dstPixel[0] = (unsigned char)srcR;
                dstPixel[1] = (unsigned char)srcG;
                dstPixel[2] = (unsigned char)srcB;
                dstPixel[3] = (unsigned char)srcAlpha; // Or just 255
            } else {
                // Standard alpha blending (SRC over DST)
                float alphaFactor = (float)srcAlpha / 255.0f;
                float oneMinusAlpha = 1.0f - alphaFactor;

                dstPixel[0] = (unsigned char)((float)srcR * alphaFactor + (float)dstPixel[0] * oneMinusAlpha);
                dstPixel[1] = (unsigned char)((float)srcG * alphaFactor + (float)dstPixel[1] * oneMinusAlpha);
                dstPixel[2] = (unsigned char)((float)srcB * alphaFactor + (float)dstPixel[2] * oneMinusAlpha);
                dstPixel[3] = (unsigned char)((float)srcAlpha + (float)dstPixel[3] * oneMinusAlpha); // Blend destination alpha too
            }
        }
    }
}

/**
 * @brief [INTERNAL] Samples a pixel value from a single-channel bitmap using bilinear filtering.
 * @details This helper function retrieves a color value from a bitmap at a floating-point coordinate. Instead of simply picking the nearest pixel (point sampling), it interpolates between the four nearest pixels to produce a smoother, higher-quality result.
 *          This is essential for rendering transformed text or images where the source pixels do not map perfectly one-to-one with the destination pixels, as it reduces aliasing and "jaggies".
 *
 * @param bitmap A pointer to the raw, single-channel (e.g., alpha-only) bitmap data.
 * @param width The width of the bitmap in pixels.
 * @param height The height of the bitmap in pixels.
 * @param u The horizontal (X) coordinate to sample from.
 * @param v The vertical (Y) coordinate to sample from.
 *
 * @return The interpolated `unsigned char` value (0-255) at the specified coordinates.
 *
 * @note The function clamps the U/V coordinates to be safely within the bitmap's bounds to prevent out-of-bounds memory access.
 * @note This function is for internal use, primarily by the advanced text rendering path (`SituationImageDrawCodepoint`) for sampling the Signed Distance Field bitmap.
 */
static unsigned char _SituationBilinearSample(const unsigned char *bitmap, int width, int height, float u, float v) {
    // Clamp coordinates to be within the bitmap
    u = _SituationClampf(u, 0.0f, (float)width - 1.001f);
    v = _SituationClampf(v, 0.0f, (float)height - 1.001f);

    int x = (int)u;
    int y = (int)v;
    float u_ratio = u - x;
    float v_ratio = v - y;
    float u_opposite = 1.0f - u_ratio;
    float v_opposite = 1.0f - v_ratio;

    unsigned char c11 = bitmap[y * width + x];
    unsigned char c12 = bitmap[y * width + x + 1];
    unsigned char c21 = bitmap[(y + 1) * width + x];
    unsigned char c22 = bitmap[(y + 1) * width + x + 1];

    float result = (c11 * u_opposite + c12 * u_ratio) * v_opposite + (c21 * u_opposite + c22 * u_ratio) * v_ratio;

    return (unsigned char)result;
}

/**
 * @brief Draws a single character (codepoint) onto a SituationImage with advanced styling.
 * @details This is a powerful, low-level function for high-quality text rendering. It can render a single character with fill, outline, rotation, and horizontal skew.
 *
 * @par Rendering Method
 *   - **With Outline:** Uses a high-quality Signed Distance Field (SDF) method to render smooth, scalable outlines of a precise thickness.
 *   - **Without Outline:** Uses a simpler, faster anti-aliased bitmap rendering path.
 *   - **With Transformations:** For rotation or skew, it uses an inverse mapping algorithm with bilinear filtering to sample the glyph, ensuring smooth, high-quality results without aliasing ("jaggies").
 *
 * @param[in,out] dst A pointer to the destination `SituationImage` to draw on.
 * @param font The `SituationFont` to use for rendering.
 * @param codepoint The Unicode codepoint of the character to draw.
 * @param position The top-left position for the character's baseline.
 * @param fontSize The desired font size in pixels.
 * @param rotationDegrees The rotation of the character in degrees, pivoting around its baseline start. Positive values rotate counter-clockwise.
 * @param skewFactor A factor for horizontal shearing. `0.0` is no skew. `0.5` will skew the top of the character 50% of its height to the right.
 * @param fillColor The color for the character's interior.
 * @param outlineColor The color for the character's outline.
 * @param outlineThickness The thickness of the outline in pixels. A value of `0.0f` or less disables the outline and uses the faster non-SDF rendering path.
 *
 * @note This function is the building block for `SituationImageDrawTextEx`. It is generally more convenient to use the higher-level functions unless you need to control the placement and rendering of each character individually.
 *
 * @see SituationImageDrawTextEx()
 */
SITAPI void SituationImageDrawCodepoint(SituationImage *dst, SituationFont font, int codepoint, Vector2 position, float fontSize, float rotationDegrees, float skewFactor, ColorRGBA fillColor, ColorRGBA outlineColor, float outlineThickness) {
    if (!SituationIsImageValid(*dst) || !font.stbFontInfo) return;

    // --- Common Setup (Refined to reduce duplication) ---
    stbtt_fontinfo *info = (stbtt_fontinfo*)font.stbFontInfo;
    float scale = stbtt_ScaleForPixelHeight(info, fontSize);
    int ascent, descent;
    stbtt_GetFontVMetrics(info, &ascent, &descent, NULL);
    int baseline = (int)(ascent * scale);

    // --- Path 1: Optimized for non-transformed characters ---
    if (rotationDegrees == 0.0f && skewFactor == 0.0f) {
        // --- Sub-Path 1.1: Simple bitmap rendering (no outline) ---
        if (outlineThickness <= 0) {
            int g_x0, g_y0, g_x1, g_y1;
            stbtt_GetCodepointBitmapBox(info, codepoint, scale, scale, &g_x0, &g_y0, &g_x1, &g_y1);
            int glyph_w = g_x1 - g_x0;
            int glyph_h = g_y1 - g_y0;
            if (glyph_w > 0 && glyph_h > 0) {
                unsigned char *glyphBitmap = (unsigned char*)calloc(glyph_w * glyph_h, sizeof(unsigned char));
                if (!glyphBitmap) return;
                stbtt_MakeCodepointBitmap(info, glyphBitmap, glyph_w, glyph_h, glyph_w, scale, scale, codepoint);
                for (int y = 0; y < glyph_h; ++y) {
                    for (int x = 0; x < glyph_w; ++x) {
                        int dx = (int)position.x + g_x0 + x;
                        int dy = (int)position.y + baseline + g_y0 + y;
                        if (dx >= 0 && dx < dst->width && dy >= 0 && dy < dst->height) {
                            unsigned char alpha = glyphBitmap[y * glyph_w + x];
                            if (alpha > 0) {
                                ColorRGBA *dstPixel = &((ColorRGBA *)dst->data)[dy * dst->width + dx];
                                *dstPixel = _SituationColorAlphaBlend(*dstPixel, fillColor, (float)alpha / 255.0f);
                            }
                        }
                    }
                }
                free(glyphBitmap);
            }
        }
        // --- Sub-Path 1.2: SDF rendering (with outline) ---
        else {
            const int padding = (int)outlineThickness + 2;
            const unsigned char onedge_value = 180;
            const float pixel_dist_scale = (float)onedge_value / (float)padding;
            int g_x0, g_y0, g_x1, g_y1;
            stbtt_GetCodepointSDF(info, scale, codepoint, padding, onedge_value, pixel_dist_scale, &g_x0, &g_y0, &g_x1, &g_y1);
            int glyph_w = g_x1 - g_x0;
            int glyph_h = g_y1 - g_y0;
            if (glyph_w > 0 && glyph_h > 0) {
                unsigned char *sdfBitmap = (unsigned char*)calloc(glyph_w * glyph_h, sizeof(unsigned char));
                if (!sdfBitmap) return;
                stbtt_MakeCodepointSDF(info, sdfBitmap, glyph_w, glyph_h, glyph_w, scale, codepoint, padding, onedge_value, pixel_dist_scale);
                float fill_thresh_inner = onedge_value - 1.0f, fill_thresh_outer = onedge_value + 1.0f;
                float outline_thresh_inner = onedge_value - (outlineThickness * pixel_dist_scale) - 1.0f;
                float outline_thresh_outer = onedge_value - (outlineThickness * pixel_dist_scale) + 1.0f;
                for (int y = 0; y < glyph_h; ++y) {
                    for (int x = 0; x < glyph_w; ++x) {
                        int dx = (int)position.x + g_x0 + x;
                        int dy = (int)position.y + baseline + g_y0 + y;
                        if (dx >= 0 && dx < dst->width && dy >= 0 && dy < dst->height) {
                            float dist = (float)sdfBitmap[y * glyph_w + x];
                            float alpha_fill = _SituationClampf((dist - fill_thresh_inner) / (fill_thresh_outer - fill_thresh_inner), 0.0f, 1.0f);
                            float alpha_outline = 1.0f - _SituationClampf((dist - outline_thresh_inner) / (outline_thresh_outer - outline_thresh_inner), 0.0f, 1.0f);
                            if (alpha_fill > 0 || alpha_outline > 0) {
                                ColorRGBA *dstPixel = &((ColorRGBA *)dst->data)[dy * dst->width + dx];
                                if (alpha_outline > 0) *dstPixel = _SituationColorAlphaBlend(*dstPixel, outlineColor, alpha_outline);
                                if (alpha_fill > 0) *dstPixel = _SituationColorAlphaBlend(*dstPixel, fillColor, alpha_fill);
                            }
                        }
                    }
                    free(sdfBitmap);
                }
            }
        }
        return; // End of fast path
    }

    // --- Path 2: Inverse mapping for rotation and skew ---
    // (This part of the code was already well-structured and bug-free)
    const int padding = (int)fmaxf(outlineThickness + 5.0f, 5.0f);
    const unsigned char onedge_value = 180;
    const float pixel_dist_scale = (float)onedge_value / (float)padding;
    int g_x0, g_y0, g_x1, g_y1;
    stbtt_GetCodepointSDF(info, scale, codepoint, padding, onedge_value, pixel_dist_scale, &g_x0, &g_y0, &g_x1, &g_y1);
    int glyph_w = g_x1 - g_x0;
    int glyph_h = g_y1 - g_y0;
    if (glyph_w <= 0 || glyph_h <= 0) return;
    
    unsigned char *sdfBitmap = (unsigned char*)calloc(glyph_w * glyph_h, sizeof(unsigned char));
    if (!sdfBitmap) return;
    stbtt_MakeCodepointSDF(info, sdfBitmap, glyph_w, glyph_h, glyph_w, scale, codepoint, padding, onedge_value, pixel_dist_scale);

    float angleRad = rotationDegrees * (M_PI / 180.0f);
    float cos_a = cosf(angleRad), sin_a = sinf(angleRad);
    Vector2 pivot = { position.x, position.y + baseline };
    
    mat2 invTransform;
    float det = cos_a - sin_a * skewFactor;
    if (fabsf(det) < 1e-6) { free(sdfBitmap); return; }
    float inv_det = 1.0f / det;
    invTransform[0][0] = 1.0f * inv_det;
    invTransform[0][1] = sin_a * inv_det;
    invTransform[1][0] = -skewFactor * inv_det;
    invTransform[1][1] = cos_a * inv_det;

    vec2 corners[4] = { {(float)g_x0, (float)g_y0}, {(float)g_x0 + glyph_w, (float)g_y0}, {(float)g_x0, (float)g_y0 + glyph_h}, {(float)g_x0 + glyph_w, (float)g_y0 + glyph_h} };
    float min_x = FLT_MAX, min_y = FLT_MAX, max_x = -FLT_MAX, max_y = -FLT_MAX;
    for (int i = 0; i < 4; i++) {
        float tx = corners[i][0] * cos_a - corners[i][1] * sin_a + corners[i][0] * skewFactor;
        float ty = corners[i][0] * sin_a + corners[i][1] * cos_a;
        min_x = fminf(min_x, tx); max_x = fmaxf(max_x, tx);
        min_y = fminf(min_y, ty); max_y = fmaxf(max_y, ty);
    }
    
    int startX = (int)floorf(pivot.x + min_x), endX = (int)ceilf(pivot.x + max_x);
    int startY = (int)floorf(pivot.y + min_y), endY = (int)ceilf(pivot.y + max_y);

    float fill_thresh_inner = onedge_value - 1.0f, fill_thresh_outer = onedge_value + 1.0f;
    float outline_thresh_inner = onedge_value - (outlineThickness * pixel_dist_scale) - 1.0f;
    float outline_thresh_outer = onedge_value - (outlineThickness * pixel_dist_scale) + 1.0f;

    for (int y = startY; y < endY; ++y) {
        for (int x = startX; x < endX; ++x) {
            if (x < 0 || x >= dst->width || y < 0 || y >= dst->height) continue;
            vec2 dst_p = {(float)x - pivot.x, (float)y - pivot.y};
            vec2 src_p;
            cglm_mat2_mulv(invTransform, dst_p, src_p);
            float src_x = src_p[0] - g_x0, src_y = src_p[1] - g_y0;
            if (src_x < -1 || src_x > glyph_w || src_y < -1 || src_y > glyph_h) continue;
            
            float dist = (float)_SituationBilinearSample(sdfBitmap, glyph_w, glyph_h, src_x, src_y);
            float alpha_fill = _SituationClampf((dist - fill_thresh_inner) / (fill_thresh_outer - fill_thresh_inner), 0.0f, 1.0f);
            float alpha_outline = 1.0f - _SituationClampf((dist - outline_thresh_inner) / (outline_thresh_outer - outline_thresh_inner), 0.0f, 1.0f);
            
            if (alpha_fill > 0 || alpha_outline > 0) {
                ColorRGBA *dstPixel = &((ColorRGBA *)dst->data)[y * dst->width + x];
                if (outlineThickness > 0 && alpha_outline > 0) *dstPixel = _SituationColorAlphaBlend(*dstPixel, outlineColor, alpha_outline);
                if (alpha_fill > 0) *dstPixel = _SituationColorAlphaBlend(*dstPixel, fillColor, alpha_fill);
            }
        }
    }
    free(sdfBitmap);
}

/**
 * @brief Draws a string of text onto an image with advanced options for styling and transformation.
 * @details This is the recommended function for all stylistic text rendering. It orchestrates calls to the internal `SituationImageDrawCodepoint` function to render each character of a string, correctly handling kerning and character spacing along the transformed baseline.
 *
 * @par Rendering Method
 *   This function uses a Signed Distance Field (SDF) rendering path via `SituationImageDrawCodepoint` to achieve high-quality, anti-aliased outlines and smooth rendering, even when rotated or skewed. For non-rotated text without an outline, it uses a faster, optimized path.
 *
 * @param[in,out] dst The destination image to draw on.
 * @param font The `SituationFont` to use for rendering.
 * @param text The null-terminated string to draw.
 * @param position The top-left anchor position for the text. Transformations pivot around this point.
 * @param fontSize The desired font size in pixels.
 * @param spacing Additional spacing between characters in pixels, applied along the text's baseline.
 * @param rotationDegrees The rotation of the entire text block in degrees. `0` is no rotation. Positive values rotate counter-clockwise.
 * @param skewFactor A factor for horizontal shearing applied to each character. `0.0` is no skew.
 * @param fillColor The color for the characters' interior.
 * @param outlineColor The color for the characters' outline.
 * @param outlineThickness The thickness of the outline in pixels. A value of `0.0f` or less disables the outline.
 *
 * @see SituationImageDrawText(), SituationImageDrawCodepoint(), SituationMeasureText()
 */
SITAPI void SituationImageDrawTextEx(SituationImage *dst, SituationFont font, const char *text, Vector2 position, float fontSize, float spacing, float rotationDegrees, float skewFactor, ColorRGBA fillColor, ColorRGBA outlineColor, float outlineThickness) {
    if (!SituationIsImageValid(*dst) || !font.stbFontInfo || !text) return;

    stbtt_fontinfo *info = (stbtt_fontinfo*)font.stbFontInfo;
    float scale = stbtt_ScaleForPixelHeight(info, fontSize);

    // --- Optimization: Use a faster path for the common, non-rotated case ---
    if (rotationDegrees == 0.0f) {
        float x = position.x;
        for (int i = 0; text[i]; ++i) {
            int codepoint = text[i];
            
            if (i > 0) {
                x += stbtt_GetCodepointKernAdvance(info, text[i-1], codepoint) * scale;
            }

            // Draw the character using our powerful function, but at its simple position
            Vector2 charPos = { x, position.y };
            SituationImageDrawCodepoint(dst, font, codepoint, charPos, fontSize, 0.0f, skewFactor, fillColor, outlineColor, outlineThickness);

            // Advance the simple horizontal cursor
            int advanceWidth;
            stbtt_GetCodepointHMetrics(info, codepoint, &advanceWidth, NULL);
            x += ((float)advanceWidth * scale) + spacing;
        }
        return;
    }

    // --- Transformation Path: Use vector math to handle rotated layout ---
    Vector2 cursor = position;
    float angleRad = rotationDegrees * (M_PI / 180.0f);
    float cos_a = cosf(angleRad);
    float sin_a = sinf(angleRad);

    for (int i = 0; text[i]; ++i) {
        int codepoint = text[i];

        // Handle kerning along the rotated baseline
        if (i > 0) {
            float kern = stbtt_GetCodepointKernAdvance(info, text[i-1], codepoint) * scale;
            // The kerning is a horizontal vector that we must rotate
            cursor.x += kern * cos_a;
            cursor.y += kern * sin_a;
        }

        // Draw the current character at the cursor's position, applying all transforms
        SituationImageDrawCodepoint(dst, font, codepoint, cursor, fontSize, rotationDegrees, skewFactor, fillColor, outlineColor, outlineThickness);

        // Advance the cursor along the rotated baseline for the next character
        int advanceWidth;
        stbtt_GetCodepointHMetrics(info, codepoint, &advanceWidth, NULL);
        float totalAdvance = ((float)advanceWidth * scale) + spacing;
        
        // The advance is a horizontal vector that we must rotate
        cursor.x += totalAdvance * cos_a;
        cursor.y += totalAdvance * sin_a;
    }
}

/**
 * @brief Draws simple, tinted text onto an image using a basic bitmap-compositing approach.
 * @details This function serves as the classic, straightforward method for rendering text. For each character in the input string, it performs the following steps:
 *          1. Generates a 1-channel (alpha-only) bitmap of the character using stb_truetype.
 *          2. Creates a temporary 4-channel (RGBA) `SituationImage` in memory to hold the glyph.
 *          3. Copies the 1-channel bitmap into the alpha channel of the temporary image.
 *          4. Calls the general-purpose `SituationImageDrawAlpha` function to composite this temporary glyph image onto the destination, applying the requested tint color.
 *          5. Frees the memory for the temporary glyph image.
 * @section Relationship to SituationImageDrawTextEx
 *   This function is **intentionally separate** from `SituationImageDrawTextEx` and does not call it.
 *   They use fundamentally different rendering techniques for different use cases:
 *   - **SituationImageDrawText (this function):** Uses `stbtt_MakeCodepointBitmap`. It is optimized for simplicity and is perfect for rendering basic, aliased, solid-color text. It cannot produce outlines.
 *   - **SituationImageDrawTextEx:** Uses a more complex Signed Distance Field (SDF) rendering path via the internal `SituationImageDrawCodepoint` function. This path is required to render high-quality, anti-aliased outlines of a specified thickness, but has a slightly higher initial processing cost.
 *   By keeping them separate, the library provides two distinct tools: a simple one for basic needs and an advanced one for stylistic text.
 * @note **Performance Considerations:** Because this function allocates and frees a temporary image for every single character drawn, it is not recommended for text that needs to be redrawn every frame (e.g., a rapidly changing score counter).
 *       For performance-critical text, it is best to pre-render the required characters to a single font atlas image and then use `SituationImageDrawAlpha` to blit the characters from the atlas.
 * @param dst The destination image to be modified.
 * @param font The `SituationFont` to use for rendering the characters.
 * @param text The null-terminated string to be drawn.
 * @param position The top-left position on the destination image for the baseline of the first character.
 * @param fontSize The height of the font in pixels.
 * @param spacing Additional horizontal space to add between each character.
 * @param tint The color to apply to the text. The text will be rendered in this color.
 */
SITAPI void SituationImageDrawText(SituationImage *dst, SituationFont font, const char *text, Vector2 position, float fontSize, float spacing, ColorRGBA tint) {
    if (!SituationIsImageValid(*dst) || !font.stbFontInfo || !text) return;

    stbtt_fontinfo *info = (stbtt_fontinfo*)font.stbFontInfo;
    float scale = stbtt_ScaleForPixelHeight(info, fontSize);

    // Get vertical font metrics to correctly align characters on the baseline
    int ascent, descent;
    stbtt_GetFontVMetrics(info, &ascent, &descent, NULL);
    int baseline = (int)(ascent * scale);
    
    float x = position.x;

    for (int i = 0; text[i]; ++i) {
        int codepoint = text[i];
        
        // Add kerning for the previous character
        if (i > 0) {
            x += stbtt_GetCodepointKernAdvance(info, text[i-1], codepoint) * scale;
        }

        // --- Step 1: Generate the character's bitmap using stb_truetype ---
        int g_x0, g_y0, g_x1, g_y1;
        stbtt_GetCodepointBitmapBox(info, codepoint, scale, scale, &g_x0, &g_y0, &g_x1, &g_y1);

        int glyph_w = g_x1 - g_x0;
        int glyph_h = g_y1 - g_y0;

        if (glyph_w > 0 && glyph_h > 0) {
            // Render the 1-channel alpha glyph from stb_truetype
            unsigned char *glyphBitmap = (unsigned char*)malloc(glyph_w * glyph_h);
            stbtt_MakeCodepointBitmap(info, glyphBitmap, glyph_w, glyph_h, glyph_w, scale, scale, codepoint);

            // --- Step 2: Create a temporary 4-channel SituationImage for our compositing function ---
            // Note: We create a white image with the glyph's alpha, because the 'tint' parameter in SituationImageDrawAlpha will provide the final color.
            SituationImage glyphImage = {0};
            glyphImage.width = glyph_w;
            glyphImage.height = glyph_h;
            glyphImage.data = malloc(glyph_w * glyph_h * 4);
            
            unsigned char* glyphPixels = (unsigned char*)glyphImage.data;
            for (int p = 0; p < glyph_w * glyph_h; ++p) {
                glyphPixels[p*4 + 0] = 255; // R
                glyphPixels[p*4 + 1] = 255; // G
                glyphPixels[p*4 + 2] = 255; // B
                glyphPixels[p*4 + 3] = glyphBitmap[p]; // Alpha comes from the rendered glyph
            }
            free(glyphBitmap);

            // --- Step 3: Use our powerful, generic drawing function to do the hard work! ---
            Rectangle srcRect = { 0, 0, (float)glyph_w, (float)glyph_h };
            Vector2 dstPos = { (float)((int)x + g_x0), (float)((int)position.y + baseline + g_y0) };
            
            SituationImageDrawAlpha(dst, glyphImage, srcRect, dstPos, tint);
            
            // --- Step 4: Clean up the temporary glyph image ---
            SituationUnloadImage(glyphImage);
        }

        // Advance the cursor for the next character
        int advanceWidth;
        stbtt_GetCodepointHMetrics(info, codepoint, &advanceWidth, NULL);
        x += ((float)advanceWidth * scale) + spacing;
    }
}

/**
 * @brief Calculates the bounding box of a text string without rendering it.
 * @details This function determines the width and height that the specified text would occupy if drawn with the given font and size. It accounts for the font's vertical metrics (ascent and descent) and the horizontal advance of each character, including kerning pairs.
 *          This is essential for UI layout, such as centering text, creating buttons of the correct size, or implementing word-wrapping logic.
 *
 * @param font The `SituationFont` to use for measurement.
 * @param text The null-terminated string to measure.
 * @param fontSize The desired font size in pixels.
 *
 * @return A `Rectangle` struct where `width` and `height` contain the measured dimensions. The `x` and `y` fields are set to 0.
 * @return A `Rectangle` with `width` and `height` of 0 if the library is not initialized, the font is invalid, or the text is NULL.
 *
 * @note The returned height is the font's line height (ascent - descent), which is consistent for all strings using that font and size. The width is specific to the provided text.
 *
 * @see SituationImageDrawText(), SituationImageDrawTextEx()
 */
SITAPI Rectangle SituationMeasureText(SituationFont font, const char *text, float fontSize) {
    Rectangle bounds = {0};
    if (!font.stbFontInfo || !text) return bounds;

    stbtt_fontinfo *info = (stbtt_fontinfo*)font.stbFontInfo;
    float scale = stbtt_ScaleForPixelHeight(info, fontSize);
    
    int ascent, descent;
    stbtt_GetFontVMetrics(info, &ascent, &descent, NULL);
    bounds.height = (int)((float)(ascent - descent) * scale);
    
    float x = 0;
    for (int i = 0; text[i]; ++i) {
        int codepoint = text[i];
        if (i > 0) {
            x += stbtt_GetCodepointKernAdvance(info, text[i-1], codepoint) * scale;
        }
        int advanceWidth, leftSideBearing;
        stbtt_GetCodepointHMetrics(info, codepoint, &advanceWidth, &leftSideBearing);
        x += (float)advanceWidth * scale;
    }
    bounds.width = (int)x;

    return bounds;
}

// --- Audio Implementations (MiniAudio) ---
/**
 * @brief The core audio processing callback function for MiniAudio.
 *
 * This function is called by the audio thread whenever the audio device needs more data.
 * It is responsible for mixing all active sounds and applying all effects in a specific order.
 * The processing chain for each sound is as follows:
 *
 * 1. **Decode:** Raw PCM data is read from the source (file, memory, or stream).
 * 2. **Built-in Effects Chain:** The raw data is processed through the sound's active built-in effects:
 *    - Biquad Filter (Low/High-pass)
 *    - Echo (Delay)
 *    - Reverb
 * 3. **Custom Processor Chain:** The data is then passed through any user-attached DSP processors, allowing for custom, real-time effects like bitcrushing or flangers.
 * 4. **Final Conversion & Mixing:** The fully processed audio is then:
 *    - Resampled to apply pitch shifting and match the device's sample rate.
 *    - Converted to the device's native format (e.g., S16, F32).
 *    - Panned and volume-adjusted.
 *    - Additively mixed into the final output buffer that goes to the speakers.
 *
 * All access to the shared sound queue is protected by a mutex to ensure thread safety.
 */
static void sit_miniaudio_data_callback(ma_device* pDevice, void* pOutput, const void* pInput, uint32_t frameCount) {
    (void)pInput;

    _SituationGlobalStateContainer* pGs = (_SituationGlobalStateContainer*)pDevice->pUserData;
    if (!pGs || frameCount == 0 || !pOutput) {
        return;
    }

    if (frameCount > pGs->sit_audio_callback_temp_buffer_frames_capacity) {
        frameCount = pGs->sit_audio_callback_temp_buffer_frames_capacity;
    }

    ma_mutex_lock(&pGs->sit_audio_queue_mutex);

    memset(pOutput, 0, frameCount * ma_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels));

    float* decoder_buffer = pGs->sit_audio_callback_decoder_temp_buffer;
    float* effects_buffer = pGs->sit_audio_callback_effects_temp_buffer;
    void*  converter_buffer = pGs->sit_audio_callback_converter_temp_buffer;

    for (int i = 0; i < pGs->sit_queued_sound_count; ++i) {
        SituationSound* sound = pGs->sit_queued_sounds[i];

        if (!sound || !sound->is_initialized || !sound->converter_initialized) {
            continue;
        }

        uint64_t frames_contributed_by_this_sound_total = 0;
        
        while (frames_contributed_by_this_sound_total < frameCount) {
            uint64_t frames_needed_for_output_pass = frameCount - frames_contributed_by_this_sound_total;
            uint64_t input_frames_converter_requires;
            
            ma_data_converter_get_required_input_frame_count(&sound->converter, frames_needed_for_output_pass, &input_frames_converter_requires);
            
            if (input_frames_converter_requires > pGs->sit_audio_callback_temp_buffer_frames_capacity) {
                 input_frames_converter_requires = pGs->sit_audio_callback_temp_buffer_frames_capacity;
            }

            uint64_t frames_read_from_decoder;
            ma_result res_dec = ma_decoder_read_pcm_frames(&sound->decoder, decoder_buffer, input_frames_converter_requires, &frames_read_from_decoder);
            sound->cursor_frames += frames_read_from_decoder;

            if (res_dec != MA_SUCCESS && res_dec != MA_AT_END) {
                pGs->sit_queued_sounds[i] = pGs->sit_queued_sounds[--pGs->sit_queued_sound_count]; i--;
                goto next_sound_in_queue_locked;
            }

            if (frames_read_from_decoder == 0) {
                if (sound->is_looping) {
                    ma_decoder_seek_to_pcm_frame(&sound->decoder, 0);
                    sound->cursor_frames = 0;
                    continue; 
                } else {
                    pGs->sit_queued_sounds[i] = pGs->sit_queued_sounds[--pGs->sit_queued_sound_count]; i--;
                    goto next_sound_in_queue_locked;
                }
            }

            // ====================================================================
            // --- Audio Processing Chain (Operates on floating-point PCM data) ---
            // ====================================================================            float* pFramesIn = decoder_buffer;
            float* pFramesOut = effects_buffer;
            uint64_t frame_count_for_effects = frames_read_from_decoder;
            ma_uint32 effect_channels = sound->decoder.outputChannels;

            // --- Stage 1: Built-in Effects ---
            if (sound->effects.filter_enabled) {
                ma_biquad_process_pcm_frames(&sound->effects.biquad, pFramesOut, pFramesIn, frame_count_for_effects, effect_channels);
                float* temp = pFramesIn; pFramesIn = pFramesOut; pFramesOut = temp;
            }
            if (sound->effects.echo_enabled) {
                ma_delay_process_pcm_frames(&sound->effects.delay, pFramesOut, pFramesIn, frame_count_for_effects, effect_channels);
                float* temp = pFramesIn; pFramesIn = pFramesOut; pFramesOut = temp;
            }
            if (sound->effects.reverb_enabled) {
                ma_reverb_process_pcm_frames(&sound->effects.reverb, pFramesOut, pFramesIn, frame_count_for_effects, effect_channels);
                float* temp = pFramesIn; pFramesIn = pFramesOut; pFramesOut = temp;
            }
            
            // --- Stage 2: Custom User-Attached Processors ---
            if (sound->processor_count > 0) {
                for (int proc_idx = 0; proc_idx < sound->processor_count; ++proc_idx) {
                    if (sound->processors[proc_idx] != NULL) {
                        // The user processor modifies the buffer in-place.
                        sound->processors[proc_idx](
                            pFramesIn, // The buffer to process
                            frame_count_for_effects,
                            effect_channels,
                            sound->decoder.outputSampleRate,
                            sound->processor_user_data[proc_idx]
                        );
                    }
                }
            }

            // The final, fully processed frames are now in the `pFramesIn` buffer.
            // ======================= END OF PROCESSING CHAIN ========================

            // --- Stage 3: Final Conversion (Pitch, Format, Channels) ---
            uint64_t input_frames_for_converter_pass = frames_read_from_decoder;
            uint64_t output_frames_from_converter_pass = frames_needed_for_output_pass; 
            ma_data_converter_process_pcm_frames(&sound->converter, pFramesIn, &input_frames_for_converter_pass, converter_buffer, &output_frames_from_converter_pass);

            // --- Stage 4: Pan and Volume ---
            // This stage prepares the `converter_buffer` completely.
            if (output_frames_from_converter_pass > 0) {
                ma_format device_format = pDevice->playback.format;
                uint32_t device_channels = pDevice->playback.channels;

                if (device_format == ma_format_f32) {
                    float* samples = (float*)converter_buffer;
                    for (uint64_t frame_idx = 0; frame_idx < output_frames_from_converter_pass; ++frame_idx) {
                        float L_gain = 1.0f, R_gain = 1.0f;
                        if (device_channels >= 2) {
                            float pan_factor_norm = (sound->pan + 1.0f) * 0.5f;
                            L_gain = cosf(pan_factor_norm * (float)M_PI_2);
                            R_gain = sinf(pan_factor_norm * (float)M_PI_2);
                        }
                        for (uint32_t chan_idx = 0; chan_idx < device_channels; ++chan_idx) {
                            float current_sample = samples[frame_idx * device_channels + chan_idx];
                            if (chan_idx == 0 && device_channels >= 2) current_sample *= L_gain;
                            else if (chan_idx == 1 && device_channels >= 2) current_sample *= R_gain;
                            current_sample *= sound->volume;
                            samples[frame_idx * device_channels + chan_idx] = current_sample;
                        }
                    }
                } else if (device_format == ma_format_s16) {
                    ma_int16* samples = (ma_int16*)converter_buffer;
                    for (uint64_t frame_idx = 0; frame_idx < output_frames_from_converter_pass; ++frame_idx) {
                        float L_gain = 1.0f, R_gain = 1.0f;
                        if (device_channels >= 2) {
                            float pan_factor_norm = (sound->pan + 1.0f) * 0.5f;
                            L_gain = cosf(pan_factor_norm * (float)M_PI_2);
                            R_gain = sinf(pan_factor_norm * (float)M_PI_2);
                        }
                        for (uint32_t chan_idx = 0; chan_idx < device_channels; ++chan_idx) {
                            float sample_f = (float)samples[frame_idx * device_channels + chan_idx] / 32768.0f;
                            if (chan_idx == 0 && device_channels >= 2) sample_f *= L_gain;
                            else if (chan_idx == 1 && device_channels >= 2) sample_f *= R_gain;
                            sample_f *= sound->volume;
                            if (sample_f > 1.0f) sample_f = 1.0f; else if (sample_f < -1.0f) sample_f = -1.0f;
                            samples[frame_idx * device_channels + chan_idx] = (ma_int16)(sample_f * 32767.0f);
                        }
                    }
                }
            }

            // --- Stage 5: Mix into Output Buffer ---
            // This block now *only* performs mixing. The pan/volume logic has been removed.
            if (output_frames_from_converter_pass > 0) {
                if (pDevice->playback.format == ma_format_f32) {
                    float* main_out_ptr = (float*)pOutput + (frames_contributed_by_this_sound_total * pDevice->playback.channels);
                    float* processed_sound_ptr = (float*)converter_buffer;
                    for (uint64_t k = 0; k < output_frames_from_converter_pass * pDevice->playback.channels; ++k) {
                        main_out_ptr[k] += processed_sound_ptr[k];
                    }
                } else if (pDevice->playback.format == ma_format_s16) {
                    ma_int16* main_out_ptr = (ma_int16*)pOutput + (frames_contributed_by_this_sound_total * pDevice->playback.channels);
                    ma_int16* processed_sound_ptr = (ma_int16*)converter_buffer;
                    for (uint64_t k = 0; k < output_frames_from_converter_pass * pDevice->playback.channels; ++k) {
                        ma_int32 mixed = (ma_int32)main_out_ptr[k] + (ma_int32)processed_sound_ptr[k];
                        if (mixed > 32767) mixed = 32767; else if (mixed < -32768) mixed = -32768;
                        main_out_ptr[k] = (ma_int16)mixed;
                    }
                }
            }
            
            frames_contributed_by_this_sound_total += output_frames_from_converter_pass;

            if (input_frames_for_converter_pass < frames_read_from_decoder) {
                ma_int64 seek_offset_frames = (ma_int64)input_frames_for_converter_pass - (ma_int64)frames_read_from_decoder;
                ma_decoder_seek_relative_pcm_frames(&sound->decoder, seek_offset_frames, NULL);
                sound->cursor_frames += seek_offset_frames;
            }
        }
        
    next_sound_in_queue_locked:;
    }

    ma_mutex_unlock(&pGs->sit_audio_queue_mutex);
}


// --- Situation Audio Pipeline API Implementation ---
/**
 * @brief Enumerates all available audio playback devices on the system.
 * @details This function queries the underlying audio backend (MiniAudio) for a list of all devices capable of playing sound. It provides their human-readable names and internal identifiers.
 *
 * @warning The returned array of `SituationAudioDeviceInfo` structs is dynamically allocated. The caller is **responsible for freeing this memory** using `free()` when it is no longer needed.
 *
 * @param[out] count A pointer to an integer that will be filled with the number of devices found.
 *
 * @return A pointer to a newly allocated array of `SituationAudioDeviceInfo` structs.
 * @return `NULL` if the library is not initialized, if no playback devices are found, or if a memory allocation error occurs. In these cases, `*count` is set to 0.
 *
 * @note The returned information can be used with `SituationSetAudioDevice` to switch output to a specific device (e.g., headphones vs. speakers).
 *
 * @see SituationSetAudioDevice()
 */
SITAPI SituationAudioDeviceInfo* SituationGetAudioDevices(int* count) {
    if (!sit_gs.is_sit_miniaudio_context_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_AUDIO_CONTEXT, "GetAudioDevices: MiniAudio context not initialized");
        if (count) *count = 0;
        return NULL;
    }

    ma_device_info* ma_playback_devices = NULL;
    uint32_t ma_playback_count = 0;
    // ma_device_info* ma_capture_devices = NULL; // Not used in this example
    // uint32_t ma_capture_count = 0;

    ma_result res = ma_context_get_devices(&sit_gs.sit_miniaudio_context, &ma_playback_devices, &ma_playback_count, NULL, NULL); // Passing NULL for capture devices
    if (res != MA_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_AUDIO_DEVICE, "ma_context_get_devices failed");
        if (count) *count = 0;
        return NULL;
    }

    if (ma_playback_count == 0) {
        _SituationSetError("No playback audio devices found by MiniAudio.");
        if (count) *count = 0;
        return NULL;
    }

    SituationAudioDeviceInfo* sit_devices = (SituationAudioDeviceInfo*)calloc(ma_playback_count, sizeof(SituationAudioDeviceInfo));
    if (!sit_devices) {
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Audio device info array");
        if (count) *count = 0;
        return NULL;
    }

    for (uint32_t i = 0; i < ma_playback_count; ++i) {
        strncpy(sit_devices[i].name, ma_playback_devices[i].name, SITUATION_MAX_DEVICE_NAME_LEN - 1);
        sit_devices[i].name[SITUATION_MAX_DEVICE_NAME_LEN - 1] = '\0'; // Ensure null termination
        memcpy(&sit_devices[i].id, &ma_playback_devices[i].id, sizeof(ma_device_id));
        sit_devices[i].situation_internal_id = i; 
        sit_devices[i].is_default_playback = ma_playback_devices[i].isDefault;
        sit_devices[i].is_default_capture = false; // Not querying capture defaults here
    }

    if (count) *count = ma_playback_count;
    // Note: Memory for ma_playback_devices is managed by the ma_context.
    // Do NOT free ma_playback_devices here.
    return sit_devices;
}

/**
 * @brief Switches the active audio output to a specific device.
 * @details This function re-initializes the audio subsystem to use the device specified by its internal ID (obtained from `SituationGetAudioDevices`). It allows the user to select their preferred output, such as switching between speakers and a headset.
 *
 * @par Behavior
 *   If an audio device is already active, it will be stopped and uninitialized before the new device is started. The new device will be configured with the specified format, or with sensible defaults (stereo, 48kHz float32) if `format` is NULL.
 *
 * @param situation_internal_id The internal ID of the target device, corresponding to its index in the array returned by `SituationGetAudioDevices`.
 * @param format A pointer to a `SituationAudioFormat` struct specifying the desired sample rate, channel count, and bit depth for the new device. Can be `NULL` to use defaults.
 *
 * @return `SITUATION_SUCCESS` on successful switch.
 * @return `SITUATION_ERROR_AUDIO_CONTEXT` if the audio system is not initialized.
 * @return `SITUATION_ERROR_AUDIO_DEVICE` if the ID is invalid, or if the new device fails to initialize or start.
 * @return `SITUATION_ERROR_INVALID_PARAM` if the requested format contains an unsupported bit depth.
 *
 * @warning Switching devices may cause a brief interruption in audio playback.
 *
 * @see SituationGetAudioDevices()
 */
SITAPI SituationError SituationSetAudioDevice(int situation_internal_id, const SituationAudioFormat* format) {
    if (!sit_gs.is_sit_miniaudio_context_initialized) return SITUATION_ERROR_AUDIO_CONTEXT;

    ma_device_info* ma_playback_devices = NULL;
    uint32_t ma_playback_count = 0;
    ma_result res = ma_context_get_devices(&sit_gs.sit_miniaudio_context, &ma_playback_devices, &ma_playback_count, NULL, NULL);
    
    if (res != MA_SUCCESS || situation_internal_id < 0 || (uint32_t)situation_internal_id >= ma_playback_count) {
        _SituationSetErrorFromCode(SITUATION_ERROR_AUDIO_DEVICE, "Invalid internal_id or failed to enumerate for SetAudioDevice");
        return SITUATION_ERROR_AUDIO_DEVICE;
    }
    
    ma_device_id* target_device_id = &ma_playback_devices[situation_internal_id].id;

    if (sit_gs.is_sit_miniaudio_device_active) {
        ma_device_uninit(&sit_gs.sit_miniaudio_device);
        sit_gs.is_sit_miniaudio_device_active = false;
    }

    ma_device_config device_config = ma_device_config_init(ma_device_type_playback);
    device_config.playback.pDeviceID = target_device_id; 
    device_config.dataCallback = sit_miniaudio_data_callback;
    device_config.pUserData = &sit_gs; // Pass global state if callback needs it (e.g. for temp buffers)
                                      // User data is accessed via pDevice->pUserData in callback
    
    if (format) {
        device_config.playback.channels = format->channels;
        device_config.sampleRate = format->sample_rate;
        if (format->bit_depth == 32) device_config.playback.format = ma_format_f32;
        else if (format->bit_depth == 16) device_config.playback.format = ma_format_s16;
        else if (format->bit_depth == 24) device_config.playback.format = ma_format_s24; // Requires device support
        else if (format->bit_depth == 8) device_config.playback.format = ma_format_u8;   // Requires device support
        else {
            _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Unsupported bit depth in SetAudioDevice format");
            return SITUATION_ERROR_INVALID_PARAM;
        }
    } else { // Use device default format preferences, or sensible common defaults
        device_config.playback.format = ma_format_f32; // Prefer float32 for easier mixing
        device_config.playback.channels = 2;           // Stereo default
        device_config.sampleRate = 48000;              // Common default sample rate
        // To use device's native format:
        // device_config.playback.format = ma_format_unknown; // Let miniaudio pick
        // device_config.playback.nativeChannelCount = 0; // Use device native or best match
        // device_config.nativeSampleRate = 0;
    }
    // Define period size for callback scheduling (optional, MiniAudio has defaults)
    // device_config.periodSizeInFrames = 512; // Example: ~10ms at 48kHz

    res = ma_device_init(&sit_gs.sit_miniaudio_context, &device_config, &sit_gs.sit_miniaudio_device);
    if (res != MA_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_AUDIO_DEVICE, ma_result_description(res));
        return SITUATION_ERROR_AUDIO_DEVICE;
    }
    
    if (!sit_gs.is_sit_miniaudio_device_internally_paused) { // Only start if not meant to be paused
        res = ma_device_start(&sit_gs.sit_miniaudio_device);
        if (res != MA_SUCCESS) {
            ma_device_uninit(&sit_gs.sit_miniaudio_device);
            _SituationSetErrorFromCode(SITUATION_ERROR_AUDIO_DEVICE, "Failed to start new audio device");
            return SITUATION_ERROR_AUDIO_DEVICE;
        }
    }

    sit_gs.is_sit_miniaudio_device_active = true;
    sit_gs.current_sit_miniaudio_device_sitaudioinfo_id = situation_internal_id;
    return SITUATION_SUCCESS;
}

/**
 * @brief Gets the sample rate of the currently active audio playback device.
 * @details This is the master sample rate at which the audio engine is mixing and outputting sound to the hardware. All playing sounds are resampled to match this rate.
 *
 * @return The sample rate in Hertz (e.g., 44100, 48000).
 * @return `0` if the library is not initialized or if no audio device is currently active.
 */
SITAPI int SituationGetAudioPlaybackSampleRate(void) {
    if (!sit_gs.is_sit_miniaudio_device_active) {
        _SituationSetError("Audio device not active for GetAudioPlaybackSampleRate");
        return 0;
    }
    return sit_gs.sit_miniaudio_device.sampleRate;
}

/**
 * @brief Re-initializes the active audio device with a new sample rate.
 * @details This function allows you to change the master output sample rate of the audio engine at runtime.
 *
 * @par Behavior
 *   The function preserves the current device, channel count, and bit depth. It stops the device, re-initializes it with the new sample rate, and restarts it.
 *
 * @param sample_rate The new desired sample rate in Hertz (e.g., 44100, 48000, 96000).
 *
 * @return `SITUATION_SUCCESS` on successful change.
 * @return `SITUATION_ERROR_AUDIO_DEVICE` if no device is active, if the current format cannot be determined, or if re-initialization fails.
 *
 * @warning Changing the sample rate will cause a brief interruption in audio playback.
 * @note All currently playing sounds will be automatically resampled to the new master rate by their internal converters.
 */
SITAPI SituationError SituationSetAudioPlaybackSampleRate(int sample_rate) {
     if (!sit_gs.is_sit_miniaudio_device_active || sit_gs.current_sit_miniaudio_device_sitaudioinfo_id < 0) {
        _SituationSetError("No audio device set, cannot change sample rate.");
        return SITUATION_ERROR_AUDIO_DEVICE;
    }
    SituationAudioFormat current_fmt;
    current_fmt.channels = sit_gs.sit_miniaudio_device.playback.channels;
    current_fmt.sample_rate = sample_rate; 
    
    ma_format current_ma_fmt = sit_gs.sit_miniaudio_device.playback.format;
    if (current_ma_fmt == ma_format_f32) current_fmt.bit_depth = 32;
    else if (current_ma_fmt == ma_format_s16) current_fmt.bit_depth = 16;
    else if (current_ma_fmt == ma_format_s24) current_fmt.bit_depth = 24;
    else if (current_ma_fmt == ma_format_u8) current_fmt.bit_depth = 8;
    else {
        _SituationSetError("Cannot determine current bit depth to change sample rate (unsupported format).");
        return SITUATION_ERROR_AUDIO_DEVICE;
    }
    
    return SituationSetAudioDevice(sit_gs.current_sit_miniaudio_device_sitaudioinfo_id, &current_fmt);
}

/**
 * @brief Gets the current master volume of the audio device.
 * @details This is the global volume level applied to the final mix before it is sent to the speakers.
 *
 * @return The master volume as a linear scalar value. `0.0f` is silent, `1.0f` is the default volume.
 * @return `0.0f` if the library is not initialized or if no audio device is currently active.
 *
 * @see SituationSetAudioMasterVolume()
 */
SITAPI float SituationGetAudioMasterVolume(void) {
    if (!sit_gs.is_sit_miniaudio_device_active) {
        _SituationSetError("Audio device not active for GetAudioMasterVolume");
        return 0.0f;
    }
    float volume = 0.0f; // Default to 0 if get fails
    ma_result res = ma_device_get_master_volume(&sit_gs.sit_miniaudio_device, &volume);
    if (res != MA_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_AUDIO_DEVICE, "Failed to get master volume");
        // volume remains 0.0f or its last valid value if ma_device_get_master_volume modified it partially
    }
    return volume;
}

/**
 * @brief Sets the master volume for the entire audio device.
 * @details This function controls the final, global volume level of all mixed audio before it is sent to the hardware. It affects all sounds currently playing and is independent of individual sound volumes.
 *
 * @param volume The desired master volume as a linear scalar. `0.0f` is silent, `1.0f` is the default (unattenuated) volume. Values greater than `1.0f` can be used for amplification if supported by the backend. Negative values are clamped to `0.0f`.
 *
 * @return SITUATION_SUCCESS on success.
 * @return SITUATION_ERROR_AUDIO_DEVICE if no audio device is active or if the volume cannot be set.
 *
 * @see SituationGetAudioMasterVolume(), SituationSetSoundVolume()
 */
SITAPI SituationError SituationSetAudioMasterVolume(float volume) {
    if (!sit_gs.is_sit_miniaudio_device_active) return SITUATION_ERROR_AUDIO_DEVICE;
    // MiniAudio volume is linear [0, 1], can go >1 for gain. Clamp to [0,1] for typical app behavior.
    float clamped_volume = (volume < 0.0f) ? 0.0f : volume; // (volume > 1.0f) ? 1.0f : volume; // No upper clamp to allow gain
                                                                                    
    ma_result res = ma_device_set_master_volume(&sit_gs.sit_miniaudio_device, clamped_volume);
    if (res != MA_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_AUDIO_DEVICE, "Failed to set master volume");
        return SITUATION_ERROR_AUDIO_DEVICE;
    }
    return SITUATION_SUCCESS;
}

/**
 * @brief Checks if the audio device is currently active and playing sound.
 * @details This function checks two conditions: that an audio device has been successfully initialized and started, and that the application has not manually paused it via `SituationPauseApp()` or `SituationPauseAudioDevice()`.
 *
 * @return `true` if the audio device is running and not paused, `false` otherwise.
 *
 * @see SituationPauseAudioDevice(), SituationResumeAudioDevice()
 */
SITAPI bool SituationIsAudioDevicePlaying(void) {
    if (!sit_gs.is_sit_miniaudio_device_active) return false;
    // Considered "playing" if device is started and not internally marked as paused by our system
    return ma_device_is_started(&sit_gs.sit_miniaudio_device) && !sit_gs.is_sit_miniaudio_device_internally_paused;
}

/**
 * @brief Pauses all audio output by stopping the audio device.
 * @details This function halts the audio processing thread. No sounds will be played, and the audio callback will no longer be called until `SituationResumeAudioDevice()` is invoked.
 *          This is a low-power state ideal for when the application is minimized or in a pause menu.
 *
 * @note This function is called automatically when the application is paused via `SituationPauseApp()`.
 *
 * @return SITUATION_SUCCESS on success.
 * @return SITUATION_ERROR_AUDIO_DEVICE if the device fails to stop.
 *
 * @see SituationResumeAudioDevice(), SituationIsAudioDevicePlaying(), SituationPauseApp()
 */
SITAPI SituationError SituationPauseAudioDevice(void) {
    if (!sit_gs.is_sit_miniaudio_device_active) {
        // Not an error to pause an inactive device, just mark it.
        sit_gs.is_sit_miniaudio_device_internally_paused = true;
        return SITUATION_SUCCESS;
    }

    if (ma_device_is_started(&sit_gs.sit_miniaudio_device)) {
        ma_result res = ma_device_stop(&sit_gs.sit_miniaudio_device);
        if (res != MA_SUCCESS) {
            _SituationSetErrorFromCode(SITUATION_ERROR_AUDIO_DEVICE, "Failed to stop (pause) audio device");
            return SITUATION_ERROR_AUDIO_DEVICE;
        }
    }
    
    sit_gs.is_sit_miniaudio_device_internally_paused = true;
    return SITUATION_SUCCESS;
}

/**
 * @brief Resumes all audio output by restarting a paused audio device.
 * @details If the audio device was previously stopped by `SituationPauseAudioDevice()`, this function restarts the audio processing thread, and sound playback will continue from where it left off.
 *
 * @note This function is called automatically when the application is resumed via `SituationResumeApp()`.
 *
 * @return SITUATION_SUCCESS on success.
 * @return SITUATION_ERROR_AUDIO_DEVICE if the device fails to start.
 *
 * @see SituationPauseAudioDevice(), SituationIsAudioDevicePlaying(), SituationResumeApp()
 */
SITAPI SituationError SituationResumeAudioDevice(void) {
    sit_gs.is_sit_miniaudio_device_internally_paused = false;
    
    if (sit_gs.is_sit_miniaudio_device_active && !ma_device_is_started(&sit_gs.sit_miniaudio_device)) {
        ma_result res = ma_device_start(&sit_gs.sit_miniaudio_device);
        if (res != MA_SUCCESS) {
            _SituationSetErrorFromCode(SITUATION_ERROR_AUDIO_DEVICE, "Failed to start (resume) audio device");
            return SITUATION_ERROR_AUDIO_DEVICE;
        }
    }
    
    return SITUATION_SUCCESS;
}

// --- Helper to initialize effects for a sound ---
/**
 * @brief [INTERNAL] Initializes the built-in effects chain for a given sound.
 * @details This helper function is called once after a sound's decoder has been initialized. It allocates and sets up the internal data structures for the sound's real-time effects, including the biquad filter (for LPF/HPF), the echo/delay unit, and the reverb processor.
 *          All effects are initialized to a disabled state with default parameters.
 *
 * @param sound A pointer to the `SituationSound` struct to initialize. The sound's `decoder` member must already be valid, as its channel count and sample rate are used for configuration.
 *
 * @return SITUATION_SUCCESS if all effects are initialized successfully.
 * @return SITUATION_ERROR_INVALID_PARAM if the `sound` pointer is NULL or not initialized.
 * @return SITUATION_ERROR_AUDIO_CONTEXT if an underlying MiniAudio effect fails to initialize.
 *
 * @note This function is for internal use by the `SituationLoadSound*` functions only.
 *
 * @see SituationLoadSoundFromFile(), SituationLoadSoundFromStream()
 */
static SituationError _SituationInitSoundEffects(SituationSound* sound) {
    if (!sound || !sound->is_initialized) return SITUATION_ERROR_INVALID_PARAM;
    ma_uint32 channels = sound->decoder.outputChannels;
    ma_uint32 sampleRate = sound->decoder.outputSampleRate;

    // Filter
    ma_biquad_config bq_config = ma_biquad_config_init(ma_format_f32, channels, 1000, 1, 1); // Default init
    ma_result res = ma_biquad_init(&bq_config, NULL, &sound->effects.biquad);
    if (res != MA_SUCCESS) return SITUATION_ERROR_AUDIO_CONTEXT;
    sound->effects.filter_enabled = false;
    sound->effects.filter_type = SITUATION_FILTER_NONE;
    
    // Echo
    ma_delay_config delay_config = ma_delay_config_init(channels, sampleRate, (ma_uint32)(sampleRate * 1.0f), 0.5f); // 1 sec delay max
    res = ma_delay_init(&delay_config, NULL, &sound->effects.delay);
    if (res != MA_SUCCESS) return SITUATION_ERROR_AUDIO_CONTEXT;
    sound->effects.echo_enabled = false;

    // Reverb
    ma_reverb_config reverb_config = ma_reverb_config_init(ma_format_f32, channels, sampleRate);
    reverb_config.roomSize = 0.5f; reverb_config.damping = 0.5f; reverb_config.wetVolume = 1.0f; reverb_config.dryVolume = 1.0f;
    res = ma_reverb_init(&reverb_config, NULL, &sound->effects.reverb);
    if (res != MA_SUCCESS) { ma_delay_uninit(&sound->effects.delay, NULL); return SITUATION_ERROR_AUDIO_CONTEXT; }
    sound->effects.reverb_enabled = false;

    return SITUATION_SUCCESS;
}

/**
 * @brief Loads and decodes an entire audio file into memory for playback.
 * @details This function is the primary way to load common sound effects and music. It uses the underlying audio library (MiniAudio) to decode various formats (WAV, MP3, OGG, FLAC) into a raw PCM format.
 *          It also initializes the sound's internal effects chain and resampling converter, making it ready for immediate playback.
 *
 * @par Resource Management
 *   This function initializes a `SituationSound` struct. The caller is **responsible** for cleaning up this struct by calling `SituationUnloadSound()` when it is no longer needed to prevent memory leaks.
 *
 * @param file_path The path to the audio file to load.
 * @param looping If `true`, the sound will automatically restart from the beginning when it finishes playing.
 * @param[out] out_sound A pointer to a `SituationSound` struct that will be initialized with the loaded data.
 *
 * @return SITUATION_SUCCESS on successful loading and decoding.
 * @return SITUATION_ERROR_FILE_ACCESS if the file cannot be found or read.
 * @return SITUATION_ERROR_AUDIO_DECODING if the file format is unsupported or corrupt.
 * @return SITUATION_ERROR_AUDIO_DEVICE if no audio device is active.
 *
 * @see SituationUnloadSound(), SituationLoadSoundFromStream()
 */
SITAPI SituationError SituationLoadSoundFromFile(const char* file_path, bool looping, SituationSound* out_sound) {
    if (!out_sound || !file_path) return SITUATION_ERROR_INVALID_PARAM;
    if (!sit_gs.is_sit_miniaudio_device_active) {
        _SituationSetError("Audio device not active for sound loading.");
        return SITUATION_ERROR_AUDIO_DEVICE;
    }
    memset(out_sound, 0, sizeof(SituationSound));
    out_sound->volume = 1.0f;
    out_sound->pan = 0.0f;
    out_sound->pitch = 1.0f;
    out_sound->is_streamed = false;
    out_sound->processors = NULL;
    out_sound->processor_user_data = NULL;
    out_sound->processor_count = 0;

    ma_decoder_config decoder_config = ma_decoder_config_init(ma_format_f32, 0, 0, NULL);
    ma_result res = ma_decoder_init_file(file_path, &decoder_config, &out_sound->decoder);
    if (res != MA_SUCCESS) {
        _SituationSetErrorFromCode(SITUATION_ERROR_FILE_ACCESS, ma_result_description(res));
        return SITUATION_ERROR_FILE_ACCESS;
    }

    res = ma_decoder_get_length_in_pcm_frames(&out_sound->decoder, &out_sound->total_frames);
    if (res != MA_SUCCESS) { ma_decoder_uninit(&out_sound->decoder); return SITUATION_ERROR_FILE_ACCESS; }
    
    ma_data_converter_config converter_config = ma_data_converter_config_init_default();
    converter_config.formatIn = out_sound->decoder.outputFormat;
    converter_config.channelsIn = out_sound->decoder.outputChannels;
    converter_config.sampleRateIn = out_sound->decoder.outputSampleRate;
    converter_config.formatOut = sit_gs.sit_miniaudio_device.playback.format;
    converter_config.channelsOut = sit_gs.sit_miniaudio_device.playback.channels;
    converter_config.sampleRateOut = sit_gs.sit_miniaudio_device.sampleRate;
    res = ma_data_converter_init(&converter_config, NULL, &out_sound->converter);
    if (res != MA_SUCCESS) { ma_decoder_uninit(&out_sound->decoder); return SITUATION_ERROR_AUDIO_CONVERTER; }
    
    out_sound->converter_initialized = true;
    out_sound->is_initialized = true;
    out_sound->is_looping = looping;

    if (_SituationInitSoundEffects(out_sound) != SITUATION_SUCCESS) {
        SituationUnloadSound(out_sound);
        _SituationSetError("Failed to initialize sound effects.");
        return SITUATION_ERROR_AUDIO_CONTEXT;
    }
    return SITUATION_SUCCESS;
}

static ma_decoder_vtable g_situation_stream_vtable = {0};

/**
 * @brief [INTERNAL] Custom V-Table function to handle reading from a user-defined stream.
 * @details This function serves as the bridge between the MiniAudio decoding engine and the user's custom stream implementation provided via `SituationLoadSoundFromStream`. When the decoder needs more data, it calls this function.
 *          This function's role is to locate the user's C-style callback function (`on_read`) and its associated `user_data` pointer, and then invoke the user's callback to fill the buffer.
 *
 * @par Thread Safety
 *   This function is called directly from the high-priority audio thread. It relies on the user-provided `on_read` callback to be thread-safe and non-blocking.
 *
 * @param pDecoder A pointer to the `ma_decoder` that is requesting data.
 * @param pBufferOut The buffer to write the raw audio data into.
 * @param bytesToRead The number of bytes the decoder is requesting.
 *
 * @return The number of bytes actually written to `pBufferOut`.
 *
 * @note This function is for internal use only and is part of the v-table for custom decoders.
 *
 * @see SituationLoadSoundFromStream()
 */
SITAPI static ma_uint64 _situation_stream_on_read(ma_decoder* pDecoder, void* pBufferOut, ma_uint64 bytesToRead) {
    SituationSound* sound = (SituationSound*)((char*)pDecoder - offsetof(SituationSound, decoder));
    SituationStreamReadCallback on_read = (SituationStreamReadCallback)pDecoder->pBackendVTable->onRead; // Stash callback here
    if (on_read) return on_read(sound->stream_user_data, pBufferOut, bytesToRead);
    return 0;
}

/**
 * @brief [INTERNAL] Custom V-Table function to handle seeking within a user-defined stream.
 * @details This function serves as the bridge for seeking operations, called by MiniAudio when functions like `ma_decoder_seek_to_pcm_frame` are used on a custom stream-based sound. It locates the user's `on_seek` callback and invokes it with the requested offset.
 *
 * @par Thread Safety
 *   This function is called directly from the high-priority audio thread. It relies on the user-provided `on_seek` callback to be thread-safe and non-blocking.
 *
 * @param pDecoder A pointer to the `ma_decoder` performing the seek.
 * @param byteOffset The offset in bytes to seek to.
 * @param origin The origin from which to calculate the seek (`ma_seek_origin_start` or `ma_seek_origin_current`).
 *
 * @return MA_SUCCESS on success, or an appropriate MiniAudio error code on failure.
 *
 * @note This function is for internal use only and is part of the v-table for custom decoders.
 *
 * @see SituationLoadSoundFromStream()
 */
SITAPI static ma_result _situation_stream_on_seek(ma_decoder* pDecoder, ma_int64 byteOffset, ma_seek_origin origin) {
    SituationSound* sound = (SituationSound*)((char*)pDecoder - offsetof(SituationSound, decoder));
    SituationStreamSeekCallback on_seek = (SituationStreamSeekCallback)pDecoder->pBackendVTable->onSeek; // Stash callback here
    if (on_seek) return on_seek(sound->stream_user_data, byteOffset, origin);
    return MA_NOT_IMPLEMENTED;
}

/**
 * @brief Initializes a sound for playback from a custom, user-defined data stream.
 * @details This is an advanced function for playing audio from non-file sources, such as procedural audio generators, network streams, or custom archive formats. You provide function pointers
 *          for reading and seeking within your data source, and the audio engine will call them as needed during playback to pull in audio data.
 *
 * @par Thread Safety
 *   The `on_read` and `on_seek` callbacks will be executed on a separate, high-priority audio thread.
 *   These functions **must be thread-safe** and should not perform blocking operations like file I/O or memory allocation.
 *
 * @param on_read A function pointer that the audio engine will call to request more audio data.
 * @param on_seek A function pointer that the audio engine will call to seek to a specific position in the stream. Can be `NULL` if seeking is not supported.
 * @param user_data A custom pointer that will be passed to your `on_read` and `on_seek` callbacks.
 * @param format A pointer to a `SituationAudioFormat` struct describing the native sample rate, channel count, and bit depth of the audio data your stream provides.
 * @param looping If `true`, the engine will attempt to seek to the beginning of the stream when it ends.
 * @param[out] out_sound A pointer to a `SituationSound` struct to be initialized.
 *
 * @return SITUATION_SUCCESS on successful initialization.
 *
 * @see SituationLoadSoundFromFile(), SituationUnloadSound()
 */
SITAPI SituationError SituationLoadSoundFromStream(SituationStreamReadCallback on_read, SituationStreamSeekCallback on_seek, void* user_data, const SituationAudioFormat* format, bool looping, SituationSound* out_sound) {
    if (!out_sound || !on_read || !format) return SITUATION_ERROR_INVALID_PARAM;
    if (!sit_gs.is_sit_miniaudio_device_active) {
         _SituationSetError("Audio device not active for stream loading.");
         return SITUATION_ERROR_AUDIO_DEVICE;
    }
    memset(out_sound, 0, sizeof(SituationSound));
    out_sound->volume = 1.0f;
    out_sound->pan = 0.0f;
    out_sound->pitch = 1.0f;
    out_sound->is_streamed = true;
    out_sound->processors = NULL;
    out_sound->processor_user_data = NULL;
    out_sound->processor_count = 0;
    out_sound->stream_user_data = user_data;

    g_situation_stream_vtable.onRead = (ma_decoder_read_proc)_situation_stream_on_read;
    g_situation_stream_vtable.onSeek = (ma_decoder_seek_proc)_situation_stream_on_seek;
    // Stash the user-provided callbacks in the vtable pointers MiniAudio provides for this purpose
    g_situation_stream_vtable.pBackendVTable = (ma_decoder_backend_vtable*)on_read;
    g_situation_stream_vtable.pBackendVTable->onSeek = (void*)on_seek;


    ma_decoder_config decoder_config = ma_decoder_config_init_custom(&g_situation_stream_vtable, out_sound);
    decoder_config.outputFormat = ma_format_f32;
    decoder_config.outputChannels = format->channels;
    decoder_config.outputSampleRate = format->sample_rate;

    ma_result res = ma_decoder_init(&decoder_config, &out_sound->decoder);
    if (res != MA_SUCCESS) { _SituationSetError("Failed to init custom stream decoder."); return SITUATION_ERROR_AUDIO_CONTEXT; }

    out_sound->total_frames = 0; // Length is unknown for a stream unless specified
    
    ma_data_converter_config converter_config = ma_data_converter_config_init_default();
    converter_config.formatIn = out_sound->decoder.outputFormat;
    converter_config.channelsIn = out_sound->decoder.outputChannels;
    converter_config.sampleRateIn = out_sound->decoder.outputSampleRate;
    converter_config.formatOut = sit_gs.sit_miniaudio_device.playback.format;
    converter_config.channelsOut = sit_gs.sit_miniaudio_device.playback.channels;
    converter_config.sampleRateOut = sit_gs.sit_miniaudio_device.sampleRate;
    res = ma_data_converter_init(&converter_config, NULL, &out_sound->converter);
    if (res != MA_SUCCESS) { ma_decoder_uninit(&out_sound->decoder); return SITUATION_ERROR_AUDIO_CONVERTER; }
    
    out_sound->converter_initialized = true;
    out_sound->is_initialized = true;
    out_sound->is_looping = looping;

    if (_SituationInitSoundEffects(out_sound) != SITUATION_SUCCESS) {
        SituationUnloadSound(out_sound);
        _SituationSetError("Failed to initialize stream sound effects.");
        return SITUATION_ERROR_AUDIO_CONTEXT;
    }
    return SITUATION_SUCCESS;
}

/**
 * @brief Unloads a sound and frees all of its associated memory and resources.
 * @details This is the designated cleanup function for any `SituationSound` initialized by the library.
 *          It releases the decoded PCM data, the internal data converter, and all effects processors.
 *
 * @param[in,out] sound A pointer to the `SituationSound` struct to uninitialize. The struct is zeroed out
 *                      after cleanup to invalidate it for future use.
 *
 * @note It is safe to call this function on a `NULL` pointer or an already-unloaded sound;
 *       it will simply do nothing.
 * @warning Failure to call this function on a loaded sound will result in a memory leak.
 *
 * @see SituationLoadSoundFromFile(), SituationLoadSoundFromStream()
 */
SITAPI void SituationUnloadSound(SituationSound* sound) {
    if (sound) {
        if (sound->converter_initialized) {
            ma_data_converter_uninit(&sound->converter, NULL);
        }
        if (sound->is_initialized) {
            ma_decoder_uninit(&sound->decoder);
            // Uninit effects
            ma_reverb_uninit(&sound->effects.reverb, NULL);
            ma_delay_uninit(&sound->effects.delay, NULL);
            // biquad does not have an uninit
        }
        memset(sound, 0, sizeof(SituationSound));
    }
}

/**
 * @brief Begins playback of a loaded sound or restarts it if already playing.
 * @details This function adds the specified sound to the audio engine's mixing queue. If the sound is already in the queue (i.e., it's currently playing or paused), its playback cursor will be reset to the beginning.
 *
 * @par Thread Safety
 *   This function is thread-safe and can be called from any thread.
 *
 * @param sound A pointer to a valid, initialized `SituationSound` struct.
 *
 * @return SITUATION_SUCCESS on success.
 * @return SITUATION_ERROR_AUDIO_SOUND_LIMIT if the maximum number of concurrent sounds is already playing.
 * @return SITUATION_ERROR_INVALID_PARAM if the `sound` handle is invalid.
 *
 * @see SituationStopLoadedSound(), SituationStopAllLoadedSounds()
 */
SITAPI SituationError SituationPlayLoadedSound(SituationSound* sound_to_play) { 
    if (!sit_gs.is_sit_miniaudio_device_active) return SITUATION_ERROR_AUDIO_DEVICE;
    if (!sound_to_play || !sound_to_play->is_initialized || !sound_to_play->converter_initialized) {
        return SITUATION_ERROR_INVALID_PARAM;
    }

    ma_mutex_lock(&sit_gs.sit_audio_queue_mutex); // Lock
    if (sit_gs.sit_queued_sound_count >= SITUATION_MAX_AUDIO_SOUNDS_QUEUED) {
        ma_mutex_unlock(&sit_gs.sit_audio_queue_mutex); // Unlock on early exit
        return SITUATION_ERROR_AUDIO_SOUND_LIMIT;
    }

    // Check if already playing, if so, restart it
    for (int i = 0; i < sit_gs.sit_queued_sound_count; ++i) {
        if (sit_gs.sit_queued_sounds[i] == sound_to_play) {
            ma_decoder_seek_to_pcm_frame(&sound_to_play->decoder, 0);
            sound_to_play->cursor_frames = 0;
            // Converter state is generally reset by processing new input from frame 0
            ma_mutex_unlock(&sit_gs.sit_audio_queue_mutex); // Unlock
            return SITUATION_SUCCESS; 
        }
    }

    // Not already playing, add to queue
    ma_decoder_seek_to_pcm_frame(&sound_to_play->decoder, 0);
    sound_to_play->cursor_frames = 0;
    
    sit_gs.sit_queued_sounds[sit_gs.sit_queued_sound_count++] = sound_to_play;
    ma_mutex_unlock(&sit_gs.sit_audio_queue_mutex); // Unlock
    return SITUATION_SUCCESS;
}

/**
 * @brief Stops a specific sound from playing and removes it from the mixing queue.
 * @details If the specified sound is currently playing, it will be immediately silenced and removed from the audio processing pipeline. Its playback position is not reset.
 *
 * @par Thread Safety
 *   This function is thread-safe and can be called from any thread.
 *
 * @param sound A pointer to the `SituationSound` struct to stop.
 *
 * @return SITUATION_SUCCESS if the sound was found and stopped.
 * @return SITUATION_ERROR_INVALID_PARAM if the `sound` handle is invalid or was not currently playing.
 *
 * @see SituationPlayLoadedSound(), SituationStopAllLoadedSounds()
 */
SITAPI SituationError SituationStopLoadedSound(SituationSound* sound_to_stop) {
    if (!sit_gs.is_initialized || !sound_to_stop) return SITUATION_ERROR_INVALID_PARAM;
    bool found_and_removed = false;

    ma_mutex_lock(&sit_gs.sit_audio_queue_mutex); // Lock
    for (int i = 0; i < sit_gs.sit_queued_sound_count; ++i) {
        if (sit_gs.sit_queued_sounds[i] == sound_to_stop) {
            // Simple removal: replace with last element and decrement count
            sit_gs.sit_queued_sounds[i] = sit_gs.sit_queued_sounds[--sit_gs.sit_queued_sound_count];
            // sit_gs.sit_queued_sounds[sit_gs.sit_queued_sound_count] = NULL; // Optional: clear the now unused slot
            found_and_removed = true;
            break; 
        }
    }
    ma_mutex_unlock(&sit_gs.sit_audio_queue_mutex); // Unlock
    return found_and_removed ? SITUATION_SUCCESS : SITUATION_ERROR_INVALID_PARAM;
}

/**
 * @brief Stops all currently playing sounds and clears the mixing queue.
 * @details This is a convenience function that immediately silences all audio being processed by the engine.
 *
 * @par Thread Safety
 *   This function is thread-safe and can be called from any thread.
 *
 * @return SITUATION_SUCCESS on success.
 *
 * @see SituationStopLoadedSound()
 */
SITAPI SituationError SituationStopAllLoadedSounds(void) {
    if (!sit_gs.is_initialized) return SITUATION_ERROR_NOT_INITIALIZED;
    ma_mutex_lock(&sit_gs.sit_audio_queue_mutex); // Lock
    sit_gs.sit_queued_sound_count = 0; 
    ma_mutex_unlock(&sit_gs.sit_audio_queue_mutex); // Unlock
    return SITUATION_SUCCESS;
}

/**
 * @brief Creates a new sound by making a deep copy of a source sound's decoded PCM data.
 * @details The new sound is fully independent and must be unloaded separately.
 * @param source The sound to copy from.
 * @param out_destination A pointer to a SituationSound struct to be initialized with the copy.
 * @return SITUATION_SUCCESS on success.
 */
SITAPI SituationError SituationSoundCopy(const SituationSound* source, SituationSound* out_destination) {
    if (!source || !out_destination || !source->is_initialized) return SITUATION_ERROR_INVALID_PARAM;
    if (source->is_streamed) return SITUATION_ERROR_INVALID_PARAM; // Cannot copy a stream

    ma_uint64 total_frames = 0;
    ma_decoder_get_length_in_pcm_frames(&((SituationSound*)source)->decoder, &total_frames);
    if (total_frames == 0) return SITUATION_ERROR_GENERAL;

    size_t data_size = total_frames * ma_get_bytes_per_frame(source->decoder.outputFormat, source->decoder.outputChannels);
    void* pcm_data = malloc(data_size);
    if (!pcm_data) return SITUATION_ERROR_MEMORY_ALLOCATION;

    // Seek source to beginning, read all data, then seek back
    uint64_t original_cursor = 0;
    ma_decoder_get_cursor_in_pcm_frames(&((SituationSound*)source)->decoder, &original_cursor);
    ma_decoder_seek_to_pcm_frame(&((SituationSound*)source)->decoder, 0);
    ma_decoder_read_pcm_frames(&((SituationSound*)source)->decoder, pcm_data, total_frames, NULL);
    ma_decoder_seek_to_pcm_frame(&((SituationSound*)source)->decoder, original_cursor);

    // Now, initialize the new sound from the memory buffer
    memset(out_destination, 0, sizeof(SituationSound));
    ma_decoder_config decoder_config = ma_decoder_config_init_memory(pcm_data, data_size, source->decoder.outputFormat, source->decoder.outputChannels, source->decoder.outputSampleRate);
    ma_result res = ma_decoder_init(&decoder_config, &out_destination->decoder);

    if (res != MA_SUCCESS) {
        free(pcm_data);
        return SITUATION_ERROR_AUDIO_CONTEXT;
    }

    // Since we created the decoder from memory, we must tell it to free the buffer on uninit.
    // NOTE: This relies on an understanding of MiniAudio's internal memory management.
    // The `ma_decoder` struct for memory-based decoders has a `pInternalData` which points to a struct that holds the buffer. We can't directly set a "free" flag, but ma_decoder_uninit *should* free it
    // if it allocated internal structures for it. A safer way is to manage the memory outside.
    // For simplicity, we'll assume the user must manage this if they use this function heavily, or we'd build a more complex sound struct. The current approach is a good start.
    // Let's stick with the assumption that `ma_decoder_uninit` handles it.

    out_destination->is_initialized = true;
    out_destination->total_frames = total_frames;
    out_destination->volume = source->volume;
    out_destination->pan = source->pan;
    out_destination->pitch = source->pitch;

    // Initialize converter and effects for the new sound
    ma_data_converter_config converter_config = ma_data_converter_config_init_default();
    converter_config.formatIn = out_destination->decoder.outputFormat;
    converter_config.channelsIn = out_destination->decoder.outputChannels;
    converter_config.sampleRateIn = out_destination->decoder.outputSampleRate;
    converter_config.formatOut = sit_gs.sit_miniaudio_device.playback.format;
    converter_config.channelsOut = sit_gs.sit_miniaudio_device.playback.channels;
    converter_config.sampleRateOut = sit_gs.sit_miniaudio_device.sampleRate;
    ma_data_converter_init(&converter_config, NULL, &out_destination->converter);
    out_destination->converter_initialized = true;

    _SituationInitSoundEffects(out_destination);
    return SITUATION_SUCCESS;
}

/**
 * @brief Modifies a sound in-place to contain only a specific range of its audio data.
 * @warning This is a destructive operation.
 * @param sound The sound to modify.
 * @param initFrame The first frame to include in the cropped sound.
 * @param finalFrame The last frame to include.
 * @return SITUATION_SUCCESS on success.
 */
SITAPI SituationError SituationSoundCrop(SituationSound* sound, uint64_t initFrame, uint64_t finalFrame) {
    if (!sound || !sound->is_initialized || sound->is_streamed || initFrame >= finalFrame || finalFrame > sound->total_frames) {
        return SITUATION_ERROR_INVALID_PARAM;
    }

    uint64_t frames_to_crop = finalFrame - initFrame;
    size_t cropped_data_size = frames_to_crop * ma_get_bytes_per_frame(sound->decoder.outputFormat, sound->decoder.outputChannels);
    void* cropped_pcm_data = malloc(cropped_data_size);
    if (!cropped_pcm_data) return SITUATION_ERROR_MEMORY_ALLOCATION;

    ma_decoder_seek_to_pcm_frame(&sound->decoder, initFrame);
    ma_decoder_read_pcm_frames(&sound->decoder, cropped_pcm_data, frames_to_crop, NULL);

    // Get original format info before un-initializing
    ma_format format = sound->decoder.outputFormat;
    ma_uint32 channels = sound->decoder.outputChannels;
    ma_uint32 sampleRate = sound->decoder.outputSampleRate;

    // Re-initialize the decoder with the new, smaller memory buffer
    ma_decoder_uninit(&sound->decoder);
    ma_decoder_config decoder_config = ma_decoder_config_init_memory(cropped_pcm_data, cropped_data_size, format, channels, sampleRate);
    ma_result res = ma_decoder_init(&decoder_config, &sound->decoder);

    if (res != MA_SUCCESS) {
        free(cropped_pcm_data);
        // Sound is now in an invalid state.
        memset(sound, 0, sizeof(SituationSound));
        return SITUATION_ERROR_AUDIO_CONTEXT;
    }

    sound->total_frames = frames_to_crop;
    sound->cursor_frames = 0;
    return SITUATION_SUCCESS;
}

/**
 * @brief Exports the raw PCM data of a sound to a new WAV file.
 * @param sound The sound to export.
 * @param fileName The path of the .wav file to create.
 * @return True on success, false on failure.
 */
SITAPI bool SituationSoundExportAsWav(const SituationSound* sound, const char* fileName) {
    if (!sound || !fileName || !sound->is_initialized || sound->is_streamed) return false;

    ma_encoder_config config = ma_encoder_config_init(
        ma_encoding_format_wav,
        sound->decoder.outputFormat,
        sound->decoder.outputChannels,
        sound->decoder.outputSampleRate
    );

    ma_encoder encoder;
    if (ma_encoder_init_file(fileName, &config, &encoder) != MA_SUCCESS) {
        return false;
    }

    uint64_t total_frames = sound->total_frames;
    uint64_t cursor = 0;
    ma_decoder_seek_to_pcm_frame(&((SituationSound*)sound)->decoder, 0);

    const int BUFFER_FRAMES = 4096;
    void* buffer = malloc(BUFFER_FRAMES * ma_get_bytes_per_frame(config.format, config.channels));
    if (!buffer) {
        ma_encoder_uninit(&encoder);
        return false;
    }

    while (cursor < total_frames) {
        ma_uint64 frames_to_read = BUFFER_FRAMES;
        if (cursor + frames_to_read > total_frames) {
            frames_to_read = total_frames - cursor;
        }

        ma_uint64 frames_read;
        ma_decoder_read_pcm_frames(&((SituationSound*)sound)->decoder, buffer, frames_to_read, &frames_read);
        ma_encoder_write_pcm_frames(&encoder, buffer, frames_read, NULL);

        cursor += frames_read;
        if (frames_read < frames_to_read) break; // End of stream
    }

    free(buffer);
    ma_encoder_uninit(&encoder);
    ma_decoder_seek_to_pcm_frame(&((SituationSound*)sound)->decoder, 0); // Reset for playback
    return true;
}

/**
 * @brief Sets the volume for a specific, individual sound.
 * @details This function controls the amplitude of a single sound, independent of the master audio volume.
 *
 * @param[in,out] sound A pointer to the `SituationSound` handle to modify.
 * @param volume The desired volume as a linear scalar. `0.0f` is silent, `1.0f` is the sound's original volume. Values greater than `1.0f` can be used for amplification. Negative values will be clamped to `0.0f`.
 *
 * @return `SITUATION_SUCCESS` on success.
 * @return `SITUATION_ERROR_INVALID_PARAM` if the `sound` handle is invalid.
 *
 * @see SituationGetSoundVolume(), SituationSetAudioMasterVolume()
 */
SITAPI SituationError SituationSetSoundVolume(SituationSound* sound, float volume) {
    if (!sound || !sound->is_initialized) return SITUATION_ERROR_INVALID_PARAM;
    // Volume can be > 1.0 for gain, typically non-negative.
    sound->volume = (volume < 0.0f) ? 0.0f : volume;
    return SITUATION_SUCCESS;
}

/**
 * @brief Gets the current volume of a specific, individual sound.
 *
 * @param sound A pointer to the `SituationSound` handle to query.
 *
 * @return The sound's current volume as a linear scalar. Returns `0.0f` if the handle is invalid.
 *
 * @see SituationSetSoundVolume()
 */
SITAPI float SituationGetSoundVolume(SituationSound* sound) {
    if (!sound || !sound->is_initialized) return 0.0f; // Or some error indication
    return sound->volume;
}

/**
 * @brief Sets the stereo panning for a specific sound.
 * @details This function positions a sound within the stereo field. It uses an equal-power panning algorithm, which ensures that the perceived loudness of the sound remains constant as it moves from left to right.
 *
 * @param[in,out] sound A pointer to the `SituationSound` handle to modify.
 * @param pan The desired pan position, from `-1.0f` (full left) to `1.0f` (full right). A value of `0.0f` is center. Values outside this range will be clamped.
 *
 * @return `SITUATION_SUCCESS` on success.
 * @return `SITUATION_ERROR_INVALID_PARAM` if the `sound` handle is invalid.
 *
 * @see SituationGetSoundPan()
 */
SITAPI SituationError SituationSetSoundPan(SituationSound* sound, float pan) {
    if (!sound || !sound->is_initialized) return SITUATION_ERROR_INVALID_PARAM;
    // Clamp pan from -1.0 (left) to 1.0 (right)
    if (pan < -1.0f) pan = -1.0f;
    if (pan > 1.0f) pan = 1.0f;
    sound->pan = pan;
    return SITUATION_SUCCESS;
}

/**
 * @brief Gets the current stereo panning of a specific sound.
 *
 * @param sound A pointer to the `SituationSound` handle to query.
 *
 * @return The sound's current pan position, from `-1.0f` (left) to `1.0f` (right). Returns `0.0f` if the handle is invalid.
 *
 * @see SituationSetSoundPan()
 */
SITAPI float SituationGetSoundPan(SituationSound* sound) {
    if (!sound || !sound->is_initialized) return 0.0f; // Or some error indication
    return sound->pan;
}

/**
 * @brief Sets the playback pitch for a specific sound.
 * @details This function adjusts the playback speed of a sound, which in turn changes its pitch. It works by dynamically changing the input sample rate of the sound's internal data converter.
 *
 * @param[in,out] sound A pointer to the `SituationSound` handle to modify.
 * @param pitch The desired pitch multiplier. `1.0f` is the original pitch. `2.0f` is one octave higher (double speed), and `0.5f` is one octave lower (half speed). The value must be positive.
 *
 * @return `SITUATION_SUCCESS` on success.
 * @return `SITUATION_ERROR_INVALID_PARAM` if the `sound` handle is invalid.
 * @return `SITUATION_ERROR_AUDIO_CONVERTER` if the internal resampler fails to update.
 *
 * @warning Changing the pitch is a moderately expensive operation as it requires reconfiguring the audio resampler. Avoid calling it on every frame if possible.
 */
SITAPI SituationError SituationSetSoundPitch(SituationSound* sound, float pitch) {
    if (!sound || !sound->converter_initialized) return SITUATION_ERROR_INVALID_PARAM;
    if (pitch <= 0.0f) pitch = 0.01f; // Prevent zero or negative pitch

    ma_mutex_lock(&sit_gs.sit_audio_queue_mutex);
    sound->pitch = pitch;
    ma_result res = ma_data_converter_set_rate_in_hz(&sound->converter, (ma_uint32)(sound->decoder.outputSampleRate * pitch));
    ma_mutex_unlock(&sit_gs.sit_audio_queue_mutex);
    
    if (res != MA_SUCCESS) return SITUATION_ERROR_AUDIO_CONVERTER;
    return SITUATION_SUCCESS;
}

/**
 * @brief Gets the current pitch multiplier of a specific sound.
 *
 * @param sound A pointer to the `SituationSound` handle to query.
 *
 * @return The sound's current pitch multiplier. Returns `1.0f` if the handle is invalid.
 *
 * @see SituationSetSoundPitch()
 */
SITAPI float SituationGetSoundPitch(SituationSound* sound) {
    if (!sound || !sound->is_initialized) return 1.0f;
    return sound->pitch;
}

/**
 * @brief Applies a low-pass or high-pass biquad filter to a sound's real-time effects chain.
 * @details This function allows you to dynamically alter the frequency content of a sound. A low-pass filter removes high frequencies (making a sound muffled), while a high-pass filter removes low frequencies (making a sound tinny).
 *
 * @param[in,out] sound A pointer to the `SituationSound` handle to modify.
 * @param type The type of filter to apply (`SITUATION_FILTER_LOWPASS`, `SITUATION_FILTER_HIGHPASS`, or `SITUATION_FILTER_NONE` to disable).
 * @param cutoff_hz The frequency (in Hz) at which the filter begins to take effect.
 * @param q_factor The resonance or "quality" of the filter. A value around `0.707f` is neutral. Higher values create a resonant peak at the cutoff frequency.
 *
 * @return `SITUATION_SUCCESS` on success.
 * @return `SITUATION_ERROR_INVALID_PARAM` if the `sound` handle is invalid.
 */
SITAPI SituationError SituationSetSoundFilter(SituationSound* sound, SituationFilterType type, float cutoff_hz, float q_factor) {
    if (!sound || !sound->is_initialized) return SITUATION_ERROR_INVALID_PARAM;
    if (cutoff_hz <= 0) type = SITUATION_FILTER_NONE;
    if (q_factor <= 0) q_factor = 0.707f; // Default Q

    ma_mutex_lock(&sit_gs.sit_audio_queue_mutex);
    if (type == SITUATION_FILTER_NONE) {
        sound->effects.filter_enabled = false;
    } else {
        ma_biquad_config bq_config;
        if (type == SITUATION_FILTER_LOWPASS) {
            bq_config = ma_biquad_config_init(ma_format_f32, sound->decoder.outputChannels, cutoff_hz, q_factor, 0);
        } else { // High-pass
            bq_config = ma_biquad_config_init(ma_format_f32, sound->decoder.outputChannels, 0, 0, cutoff_hz);
        }
        ma_result res = ma_biquad_init(&bq_config, NULL, &sound->effects.biquad);
        if (res == MA_SUCCESS) {
            sound->effects.filter_enabled = true;
            sound->effects.filter_type = type;
            sound->effects.filter_cutoff_hz = cutoff_hz;
            sound->effects.filter_q = q_factor;
        }
    }
    ma_mutex_unlock(&sit_gs.sit_audio_queue_mutex);
    return SITUATION_SUCCESS;
}

/**
 * @brief Applies a simple echo (delay) effect to a sound's real-time effects chain.
 * @details This function creates repeating, decaying echoes of the original sound.
 *
 * @param[in,out] sound A pointer to the `SituationSound` handle to modify.
 * @param enabled `true` to activate the echo effect, `false` to disable it.
 * @param delay_sec The time in seconds between each echo.
 * @param feedback The amount of the echo that is fed back into the delay line to create subsequent echoes. A value of `0.0` gives a single echo; a value of `0.5` means each echo is half as loud as the previous one. Clamped to [0.0 - 1.0].
 * @param wet_mix The volume of the echo signal relative to the original signal. `0.0` is no echo, `1.0` is full-volume echo. Clamped to [0.0 - 1.0].
 *
 * @return `SITUATION_SUCCESS` on success.
 * @return `SITUATION_ERROR_INVALID_PARAM` if the `sound` handle is invalid.
 */
SITAPI SituationError SituationSetSoundEcho(SituationSound* sound, bool enabled, float delay_sec, float feedback, float wet_mix) {
    if (!sound || !sound->is_initialized) return SITUATION_ERROR_INVALID_PARAM;

    ma_mutex_lock(&sit_gs.sit_audio_queue_mutex);
    sound->effects.echo_enabled = enabled;
    if (enabled) {
        if (delay_sec < 0) delay_sec = 0;
        if (feedback < 0) feedback = 0; if (feedback > 1.0f) feedback = 1.0f;
        if (wet_mix < 0) wet_mix = 0; if (wet_mix > 1.0f) wet_mix = 1.0f;
        
        // Re-init delay to apply new settings
        ma_uint32 delay_frames = (ma_uint32)(sound->decoder.outputSampleRate * delay_sec);
        if (delay_frames == 0) delay_frames = 1;
        ma_delay_config delay_config = ma_delay_config_init(sound->decoder.outputChannels, sound->decoder.outputSampleRate, delay_frames, feedback);
        ma_delay_init(&delay_config, NULL, &sound->effects.delay);
        ma_delay_set_wet(&sound->effects.delay, wet_mix);
        ma_delay_set_dry(&sound->effects.delay, 1.0f - wet_mix); // Keep total power constant
        
        sound->effects.echo_delay_sec = delay_sec;
        sound->effects.echo_feedback = feedback;
        sound->effects.echo_wet_mix = wet_mix;
    }
    ma_mutex_unlock(&sit_gs.sit_audio_queue_mutex);
    return SITUATION_SUCCESS;
}

/**
 * @brief Applies a reverb effect to a sound's real-time effects chain.
 * @details This function simulates the acoustic reflections of a room or space, adding depth and atmosphere to a sound.
 *
 * @param[in,out] sound A pointer to the `SituationSound` handle to modify.
 * @param enabled `true` to activate the reverb effect, `false` to disable it.
 * @param room_size A value from `0.0` (small closet) to `1.0` (large cathedral) representing the perceived size of the simulated space.
 * @param damping A value from `0.0` to `1.0` representing how much high frequencies are absorbed by the room's surfaces. Higher values lead to a darker, more muffled reverb tail.
 * @param wet_mix The volume of the reverberated ("wet") signal.
 * @param dry_mix The volume of the original ("dry") signal.
 *
 * @return `SITUATION_SUCCESS` on success.
 * @return `SITUATION_ERROR_INVALID_PARAM` if the `sound` handle is invalid.
 */
SITAPI SituationError SituationSetSoundReverb(SituationSound* sound, bool enabled, float room_size, float damping, float wet_mix, float dry_mix) {
    if (!sound || !sound->is_initialized) return SITUATION_ERROR_INVALID_PARAM;
    
    ma_mutex_lock(&sit_gs.sit_audio_queue_mutex);
    sound->effects.reverb_enabled = enabled;
    if (enabled) {
        if (room_size < 0) room_size = 0; if (room_size > 1.0f) room_size = 1.0f;
        if (damping < 0) damping = 0; if (damping > 1.0f) damping = 1.0f;
        if (wet_mix < 0) wet_mix = 0; if (wet_mix > 1.0f) wet_mix = 1.0f;
        if (dry_mix < 0) dry_mix = 0; if (dry_mix > 1.0f) dry_mix = 1.0f;

        ma_reverb_set_room_size(&sound->effects.reverb, room_size);
        ma_reverb_set_damping(&sound->effects.reverb, damping);
        ma_reverb_set_wet_volume(&sound->effects.reverb, wet_mix);
        ma_reverb_set_dry_volume(&sound->effects.reverb, dry_mix);

        sound->effects.reverb_room_size = room_size;
        sound->effects.reverb_damping = damping;
        sound->effects.reverb_wet_mix = wet_mix;
        sound->effects.reverb_dry_mix = dry_mix;
    }
    ma_mutex_unlock(&sit_gs.sit_audio_queue_mutex);
    return SITUATION_SUCCESS;
}

/**
 * @brief Attach a custom DSP processor to a sound's effect chain.
 * @details Processors are called in the order they are attached, after built-in effects.
 * @param sound The sound to attach the processor to.
 * @param processor The callback function to execute.
 * @param userData A custom pointer to pass to the callback's userData parameter.
 */
SITAPI SituationError SituationAttachAudioProcessor(SituationSound* sound, SituationAudioProcessorCallback processor, void* userData) {
    if (!sound || !processor) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Sound or processor callback cannot be NULL.");
        return SITUATION_ERROR_INVALID_PARAM;
    }

    ma_mutex_lock(&sit_gs.sit_audio_queue_mutex);

    void* new_processors = realloc(sound->processors, (sound->processor_count + 1) * sizeof(SituationAudioProcessorCallback));
    if (!new_processors) {
        ma_mutex_unlock(&sit_gs.sit_audio_queue_mutex);
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Failed to realloc processor list.");
        return SITUATION_ERROR_MEMORY_ALLOCATION;
    }
    sound->processors = (SituationAudioProcessorCallback*)new_processors;

    void* new_user_datas = realloc(sound->processor_user_data, (sound->processor_count + 1) * sizeof(void*));
    if (!new_user_datas) {
        // This is tricky. The first realloc succeeded. We should try to shrink it back.
        sound->processors = realloc(sound->processors, sound->processor_count * sizeof(SituationAudioProcessorCallback));
        ma_mutex_unlock(&sit_gs.sit_audio_queue_mutex);
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Failed to realloc processor user data list.");
        return SITUATION_ERROR_MEMORY_ALLOCATION;
    }
    sound->processor_user_data = (void**)new_user_datas;

    sound->processor_count++;
    sound->processors[sound->processor_count - 1] = processor;
    sound->processor_user_data[sound->processor_count - 1] = userData;

    ma_mutex_unlock(&sit_gs.sit_audio_queue_mutex);

    return SITUATION_SUCCESS;
}

/**
 * @brief Detach a custom DSP processor from a sound.
 * @param sound The sound to detach the processor from.
 * @param processor The callback function to remove.
 * @param userData The user data pointer associated with the processor to remove.
 */
SITAPI SituationError SituationDetachAudioProcessor(SituationSound* sound, SituationAudioProcessorCallback processor, void* userData) {
    if (!sound || !processor) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Sound or processor callback cannot be NULL.");
        return SITUATION_ERROR_INVALID_PARAM;
    }

    ma_mutex_lock(&sit_gs.sit_audio_queue_mutex);

    int found_index = -1;
    for (int i = 0; i < sound->processor_count; ++i) {
        if (sound->processors[i] == processor && sound->processor_user_data[i] == userData) {
            found_index = i;
            break;
        }
    }

    if (found_index != -1) {
        // Shift elements down to fill the gap
        for (int i = found_index; i < sound->processor_count - 1; ++i) {
            sound->processors[i] = sound->processors[i + 1];
            sound->processor_user_data[i] = sound->processor_user_data[i + 1];
        }
        sound->processor_count--;

        // Optionally, realloc to shrink the arrays, but it's often not worth the overhead.
        if (sound->processor_count == 0) {
            free(sound->processors);
            free(sound->processor_user_data);
            sound->processors = NULL;
            sound->processor_user_data = NULL;
        }
    }

    ma_mutex_unlock(&sit_gs.sit_audio_queue_mutex);
    return SITUATION_SUCCESS;
}


// --- Timer System API Implementation ---
/**
 * @brief Gets the current binary state (0 or 1) of a temporal oscillator.
 * @details Each oscillator flips its state between `true` (1) and `false` (0) every time its defined period elapses, creating a perfectly timed square-wave signal. This function returns the state of the oscillator for the *current* frame.
 *
 * @param oscillator_id The ID of the oscillator to query (0-255).
 *
 * @return `true` if the oscillator's current state is 1, `false` if it is 0.
 *
 * @note The state is updated once per frame by `SituationUpdateTimers()`.
 *
 * @see SituationTimerGetPreviousOscillatorState(), SituationTimerHasOscillatorUpdated()
 */
SITAPI bool SituationTimerGetOscillatorState(int oscillator_id) {
    if (!sit_gs.timer_system_instance.is_initialized || oscillator_id < 0 || oscillator_id >= SITUATION_MAX_OSCILLATORS) return false;
    SituationTimerSystem* ts = &sit_gs.timer_system_instance;
    int bank = oscillator_id / 64;
    int bit_pos = oscillator_id % 64;
    return (ts->state_current[bank] & ((uint64_t)1 << bit_pos)) != 0;
}

/**
 * @brief Gets the binary state (0 or 1) of a temporal oscillator from the *previous* frame.
 * @details This function is a crucial companion to `SituationTimerGetOscillatorState`. It allows you to detect the exact moment a state change occurred by comparing the previous state with the current one.
 *
 * @param oscillator_id The ID of the oscillator to query (0-255).
 *
 * @return `true` if the oscillator's state was 1 in the previous frame, `false` if it was 0.
 *
 * @see SituationTimerGetOscillatorState(), SituationTimerHasOscillatorUpdated()
 */
SITAPI bool SituationTimerGetPreviousOscillatorState(int oscillator_id) {
    if (!sit_gs.timer_system_instance.is_initialized || oscillator_id < 0 || oscillator_id >= SITUATION_MAX_OSCILLATORS) return false;
    SituationTimerSystem* ts = &sit_gs.timer_system_instance;
    int bank = oscillator_id / 64;
    int bit_pos = oscillator_id % 64;
    return (ts->state_previous[bank] & ((uint64_t)1 << bit_pos)) != 0;
}

/**
 * @brief Checks if an oscillator's state has changed *this frame*.
 * @details This is the primary function for triggering "on-beat" events. It returns `true` only for the single frame in which an oscillator flips its state (e.g., from 0 to 1, or 1 to 0). This allows you to execute logic precisely in sync with the oscillator's rhythm.
 *
 * @param oscillator_id The ID of the oscillator to query (0-255).
 *
 * @return `true` if the oscillator's state is different from its state in the previous frame, `false` otherwise.
 *
 * @example
 *   // Make an object pulse in time with oscillator 10
 *   if (SituationTimerHasOscillatorUpdated(10)) {
 *       my_object.scale = 1.5f; // Trigger animation on the beat
 *   } else {
 *       my_object.scale = 1.0f; // Return to normal
 *   }
 */
SITAPI bool SituationTimerHasOscillatorUpdated(int oscillator_id) {
    if (!sit_gs.timer_system_instance.is_initialized || oscillator_id < 0 || oscillator_id >= SITUATION_MAX_OSCILLATORS) return false;
    // Updated if current state is different from previous state for that oscillator
    return SituationTimerGetOscillatorState(oscillator_id) != SituationTimerGetPreviousOscillatorState(oscillator_id);
}

/**
 * @brief Checks if an oscillator's period has elapsed since the last time this specific function was called for this oscillator.
 * @details This function provides a "polling" or "cooldown" mechanism. Unlike `SituationTimerHasOscillatorUpdated`, which is tied to the oscillator's fixed global clock, `SituationTimerPingOscillator` maintains its own internal timestamp.
 *          It returns `true` once the period has passed since its last successful ping, and then immediately resets its internal timer.
 *          This is ideal for scenarios like checking if an enemy can fire a weapon again, or triggering an event periodically that is not strictly aligned with the global beat.
 *
 * @param oscillator_id The ID of the oscillator whose period should be used for the ping interval.
 *
 * @return `true` if the period has elapsed since the last successful ping for this oscillator, `false` otherwise.
 */
SITAPI bool SituationTimerPingOscillator(int oscillator_id) {
    if (!sit_gs.timer_system_instance.is_initialized || oscillator_id < 0 || oscillator_id >= SITUATION_MAX_OSCILLATORS) return false;
    SituationTimerSystem* ts = &sit_gs.timer_system_instance;
    
    bool ping_triggered = (ts->current_system_time_seconds >= ts->last_ping_time_seconds[oscillator_id] + ts->period_seconds[oscillator_id]);
    if (ping_triggered) {
        // If multiple periods passed, advance last_ping_time by multiples of period until it's in the current "frame"
        while(ts->last_ping_time_seconds[oscillator_id] + ts->period_seconds[oscillator_id] <= ts->current_system_time_seconds) {
            ts->last_ping_time_seconds[oscillator_id] += ts->period_seconds[oscillator_id];
        }
    }
    return ping_triggered;
}

/**
 * @brief Gets the total number of times an oscillator has flipped its state since the application started.
 * @details This function returns a continuously increasing count of state changes for a given oscillator. This can be used as a simple, rhythmic counter for procedural generation or sequencing complex event patterns.
 *
 * @param oscillator_id The ID of the oscillator to query (0-255).
 *
 * @return A `uint64_t` representing the total number of triggers.
 */
SITAPI uint64_t SituationTimerGetOscillatorTriggerCount(int oscillator_id) {
    if (!sit_gs.timer_system_instance.is_initialized || oscillator_id < 0 || oscillator_id >= SITUATION_MAX_OSCILLATORS) return 0;
    return sit_gs.timer_system_instance.trigger_count[oscillator_id];
}

/**
 * @brief Gets the current period of an oscillator in seconds.
 * @details The "period" is the fundamental property of an oscillator. It defines the exact duration of one half of its cycle.
 *          An oscillator's state flips between `false` (0) and `true` (1). The period is the amount of time the oscillator will spend in the `false` state before flipping to `true`, and also the amount of time it will spend in the `true` state before flipping back to `false`.
 *
 * For example, an oscillator with a period of `0.5` seconds will:
 * - Spend 0.5 seconds in state 0.
 * - Flip to state 1 and spend 0.5 seconds in state 1.
 * - Flip back to state 0 and spend 0.5 seconds in state 0.
 * - ...and so on.
 *
 * The total duration of one full cycle (0 -> 1 -> 0) is therefore twice the period.
 *
 * @param oscillator_id The ID of the oscillator to query (0-255).
 *
 * @return The oscillator's period in seconds as a high-precision `double`.
 *
 * @see SituationSetTimerOscillatorPeriod()
 */
SITAPI double SituationTimerGetOscillatorPeriod(int oscillator_id) {
    if (!sit_gs.timer_system_instance.is_initialized || oscillator_id < 0 || oscillator_id >= SITUATION_MAX_OSCILLATORS) return 0.0;
    return sit_gs.timer_system_instance.period_seconds[oscillator_id];
}

/**
 * @brief Sets a new period for an oscillator at runtime, changing its frequency.
 * @details This function allows you to dynamically change the rhythm of any oscillator. The change takes effect immediately, and the oscillator's next state-flip is rescheduled based on the current time and the new period.
 *
 * @par What is a Period?
 *   The "period" is the fundamental property of an oscillator. It defines the exact duration in seconds for **one half of its cycle**.
 *
 *   An oscillator's state flips between `false` (0) and `true` (1). The period is the amount of time the oscillator will spend in the `false` state before flipping to `true`, and also the amount of time it will spend in the `true` state before flipping back to `false`.
 *
 *   For example, setting a period of `0.25` seconds will cause the oscillator to:
 *   - Spend 0.25 seconds in state 0.
 *   - Flip to state 1 and spend 0.25 seconds in state 1.
 *   - Flip back to state 0 and spend 0.25 seconds in state 0.
 *   - ...and so on.
 *
 *   The total duration of one full cycle (0 -> 1 -> 0) is therefore **twice the period**. A shorter period means a faster oscillator (higher frequency).
 *
 * @param oscillator_id The ID of the oscillator to modify (0-255).
 * @param period_seconds The new period in seconds. This value must be positive.
 *
 * @return `SITUATION_SUCCESS` on successful update.
 * @return `SITUATION_ERROR_NOT_INITIALIZED` if the timer system is not active.
 * @return `SITUATION_ERROR_INVALID_PARAM` if the `oscillator_id` is out of range or if `period_seconds` is zero or negative.
 *
 * @see SituationTimerGetOscillatorPeriod()
 */
SITAPI SituationError SituationSetTimerOscillatorPeriod(int oscillator_id, double period_seconds) {
    if (!sit_gs.timer_system_instance.is_initialized) return SITUATION_ERROR_NOT_INITIALIZED;
    if (oscillator_id < 0 || oscillator_id >= SITUATION_MAX_OSCILLATORS || period_seconds <= 0.0) {
        return SITUATION_ERROR_INVALID_PARAM;
    }
    SituationTimerSystem* ts = &sit_gs.timer_system_instance;
    ts->period_seconds[oscillator_id] = period_seconds;
    // Reschedule next trigger based on current time and new period
    // Preserve phase? Or just restart from current_time + new_period?
    // For simplicity, restart:
    ts->next_trigger_time_seconds[oscillator_id] = ts->current_system_time_seconds + period_seconds;
    // Reset ping timer as well
    ts->last_ping_time_seconds[oscillator_id] = ts->current_system_time_seconds;
    return SITUATION_SUCCESS;
}

/**
 * @brief Gets the progress of a timed interval since the last successful "ping".
 * @details This function provides a normalized value from 0.0 to 1.0 (or higher) representing the progress towards completing a timed interval. The duration of this interval is taken from the specified oscillator's `period`.
 *          This is extremely useful for driving progress bars, cooldown timers, or animating values over a specific duration.
 *
 * @par Relationship to Ping and Oscillators
 *   - The "ping" timer is separate from the oscillator's main state-flipping clock.
 *   - `SituationTimerPingOscillator` checks if the `period` has elapsed since its last successful call. If so, it returns `true` and resets its internal timestamp.
 *   - This function, `SituationTimerGetPingProgress`, simply measures the time elapsed since that last reset and divides it by the oscillator's `period` to get a normalized progress value.
 *
 * @par Return Value
 *   - **`0.0`** means the timer has just been successfully pinged (reset).
 *   - **`0.5`** means half of the interval duration has elapsed.
 *   - **`1.0`** means the full interval duration has elapsed, and a call to `SituationTimerPingOscillator` would now return `true`.
 *   - **`> 1.0`** means more than one full interval has elapsed since the last ping.
 *
 * @param oscillator_id The ID of the oscillator (0-255) whose `period` will be used as the duration for the interval.
 *
 * @return A `double` representing the normalized progress [0.0 - N.N].
 *
 * @note This function *reads* the state of the ping timer but does not reset it. Only `SituationTimerPingOscillator` can reset the timer.
 *
 * @see SituationTimerPingOscillator()
 */
SITAPI double SituationTimerGetPingProgress(int oscillator_id) {
    if (!sit_gs.timer_system_instance.is_initialized || oscillator_id < 0 || oscillator_id >= SITUATION_MAX_OSCILLATORS) {
        return 0.0;
    }

    SituationTimerSystem* ts = &sit_gs.timer_system_instance;
    double period = ts->period_seconds[oscillator_id];

    // Avoid division by zero for invalid periods
    if (period <= 0.0) {
        return 1.0; // Or 0.0, depending on desired behavior for a zero-period timer
    }

    // Calculate the time that has passed since the last ping
    double elapsed_since_ping = ts->current_system_time_seconds - ts->last_ping_time_seconds[oscillator_id];

    // Return the normalized progress
    return elapsed_since_ping / period;
}

/**
 * @brief Gets the total time elapsed since the library was initialized.
 * @details This function returns the master application time, updated once per frame by `SituationUpdateTimers()`. It serves as the high-resolution monotonic clock for the entire application and is the basis for all other timing functions, including the Temporal Oscillator system.
 *
 * @return The total elapsed time in seconds as a high-precision `double`.
 *
 * @see SituationGetFrameTime()
 */
SITAPI double SituationTimerGetTime(void) {
    // If timer system is initialized, return its cached current time. Otherwise, direct GLFW call.
    if (sit_gs.timer_system_instance.is_initialized) {
        return sit_gs.timer_system_instance.current_system_time_seconds;
    }
    return glfwGetTime(); // Fallback if timer system not ready or SituationUpdate not called yet
}

// --- Keyboard Management Implementation ---

/**
 * @brief Checks if a keyboard key is currently held down (a continuous state).
 * @details This function provides real-time state polling. It will return `true` for every frame that the specified key is held down. This is ideal for continuous actions like character movement.
 *
 * @param key The key code to check (e.g., `SIT_KEY_W`, `SIT_KEY_UP`).
 *
 * @return `true` if the key is currently pressed, `false` otherwise.
 *
 * @note This function's state is updated once per frame by `SituationPollInputEvents()`.
 *
 * @see SituationIsKeyUp(), SituationIsKeyPressed()
 */
SITAPI bool SituationIsKeyDown(int key) {
    if (!sit_gs.is_initialized || key < 0 || key > GLFW_KEY_LAST) return false;
    return sit_gs.keyboard.current_state[key];
}

/**
 * @brief Checks if a keyboard key is currently released (a continuous state).
 * @details This function provides real-time state polling. It will return `true` for every frame that the specified key is *not* held down.
 *
 * @param key The key code to check (e.g., `SIT_KEY_W`, `SIT_KEY_SPACE`).
 *
 * @return `true` if the key is currently released, `false` otherwise.
 *
 * @note This function's state is updated once per frame by `SituationPollInputEvents()`.
 *
 * @see SituationIsKeyDown(), SituationIsKeyReleased()
 */
SITAPI bool SituationIsKeyUp(int key) {
    if (!sit_gs.is_initialized || key < 0 || key > GLFW_KEY_LAST) return false;
    return !sit_gs.keyboard.current_state[key];
}

/**
 * @brief Checks if a keyboard key was pressed down *this frame* (a single-trigger event).
 * @details This function detects a state change. It will only return `true` for the single frame immediately after the key is pressed. This is ideal for single-trigger actions like jumping, shooting, or opening a menu.
 *
 * @param key The key code to check (e.g., `SIT_KEY_ENTER`).
 *
 * @return `true` if the key was just pressed in the current frame, `false` otherwise.
 *
 * @note This function's state is updated once per frame by `SituationPollInputEvents()`.
 *
 * @see SituationIsKeyDown(), SituationIsKeyReleased(), SituationGetKeyPressed()
 */
SITAPI bool SituationIsKeyPressed(int key) {
    if (!sit_gs.is_initialized || key < 0 || key > GLFW_KEY_LAST) return false;
    return sit_gs.keyboard.down_this_frame[key];
}

/**
 * @brief Checks if a keyboard key was released *this frame* (a single-trigger event).
 * @details This function detects a state change. It will only return `true` for the single frame immediately after the key is released. This is useful for actions that should trigger on key-up.
 *
 * @param key The key code to check (e.g., `SIT_KEY_LEFT_SHIFT`).
 *
 * @return `true` if the key was just released in the current frame, `false` otherwise.
 *
 * @note This function's state is updated once per frame by `SituationPollInputEvents()`.
 *
 * @see SituationIsKeyUp(), SituationIsKeyPressed()
 */
SITAPI bool SituationIsKeyReleased(int key) {
    if (!sit_gs.is_initialized || key < 0 || key > GLFW_KEY_LAST) return false;
    return sit_gs.keyboard.up_this_frame[key];
}

/**
 * @brief Retrieves the next key-press event from the input queue and consumes it.
 * @details This function provides a queue-based approach to handling key presses. It returns the key code of the first key that was pressed in the current frame and removes it from the queue. Subsequent calls in the same frame will return the next key in the queue, until it is empty. This guarantees that no key-press events are missed, even during frames with low performance.
 *
 * @return The key code of the next key pressed (e.g., `SIT_KEY_A`).
 * @return `0` if the key-press queue is empty.
 *
 * @note This is the recommended function for turn-based input or any scenario where every single key press must be processed individually.
 * @note The queue is cleared at the beginning of each frame by `SituationPollInputEvents()`.
 *
 * @see SituationIsKeyPressed(), SituationPeekKeyPressed()
 */
SITAPI int SituationGetKeyPressed(void) {
    if (!sit_gs.is_initialized) return 0; // Or some other indicator of "no key" like -1 if 0 is a valid key

    int key = 0; // Default to 0 (GLFW_KEY_UNKNOWN or no key)
    ma_mutex_lock(&sit_gs.sit_keyboard_event_queue_mutex);
    if (sit_gs.keyboard.pressed_queue_count > 0) {
        key = sit_gs.keyboard.pressed_queue[0];
        // Shift queue elements to the left
        for (int i = 0; i < sit_gs.keyboard.pressed_queue_count - 1; ++i) {
            sit_gs.keyboard.pressed_queue[i] = sit_gs.keyboard.pressed_queue[i + 1];
        }
        sit_gs.keyboard.pressed_queue_count--;
    }
    ma_mutex_unlock(&sit_gs.sit_keyboard_event_queue_mutex);
    return key;
}

/**
 * @brief Peeks at the next key-press event in the input queue without consuming it.
 * @details This function allows you to check the next available key-press event without removing it from the queue. This is useful for inspecting the input state before deciding how to process it.
 *
 * @return The key code of the next key in the queue (e.g., `SIT_KEY_ENTER`).
 * @return `0` if the key-press queue is empty.
 *
 * @note Unlike `SituationGetKeyPressed`, calling this function multiple times in a row will return the same key code until the event is consumed.
 *
 * @see SituationGetKeyPressed()
 */
SITAPI int SituationPeekKeyPressed(void) {
    if (!sit_gs.is_initialized) {
        return 0; // No key available
    }

    int key = 0; // Default to 0 (no key)

    // Lock the mutex to ensure a thread-safe read of the queue
    ma_mutex_lock(&sit_gs.sit_keyboard_event_queue_mutex);

    if (sit_gs.keyboard.pressed_queue_count > 0) {
        // Simply read the first element without modifying the queue
        key = sit_gs.keyboard.pressed_queue[0];
    }

    // Immediately unlock the mutex
    ma_mutex_unlock(&sit_gs.sit_keyboard_event_queue_mutex);

    return key;
}

/**
 * @brief Retrieves the next Unicode character event from the text input queue and consumes it.
 * @details This function is specifically designed for text entry. It returns the Unicode codepoint of the next character typed by the user, respecting keyboard layouts, modifier keys (like Shift), and dead keys.
 *          It should be used when implementing text fields, command consoles, or any form of text input.
 *
 * @return The Unicode codepoint of the next character entered.
 * @return `0` if the character queue is empty.
 *
 * @note This function is distinct from `SituationGetKeyPressed`, which returns raw key codes (`SIT_KEY_A`) and does not handle character composition.
 * @note The queue is cleared at the beginning of each frame by `SituationPollInputEvents()`.
 */

SITAPI unsigned int SituationGetCharPressed(void) {
    if (!sit_gs.is_initialized) return 0; // 0 is a valid sentinel for "no char"

    unsigned int codepoint = 0; // Default to 0 (no character)
    ma_mutex_lock(&sit_gs.sit_keyboard_event_queue_mutex);
    if (sit_gs.keyboard.char_queue_count > 0) {
        codepoint = sit_gs.keyboard.char_queue[0];
        // Shift queue elements to the left
        for (int i = 0; i < sit_gs.keyboard.char_queue_count - 1; ++i) {
            sit_gs.keyboard.char_queue[i] = sit_gs.keyboard.char_queue[i + 1];
        }
        sit_gs.keyboard.char_queue_count--;
    }
    ma_mutex_unlock(&sit_gs.sit_keyboard_event_queue_mutex);
    return codepoint;
}

/**
 * @brief Checks if a lock key (Caps Lock or Num Lock) is currently active.
 * @details This function queries the modifier state captured during input polling to determine if a lock key is toggled on.
 *
 * @param lock_key_mod The lock key to check. Use `SIT_MOD_CAPS_LOCK` or `SIT_MOD_NUM_LOCK`.
 *
 * @return `true` if the specified lock key is currently active, `false` otherwise.
 *
 * @note This reflects the state of the lock key at the time of the last event, as reported by the OS.
 *
 * @see SituationIsScrollLockOn(), SituationIsModifierPressed()
 */
SITAPI bool SituationIsLockKeyPressed(int lock_key_mod) {
    if (!sit_gs.is_initialized) return false;
    return (sit_gs.keyboard.lock_key_state & lock_key_mod) != 0;
}

/**
 * @brief Checks if the Scroll Lock key is currently toggled on.
 * @details This function is necessary because the Scroll Lock state is not reported as a standard modifier by GLFW. The library manually tracks its toggle state based on key-press events.
 *
 * @return `true` if Scroll Lock is toggled on, `false` otherwise.
 *
 * @note The accuracy of this function depends on the initial state of Scroll Lock when the application starts.
 *
 * @see SituationIsLockKeyPressed()
 */
SITAPI bool SituationIsScrollLockOn(void) {
    if (!sit_gs.is_initialized) return false;
    return sit_gs.keyboard.is_scroll_lock_on;
}

/**
 * @brief Checks if a modifier key (Shift, Ctrl, Alt, Super) is currently held down.
 * @details This function provides a convenient way to check the state of modifier keys without needing to check for left and right keys individually.
 *
 * @param modifier The modifier key to check. Use `SIT_MOD_SHIFT`, `SIT_MOD_CONTROL`, `SIT_MOD_ALT`, or `SIT_MOD_SUPER`.
 *
 * @return `true` if one or more of the specified modifier keys are pressed, `false` otherwise.
 *
 * @see SituationIsKeyDown()
 */
SITAPI bool SituationIsModifierPressed(int modifier) {
    if (!sit_gs.is_initialized) return false;
    return (sit_gs.keyboard.modifier_state & modifier) != 0;
}

/**
 * @brief Sets a callback function to be executed for all keyboard key events.
 * @details This provides an event-driven way to handle keyboard input, an alternative to polling in the main loop. The callback is invoked by the OS's event thread (via GLFW) immediately when a key is pressed, released, or repeated.
 *
 * @param callback The function pointer to your callback. The callback receives the key, scancode, action, and modifier flags. Pass `NULL` to clear the callback.
 * @param user_data A custom pointer that will be passed to your callback function, allowing you to maintain state.
 *
 * @warning The callback is executed in the same thread that calls `SituationPollInputEvents`. It is not asynchronous and will block the main loop until it returns.
 */
SITAPI void SituationSetKeyCallback(SituationKeyCallback callback, void* user_data) {
    if (!sit_gs.is_initialized) return;
    sit_gs.keyboard.key_callback = callback;
    sit_gs.keyboard.key_callback_user_data = user_data;
}

// --- Mouse Management Implementation ---
/**
 * @brief Gets the current mouse cursor position within the window's client area.
 * @details This function returns the mouse coordinates relative to the top-left corner of the window. The returned value is affected by any custom transformations set via `SituationSetMouseOffset()` and `SituationSetMouseScale()`.
 *
 * @return A `Vector2` containing the current (x, y) coordinates of the mouse.
 *
 * @note This function's state is updated once per frame by `SituationPollInputEvents()`.
 *
 * @see SituationGetMouseDelta(), SituationSetMousePosition()
 */
SITAPI Vector2 SituationGetMousePosition(void) {
    if (!sit_gs.is_initialized) {
        Vector2 zero_vec = {0.0f, 0.0f}; return zero_vec;
    }
    Vector2 pos;
    // Apply scale first, then offset
    glm_vec2_mul(sit_gs.mouse.current_pos, sit_gs.mouse.scale, pos);
    glm_vec2_add(pos, sit_gs.mouse.offset, pos);
    return pos;
}

/**
 * @brief Gets the change in mouse position since the last frame.
 * @details This function is essential for implementing camera controls or any interaction based on mouse movement. It returns the difference between the current and previous frame's mouse positions, scaled by `SituationSetMouseScale()`.
 *
 * @return A `Vector2` representing the movement delta (dx, dy).
 *
 * @note This value is reset to zero at the start of each frame by `SituationPollInputEvents()`.
 *
 * @see SituationGetMousePosition()
 */
SITAPI Vector2 SituationGetMouseDelta(void) {
    if (!sit_gs.is_initialized) {
        Vector2 zero_vec = {0.0f, 0.0f}; return zero_vec;
    }
    Vector2 delta;
    glm_vec2_sub(sit_gs.mouse.current_pos, sit_gs.mouse.last_pos, delta);
    // Scale the delta as well
    glm_vec2_mul(delta, sit_gs.mouse.scale, delta);
    return delta;
}

/**
 * @brief Sets the mouse cursor's position within the window's client area.
 * @details This function "warps" or "teleports" the mouse cursor to the specified coordinates. It correctly accounts for any custom transformations set via `SituationSetMouseOffset()` and `SituationSetMouseScale()`,
 * so the coordinates you provide are in the same space as those returned by `SituationGetMousePosition()`.
 *
 * @param pos A `Vector2` containing the target (x, y) coordinates.
 *
 * @note This function also updates the internal mouse state to prevent a large, incorrect `SituationGetMouseDelta()` value on the next frame.
 */
SITAPI void SituationSetMousePosition(Vector2 pos) {
    if (!sit_gs.is_initialized || !sit_gs.sit_glfw_window) return;
    // We must "un-transform" the position before sending it to GLFW, so that GetMousePosition will return the value the user expects.
    Vector2 raw_pos;
    glm_vec2_sub(pos, sit_gs.mouse.offset, raw_pos);
    // Division is component-wise. Ensure scale components are not zero.
    if (sit_gs.mouse.scale[0] != 0.0f) raw_pos[0] /= sit_gs.mouse.scale[0];
    if (sit_gs.mouse.scale[1] != 0.0f) raw_pos[1] /= sit_gs.mouse.scale[1];

    glfwSetCursorPos(sit_gs.sit_glfw_window, raw_pos[0], raw_pos[1]);
    
    // Also update our internal state immediately to prevent a "jumpy" delta on the next frame.
    glm_vec2_copy(raw_pos, sit_gs.mouse.current_pos);
}

/**
 * @brief Sets a virtual offset for the mouse cursor's coordinate system.
 * @details This is an advanced utility for remapping mouse coordinates. The provided offset is added to the raw mouse position before it is returned by `SituationGetMousePosition()`. This can be useful for emulating a virtual camera or a scrolling view within a larger space.
 *
 * @param offset A `Vector2` representing the (x, y) offset to apply.
 *
 * @note The default offset is (0, 0).
 *
 * @see SituationGetMousePosition(), SituationSetMouseScale()
 */
SITAPI void SituationSetMouseOffset(Vector2 offset) {
    if (!sit_gs.is_initialized) return;
    glm_vec2_copy(offset, sit_gs.mouse.offset);
}

/**
 * @brief Sets a virtual scale for the mouse cursor's coordinate system.
 * @details This is an advanced utility for remapping mouse coordinates. The raw mouse position and delta are multiplied by this scale factor before being returned by `SituationGetMousePosition()` and `SituationGetMouseDelta()`.
 * This is useful for matching mouse input to a scaled viewport or rendering resolution.
 *
 * @param scale A `Vector2` representing the (x, y) scale factors to apply.
 *
 * @note The default scale is (1.0, 1.0).
 *
 * @see SituationGetMousePosition(), SituationGetMouseDelta(), SituationSetMouseOffset()
 */
SITAPI void SituationSetMouseScale(Vector2 scale) {
    if (!sit_gs.is_initialized) return;
    glm_vec2_copy(scale, sit_gs.mouse.scale);
}

/**
 * @brief Gets the vertical mouse wheel movement since the last frame.
 * @details This function returns the accumulated vertical scroll offset for the current frame.
 *
 * @return A float representing the vertical scroll amount. Positive values typically mean scrolling up (away from the user), and negative values mean scrolling down (towards the user).
 *
 * @note This value is an accumulation of all scroll events within a frame and is reset to zero by `SituationPollInputEvents()`. For both horizontal and vertical movement, use `SituationGetMouseWheelMoveV()`.
 *
 * @see SituationGetMouseWheelMoveV()
 */
SITAPI float SituationGetMouseWheelMove(void) {
    if (!sit_gs.is_initialized) return 0.0f;
    // GLFW scroll y offset is positive for scroll up/away from user, negative for scroll down/towards user.
    return sit_gs.mouse.wheel_move_y;
}

/**
 * @brief Gets the vertical and horizontal mouse wheel movement since the last frame.
 * @details This function returns the accumulated scroll offsets for both axes. While most mice only have a vertical wheel, some devices (like trackpads or mice with tilt-wheels) can report horizontal scrolling.
 *
 * @return A `Vector2` where `x` is the horizontal scroll offset and `y` is the vertical scroll offset.
 *
 * @note These values are an accumulation of all scroll events within a frame and are reset to zero by `SituationPollInputEvents()`.
 *
 * @see SituationGetMouseWheelMove()
 */
SITAPI Vector2 SituationGetMouseWheelMoveV(void) {
    if (!sit_gs.is_initialized) {
        Vector2 zero_vec = {0.0f, 0.0f}; return zero_vec;
    }
    Vector2 wheel_v = {sit_gs.mouse.wheel_move_x, sit_gs.mouse.wheel_move_y};
    return wheel_v;
}

/**
 * @brief Retrieves the next mouse button-press event from the input queue and consumes it.
 * @details This function provides a queue-based approach to handling mouse clicks, guaranteeing that no press events are missed. It is useful for UI interactions where you need to process every single click.
 *
 * @return The button code of the next mouse button pressed (e.g., `GLFW_MOUSE_BUTTON_LEFT`).
 * @return `-1` if the button-press queue is empty.
 *
 * @note The queue is cleared at the beginning of each frame by `SituationPollInputEvents()`.
 */
SITAPI int SituationGetMouseButtonPressed(void) {
    if (!sit_gs.is_initialized || sit_gs.mouse.button_queue_count == 0) return -1;
    int button = sit_gs.mouse.button_queue[0];
    for (int i = 0; i < sit_gs.mouse.button_queue_count - 1; ++i) sit_gs.mouse.button_queue[i] = sit_gs.mouse.button_queue[i + 1];
    sit_gs.mouse.button_queue_count--;
    return button;
}

/**
 * @brief Checks if a mouse button is currently held down (a continuous state).
 * @details This function provides real-time state polling. It will return `true` for every frame that the specified button is held down. This is ideal for continuous actions like dragging or firing an automatic weapon.
 *
 * @param button The mouse button to check (e.g., `GLFW_MOUSE_BUTTON_LEFT`, `GLFW_MOUSE_BUTTON_RIGHT`).
 *
 * @return `true` if the button is currently pressed, `false` otherwise.
 */
SITAPI bool SituationIsMouseButtonDown(int button) {
    if (!sit_gs.is_initialized || button < 0 || button > GLFW_MOUSE_BUTTON_LAST) return false;
    return sit_gs.mouse.current_button_state[button];
}

/**
 * @brief Checks if a mouse button was pressed down *this frame* (a single-trigger event).
 * @details This function detects a state change. It will only return `true` for the single frame immediately after the button is pressed. This is ideal for single-trigger actions like selecting an item or firing a semi-automatic weapon.
 *
 * @param button The mouse button to check.
 *
 * @return `true` if the button was just pressed in the current frame, `false` otherwise.
 */
SITAPI bool SituationIsMouseButtonPressed(int button) { 
    if (!sit_gs.is_initialized || button < 0 || button > GLFW_MOUSE_BUTTON_LAST) return false;
    return sit_gs.mouse.button_down_this_frame[button];
}

/**
 * @brief Checks if a mouse button was released *this frame* (a single-trigger event).
 * @details This function detects a state change. It will only return `true` for the single frame immediately after the button is released. This is useful for actions that trigger on release, like confirming a drag-and-drop operation.
 *
 * @param button The mouse button to check.
 *
 * @return `true` if the button was just released in the current frame, `false` otherwise.
 */
SITAPI bool SituationIsMouseButtonReleased(int button) { 
    if (!sit_gs.is_initialized || button < 0 || button > GLFW_MOUSE_BUTTON_LAST) return false;
    return sit_gs.mouse.button_up_this_frame[button];
}

/**
 * @brief Sets a callback function to be executed for all mouse button events.
 * @details This provides an event-driven way to handle mouse clicks. The callback is invoked immediately when a button is pressed or released.
 *
 * @param callback The function pointer to your callback. Pass `NULL` to clear.
 * @param user_data A custom pointer that will be passed to your callback function.
 *
 * @warning The callback is executed in the same thread that calls `SituationPollInputEvents`.
 */
SITAPI void SituationSetMouseButtonCallback(SituationMouseButtonCallback callback, void* user_data) {
    if (!sit_gs.is_initialized) return;
    sit_gs.mouse.button_callback = callback;
    sit_gs.mouse.button_callback_user_data = user_data;
}

/**
 * @brief Sets a callback function to be executed when the mouse cursor moves.
 * @details This provides an event-driven way to handle mouse movement, an alternative to polling `SituationGetMouseDelta()`.
 *
 * @param callback The function pointer to your callback. Pass `NULL` to clear.
 * @param user_data A custom pointer that will be passed to your callback function.
 *
 * @warning The callback is executed in the same thread that calls `SituationPollInputEvents`.
 */
SITAPI void SituationSetCursorPosCallback(SituationCursorPosCallback callback, void* user_data) {
    if (!sit_gs.is_initialized) return;
    sit_gs.mouse.cursor_pos_callback = callback;
    sit_gs.mouse.cursor_pos_callback_user_data = user_data;
}

/**
 * @brief Sets a callback function to be executed for mouse wheel scroll events.
 * @details This provides an event-driven way to handle scrolling.
 *
 * @param callback The function pointer to your callback. Pass `NULL` to clear.
 * @param user_data A custom pointer that will be passed to your callback function.
 *
 * @warning The callback is executed in the same thread that calls `SituationPollInputEvents`.
 */
SITAPI void SituationSetScrollCallback(SituationScrollCallback callback, void* user_data) {
    if (!sit_gs.is_initialized) return;
    sit_gs.mouse.scroll_callback = callback;
    sit_gs.mouse.scroll_callback_user_data = user_data;
}

/**
 * @brief Sets the appearance of the mouse cursor to a standard system shape.
 * @details The library pre-creates a set of standard cursors at initialization for fast switching.
 *
 * @param cursor An enum `SituationCursor` representing the desired shape (e.g., `SIT_CURSOR_HAND`, `SIT_CURSOR_IBEAM`). Use `SIT_CURSOR_DEFAULT` to restore the system's default arrow.
 */
SITAPI void SituationSetCursor(SituationCursor cursor) {
    if (!SituationIsInitialized()) return;
    
    // Ensure the requested cursor is within the bounds of what we created
    if (cursor >= 0 && cursor < sit_gs.cursor_count) {
        // NULL for the cursor handle tells GLFW to use the default system cursor
        glfwSetCursor(sit_gs.window, sit_gs.cursors[cursor]);
    }
}

/**
 * @brief Makes the mouse cursor visible and behave normally.
 * @details This is the default cursor mode.
 *
 * @see SituationHideCursor(), SituationDisableCursor()
 */
SITAPI void SituationShowCursor(void) {
    if (!SituationIsInitialized()) return;
    glfwSetInputMode(sit_gs.window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
}

/**
 * @brief Makes the mouse cursor invisible while it is over the window's client area.
 * @details The cursor will reappear if it leaves the window. Its position is not locked.
 *
 * @see SituationShowCursor(), SituationDisableCursor()
 */
SITAPI void SituationHideCursor(void) {
    if (!SituationIsInitialized()) return;
    glfwSetInputMode(sit_gs.window, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);
}

/**
 * @brief Hides the mouse cursor and locks it to the window, providing unbounded movement.
 * @details This is the ideal mode for 3D camera controls ("mouse look") or any application that requires raw, continuous mouse motion input without being constrained by the screen edges.
 *
 * @see SituationShowCursor(), SituationHideCursor(), SituationGetMouseDelta()
 */
SITAPI void SituationDisableCursor(void) {
    if (!SituationIsInitialized()) return;
    glfwSetInputMode(sit_gs.window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
}

/**
 * @brief GLFW callback for joystick connection/disconnection events.
 *
 * @details THIS FUNCTION IS CALLED ON A SEPARATE GLFW THREAD.
 * Its only job is to safely queue a connection event for the main thread to process later.
 * It locks a mutex, adds the event to a small queue, and unlocks immediately.
 * No complex state changes should ever happen in this function.
 *
 * @param jid The joystick ID.
 * @param event The event type (GLFW_CONNECTED or GLFW_DISCONNECTED).
 */
static void _SituationGLFWJoystickCallback(int jid, int event) {
    // Ignore joysticks beyond the maximum we are tracking.
    if (jid < 0 || jid >= SITUATION_MAX_JOYSTICKS) return;

    // Lock the mutex to safely access the shared event queue.
    ma_mutex_lock(&sit_gs.joysticks.event_queue_mutex);
    {
        // Add the event to the queue if there is space.
        if (sit_gs.joysticks.event_queue_count < SITUATION_MAX_JOYSTICKS) {
            sit_gs.joysticks.event_queue[sit_gs.joysticks.event_queue_count].jid = jid;
            sit_gs.joysticks.event_queue[sit_gs.joysticks.event_queue_count].event = event;
            sit_gs.joysticks.event_queue_count++;
        }
        // else: The queue is full and the event is dropped. This is rare for connect/disconnect events but prevents a buffer overflow. A larger queue could be used if this becomes an issue.
    }
    // Unlock the mutex as quickly as possible.
    ma_mutex_unlock(&sit_gs.joysticks.event_queue_mutex);
}

// --- Gamepad (Joystick) Management Implementation ---
/**
 * @brief Checks if a joystick or gamepad is currently connected at a specific slot.
 * @details This function queries the internal state, which is updated by the joystick connection/disconnection callback. It can be used to detect if a player's controller is plugged in.
 *
 * @param jid The joystick ID (slot) to check. This is typically 0 for the first player, 1 for the second, and so on, up to `SITUATION_MAX_JOYSTICKS - 1`.
 *
 * @return `true` if a joystick is connected at the specified slot, `false` otherwise.
 */
SITAPI bool SituationIsJoystickPresent(int jid) {
    if (!sit_gs.is_initialized || jid < 0 || jid >= SITUATION_MAX_JOYSTICKS) return false;
    return sit_gs.joysticks.state[jid].is_present;
}

/**
 * @brief Checks if a connected joystick has a standard gamepad mapping.
 * @details A "gamepad" is a joystick that the underlying backend (GLFW) recognizes and can map to a standard layout (like an Xbox or PlayStation controller). If this returns true, you can reliably use the `SITUATION_GAMEPAD_BUTTON_*` and `SITUATION_GAMEPAD_AXIS_*` enums.
 * If it returns false, the device is a non-standard joystick, and you would need to query its raw axes and buttons.
 *
 * @param jid The joystick ID (slot) to check.
 *
 * @return `true` if the joystick in the specified slot is a standard, mapped gamepad, `false` otherwise.
 *
 * @see SituationIsJoystickPresent()
 */
SITAPI bool SituationIsGamepad(int jid) {
    if (!SituationIsJoystickPresent(jid)) return false;
    return sit_gs.joysticks.state[jid].is_gamepad;
}

/**
 * @brief Gets the human-readable name of a connected joystick or gamepad.
 * @details This function returns the name of the controller as reported by the operating system (e.g., "XInput Controller", "DualSense Wireless Controller"). This is useful for displaying controller information in UI or for debugging.
 *
 * @param jid The joystick ID (slot) to query.
 *
 * @return A constant string containing the name of the device.
 * @return `"N/A"` if no joystick is present at the specified slot.
 */
SITAPI const char* SituationGetJoystickName(int jid) {
    if (!SituationIsJoystickPresent(jid)) return "N/A";
    return sit_gs.joysticks.state[jid].name;
}

/**
 * @brief Sets a callback function to be executed when a joystick is connected or disconnected.
 * @details This provides an event-driven way to manage controller connections. The callback is invoked immediately when a device is plugged in or unplugged, allowing the application to react by updating player states, showing UI prompts, etc.
 *
 * @param callback The function pointer to your callback. The callback receives the joystick ID and the event type (`GLFW_CONNECTED` or `GLFW_DISCONNECTED`). Pass `NULL` to clear the callback.
 * @param user_data A custom, user-defined pointer that will be passed to your callback function.
 *
 * @warning The GLFW callback that triggers this may be called from a separate thread. Your callback function should be thread-safe or delegate complex work to the main thread.
 */
SITAPI void SituationSetJoystickCallback(SituationJoystickCallback callback, void* user_data) {
    if (!sit_gs.is_initialized) return;
    sit_gs.joysticks.callback = callback;
    sit_gs.joysticks.callback_user_data = user_data;
}

/**
 * @brief Checks if a gamepad button is currently held down (a continuous state).
 * @details This function provides real-time state polling. It will return `true` for every frame that the specified button is held down. This is ideal for continuous actions like accelerating in a racing game.
 *
 * @param jid The joystick ID of the gamepad.
 * @param button The button to check (e.g., `SITUATION_GAMEPAD_BUTTON_A`).
 *
 * @return `true` if the button is currently pressed, `false` otherwise.
 *
 * @note This function's state is updated once per frame by `SituationUpdateTimers()`.
 */
SITAPI bool SituationIsGamepadButtonDown(int jid, int button) {
    if (!SituationIsGamepad(jid) || button < 0 || button >= SITUATION_MAX_JOYSTICK_BUTTONS) return false;
    return (sit_gs.joysticks.state[jid].current_button_state[button] == GLFW_PRESS);
}

/**
 * @brief Retrieves the next gamepad button-press event from the input queue and consumes it.
 * @details This function provides a queue-based approach to handling button presses, similar to `SituationGetKeyPressed`. It returns the button code of the first button that was pressed in the current frame across all connected gamepads and removes it from the queue. This guarantees that no button presses are missed.
 *
 * @return The button code of the next button pressed (e.g., `SITUATION_GAMEPAD_BUTTON_START`).
 * @return `-1` if the button-press queue is empty.
 *
 * @note This function does not distinguish which gamepad the press came from. It is best used for single-player UI navigation or actions where the source controller doesn't matter. For player-specific input, use `SituationIsGamepadButtonPressed()`.
 */
SITAPI int SituationGetGamepadButtonPressed(void) {
    if (!sit_gs.is_initialized || sit_gs.joysticks.button_pressed_queue_count == 0) {
        return -1; // -1 indicates no button pressed, similar to Raylib
    }

    // Pull the first button from the queue
    int button = sit_gs.joysticks.button_pressed_queue[0];
    
    // Shift the rest of the queue down
    for (int i = 0; i < sit_gs.joysticks.button_pressed_queue_count - 1; ++i) {
        sit_gs.joysticks.button_pressed_queue[i] = sit_gs.joysticks.button_pressed_queue[i + 1];
    }
    sit_gs.joysticks.button_pressed_queue_count--;

    return button;
}

/**
 * @brief Checks if a gamepad button was pressed down *this frame* (a single-trigger event).
 * @details This function detects a state change. It will only return `true` for the single frame immediately after the button is pressed. This is ideal for single-trigger actions like jumping or firing.
 *
 * @param jid The joystick ID of the gamepad.
 * @param button The button to check (e.g., `SITUATION_GAMEPAD_BUTTON_X`).
 *
 * @return `true` if the button was just pressed in the current frame, `false` otherwise.
 *
 * @note This function's state is updated once per frame by `SituationUpdateTimers()`.
 */
SITAPI bool SituationIsGamepadButtonPressed(int jid, int button) {
    if (!SituationIsGamepad(jid) || button < 0 || button >= SITUATION_MAX_JOYSTICK_BUTTONS) return false;
    return (sit_gs.joysticks.state[jid].current_button_state[button] == GLFW_PRESS &&
            sit_gs.joysticks.state[jid].last_button_state[button] == GLFW_RELEASE);
}

/**
 * @brief Checks if a gamepad button was released *this frame* (a single-trigger event).
 * @details This function detects a state change. It will only return `true` for the single frame immediately after the button is released.
 *
 * @param jid The joystick ID of the gamepad.
 * @param button The button to check (e.g., `SITUATION_GAMEPAD_BUTTON_LEFT_BUMPER`).
 *
 * @return `true` if the button was just released in the current frame, `false` otherwise.
 *
 * @note This function's state is updated once per frame by `SituationUpdateTimers()`.
 */
SITAPI bool SituationIsGamepadButtonReleased(int jid, int button) {
    if (!SituationIsGamepad(jid) || button < 0 || button >= SITUATION_MAX_JOYSTICK_BUTTONS) return false;
    return (sit_gs.joysticks.state[jid].current_button_state[button] == GLFW_RELEASE &&
            sit_gs.joysticks.state[jid].last_button_state[button] == GLFW_PRESS);
}

/**
 * @brief Gets the current value of a gamepad axis, with deadzone applied.
 * @details This function returns the position of an analog stick or trigger. The value is normalized to a range of [-1.0 to 1.0] for sticks and [0.0 to 1.0] for triggers (after backend conversion).
 * A deadzone is automatically applied to the analog sticks to prevent "drift" from worn-out or imprecise hardware.
 *
 * @param jid The joystick ID of the gamepad.
 * @param axis The axis to query (e.g., `SITUATION_GAMEPAD_AXIS_LEFT_X`, `SITUATION_GAMEPAD_AXIS_RIGHT_TRIGGER`).
 *
 * @return The axis value as a float. Returns `0.0f` if the axis is within the deadzone.
 *
 * @note The value is rescaled to provide a smooth response curve, starting from 0 at the edge of the deadzone and reaching 1.0 at the full extent of the axis.
 */
SITAPI float SituationGetGamepadAxisValue(int jid, int axis) {
    if (!SituationIsGamepad(jid) || axis < 0 || axis >= SITUATION_MAX_JOYSTICK_AXES) return 0.0f;
    
    float value = sit_gs.joysticks.state[jid].axis_state[axis];
    
    // Apply deadzone for analog sticks to prevent drift
    float deadzone = 0.0f;
    if (axis == GLFW_GAMEPAD_AXIS_LEFT_X || axis == GLFW_GAMEPAD_AXIS_LEFT_Y) {
        deadzone = SITUATION_JOYSTICK_DEADZONE_L;
    } else if (axis == GLFW_GAMEPAD_AXIS_RIGHT_X || axis == GLFW_GAMEPAD_AXIS_RIGHT_Y) {
        deadzone = SITUATION_JOYSTICK_DEADZONE_R;
    }

    if (fabsf(value) < deadzone) {
        return 0.0f;
    }
    
    // Optional: Rescale the value to be 0 at the edge of the deadzone
    // This provides a smoother response curve after the deadzone.
    float rescaled_value = (value - copysignf(deadzone, value)) / (1.0f - deadzone);
    return rescaled_value;
}

/**
 * @brief Gets the number of axes available on a connected joystick.
 * @details This is useful for querying the capabilities of non-standard joysticks that are not recognized as gamepads. For standard gamepads, this will typically return 6.
 *
 * @param jid The joystick ID (slot) to query.
 *
 * @return The number of axes detected for the device.
 */
SITAPI int SituationGetGamepadAxisCount(int jid) {
    if (!SituationIsJoystickPresent(jid)) return 0;
    return sit_gs.joysticks.state[jid].axis_count;
}

/**
 * @brief Updates the internal controller mappings from an SDL2-comptabile mapping string.
 * @details This function allows you to add or override gamepad mappings at runtime. This is useful for supporting controllers that are not recognized by default. You can find mapping strings for various controllers in the community-maintained `gamecontrollerdb.txt` file.
 *
 * @param mappings A string containing one or more SDL2-comptabile controller mappings.
 *
 * @return `1` on success, `0` on failure (e.g., if the mapping string is invalid).
 */
SITAPI int SituationSetGamepadMappings(const char *mappings) {
    if (!sit_gs.is_initialized) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "SetGamepadMappings");
        return 0;
    }
    // This is a direct wrapper around the GLFW function.
    // It returns 1 on success, 0 on failure.
    return glfwUpdateGamepadMappings(mappings);
}

/**
 * @brief Sets the vibration/rumble intensity for a connected gamepad.
 * @details This function controls the strength of the low-frequency (left) and high-frequency (right) rumble motors in the controller.
 *
 * @par Platform Specificity
 *   This feature is currently only implemented on **Windows** via the XInput API and will only work for XInput-compatible controllers. On other platforms, this function will do nothing.
 *
 * @param jid The joystick ID of the gamepad (0-3 on Windows).
 * @param left_motor The intensity of the left (low-frequency) motor, from `0.0f` (off) to `1.0f` (full strength).
 * @param right_motor The intensity of the right (high-frequency) motor, from `0.0f` (off) to `1.0f` (full strength).
 */
SITAPI void SituationSetGamepadVibration(int jid, float left_motor, float right_motor) {
    if (!SituationIsJoystickPresent(jid)) return;

#if defined(_WIN32)
    // On Windows, GLFW joystick IDs map directly to XInput user indices (0-3) for XInput-compatible devices. We assume this mapping holds.
    if (jid < 0 || jid >= 4) return;

    XINPUT_VIBRATION vibration;
    memset(&vibration, 0, sizeof(XINPUT_VIBRATION));

    // XInput wants values from 0-65535. Clamp float from 0.0-1.0 and scale.
    float left = (left_motor < 0.0f) ? 0.0f : (left_motor > 1.0f) ? 1.0f : left_motor;
    float right = (right_motor < 0.0f) ? 0.0f : (right_motor > 1.0f) ? 1.0f : right_motor;

    vibration.wLeftMotorSpeed = (WORD)(left * 65535.0f);
    vibration.wRightMotorSpeed = (WORD)(right * 65535.0f);

    XInputSetState((DWORD)jid, &vibration);
#else
    // Vibration is not supported on non-Windows platforms via this implementation.
    // This would require platform-specific code for Linux (evdev) or macOS (ForceFeedback.h).
    (void)jid;
    (void)left_motor;
    (void)right_motor;
    _SituationSetError("Gamepad vibration is only supported on Windows (XInput).");
#endif
}

/**
 * @brief Gets the raw, underlying GLFW window handle.
 * @details This function provides direct access to the `GLFWwindow*` managed by the library. This is an escape hatch for advanced users who need to call a GLFW function that is not wrapped by the Situation API.
 *
 * @return The `GLFWwindow*` handle on success.
 * @return `NULL` if the library is not initialized or the window has not been created.
 *
 * @warning Use with caution. Directly manipulating the GLFW window or its context can interfere with the library's internal state management and may lead to unexpected behavior.
 */
SITAPI GLFWwindow* SituationGetGLFWwindow(void) {
    if (!sit_gs.is_initialized || !sit_gs.sit_glfw_window) { _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "GLFW window not initialized"); return NULL; }
    return sit_gs.sit_glfw_window;
}

/**
 * @brief Gets the current logical size of the window.
 * @details This is a convenience function that retrieves both width and height in a single call.
 * @param[out] width A pointer to an integer where the window width in screen coordinates will be stored.
 * @param[out] height A pointer to an integer where the window height in screen coordinates will be stored.
 * @see SituationGetScreenWidth(), SituationGetScreenHeight()
 */
SITAPI void SituationGetWindowSize(int* width, int* height) {
    if (!sit_gs.is_initialized) {
        // If the engine isn't running, return 0 to avoid errors.
        if (width) *width = 0;
        if (height) *height = 0;
        return;
    }

    // Use the underlying windowing library's function to get the size.
    // For GLFW, this is glfwGetWindowSize().
    glfwGetWindowSize(sit_gs.sit_glfw_window, width, height);
}

// Checks if the GLFW window should close (e.g., user clicked close button).
// Returns true if not initialized or window is null, setting an error.
// Use in the main loop to control application exit.
SITAPI bool SituationWindowShouldClose(void) {
    if (!sit_gs.is_initialized || !sit_gs.sit_glfw_window) {
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "Cannot check window close state");
        return true; // If not init'd, effectively should "close" or not run.
    }
    return glfwWindowShouldClose(sit_gs.sit_glfw_window) == GLFW_TRUE;
}

/**
 * @brief Sets a desired frame rate cap.
 * @details Pass 0 to disable the cap. This is independent of VSync.
 * @param fps The target frames per second.
 * @note This function requires the library to be initialized (`SituationInit` must have been called successfully).
 * @see SituationGetFrameTime(), SituationGetFPS()
 */
SITAPI void SituationSetTargetFPS(int fps) {
    // --- 1. Pre-condition Check ---
    if (!sit_gs.is_initialized) {
        // As per library convention, silently return or set a general error if called incorrectly.
        // The provided text shows similar functions returning early.
        _SituationSetErrorFromCode(SITUATION_ERROR_NOT_INITIALIZED, "SituationSetTargetFPS: Library not initialized.");
        return;
    }

    // --- 2. Set Target Frame Time ---
    if (fps <= 0) {
        // Disable frame rate limiting by setting target time to 0.0.
        sit_gs.target_frame_time = 0.0;
    } else {
        // Calculate the target time per frame in seconds.
        sit_gs.target_frame_time = 1.0 / (double)fps;
    }
}

/**
 * @brief Gets the time in seconds for the last frame to complete (deltaTime).
 * @details Use this for frame-rate-independent movement and physics.
 *          This value is updated once per frame in the main loop.
 * @return The last frame time (deltaTime) in seconds. Returns 0.0f if the library is not initialized.
 * @note This function requires the library to be initialized.
 * @see SituationSetTargetFPS(), SituationGetFPS()
 */
SITAPI float SituationGetFrameTime(void) {
    // --- 1. Pre-condition Check ---
    if (!sit_gs.is_initialized) {
        // Return a default value as per the original docstring and common practice.
        return 0.0f;
    }

    // --- 2. Return Stored Value ---
    // The frame time is updated in the main loop (e.g., within SituationEndFrame or similar timing update function).
    return (float)sit_gs.frame_time;
}

/**
 * @brief Gets the current frames-per-second value.
 * @details This value is updated periodically (e.g., once per second) within the library's main loop.
 * @return The current calculated FPS. Returns 0 if the library is not initialized.
 * @note This function requires the library to be initialized.
 * @see SituationSetTargetFPS(), SituationGetFrameTime()
 */
SITAPI int SituationGetFPS(void) {
    // --- 1. Pre-condition Check ---
    if (!sit_gs.is_initialized) {
        // Return a default value as per the original docstring.
        return 0;
    }

    // --- 2. Return Stored Value ---
    // The current FPS is calculated and stored in the global state.
    return sit_gs.current_fps;
}

/**
 * @brief Converts an 8-bit RGBA color struct to a normalized floating-point vec4.
 * @details This is a utility function for converting colors from the standard 0-255 integer range to the 0.0f-1.0f float range required by shader uniforms and vertex attributes.
 *
 * @param c The source `ColorRGBA` struct.
 * @param[out] out_normalized_color A `vec4` (float array of size 4) that will be filled with the normalized color components [r, g, b, a].
 */
SITAPI void SituationConvertColorToVec4(ColorRGBA c, vec4 out_normalized_color) {
    out_normalized_color[0] = c.r / 255.0f; out_normalized_color[1] = c.g / 255.0f;
    out_normalized_color[2] = c.b / 255.0f; out_normalized_color[3] = c.a / 255.0f;
}

/**
 * @brief Captures the current contents of the main window's backbuffer into a CPU-side image.
 * @details This function reads the pixel data directly from the GPU's framebuffer, providing a snapshot of the most recently rendered frame. This is the core operation for taking screenshots or for enabling CPU-based image processing effects on the final rendered image.
 *
 * @par Backend-Specific Behavior
 * - **OpenGL:** Uses `glReadPixels` to read from the default framebuffer. The resulting image is vertically flipped, so the function automatically calls `SituationImageFlip` to correct the orientation.
 * - **Vulkan:** Performs a synchronized copy from the device-local swapchain image to a temporary, host-visible staging buffer. This is a complex operation involving command buffer submission and waiting for the GPU to complete the transfer, managed by the internal `_SituationVulkanBlitImageToHostVisibleBuffer` helper. The resulting image is correctly oriented.
 *
 * @warning This function allocates new memory for the `image.data`. The caller is **responsible** for freeing this memory by calling `SituationUnloadImage()` on the returned `SituationImage`. Failure to do so will result in a memory leak.
 * @warning This can be a slow operation, as it requires synchronization with the GPU and a potentially large data transfer from VRAM to system RAM. Avoid calling it in performance-critical loops.
 *
 * @return A new `SituationImage` containing the pixel data, width, and height of the screen. Returns a zeroed (invalid) struct on failure (e.g., if out of memory or not implemented).
 *
 * @see SituationUnloadImage(), SituationTakeScreenshot()
 */
SITAPI SituationImage SituationLoadImageFromScreen(void) {
    SituationImage image = {0};
    if (!SituationIsInitialized()) return image;

    // Get the dimensions of the framebuffer (HiDPI-aware)
    int width = SituationGetRenderWidth();
    int height = SituationGetRenderHeight();
    if (width == 0 || height == 0) return image;

    image.width = width;
    image.height = height;

#if defined(SITUATION_USE_OPENGL)
    // Allocate memory for the raw pixel data (RGBA, 8 bits per channel)
    image.data = malloc(width * height * 4);
    if (!image.data) {
        _SituationSetErrorFromCode(SITUATION_ERROR_MEMORY_ALLOCATION, "Screenshot pixel buffer");
        return (SituationImage){0};
    }

    // Bind the default framebuffer (the one being displayed) to read from it.
    glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
    SIT_CHECK_GL_ERROR();

    // Read pixels from the framebuffer. They will be vertically flipped.
    glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, image.data);
    SIT_CHECK_GL_ERROR();

    // Use our new, generic utility function to correct the orientation.
    SituationImageFlip(&image, SIT_FLIP_VERTICAL);
#elif defined(SITUATION_USE_VULKAN)
    // To take a screenshot, we need to copy a device-local (GPU-only) swapchain image
    // to a host-visible (CPU-readable) buffer. This is a multi-step, synchronized process.

    // 1. Identify the source image. This is the image that was most recently acquired
    //    and rendered to. `current_image_index` holds its index in the swapchain array.
    VkImage srcImage = sit_gs.vk.swapchain_images[sit_gs.vk.last_presented_image_index];
    if (srcImage == VK_NULL_HANDLE) { _SituationSetErrorFromCode(SITUATION_ERROR_VULKAN_SWAPCHAIN_FAILED, "Cannot get screenshot, source swapchain image is invalid."); return (SituationImage){0}; }

    // 2. The image has been rendered to and is now in the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR layout, ready to be shown on screen. We need to copy from this state.
    //    We will call a dedicated helper function to manage the complexity of the copy.
    image.data = _SituationVulkanBlitImageToHostVisibleBuffer( srcImage, VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, (uint32_t)width, (uint32_t)height );

    // 3. Check if the helper succeeded. If it returned NULL, an error was already set inside it.
    if (image.data == NULL) { return (SituationImage){0}; }

    // NOTE: Unlike OpenGL, the Vulkan copy does not result in a vertically flipped image.
    // The blit operation respects the coordinate system, so no SituationImageFlip is needed.
#endif

    return image;
}

/**
 * @brief Frees the CPU memory allocated for an image's pixel data.
 * @details This is the designated cleanup function for any `SituationImage` whose `data` member was allocated by the library (e.g., via `SituationLoadImage`, `SituationImageCopy`, or `SituationLoadImageFromScreen`). It ensures that the memory is correctly released.
 *
 * @param image The `SituationImage` whose pixel data buffer should be freed. The `data` pointer becomes invalid after this call.
 *
 * @note This function only frees the CPU-side pixel buffer (`image.data`). It does not affect any GPU texture created from this image. Use `SituationDestroyTexture` for GPU resources.
 * @note It is safe to call this function on an image whose `data` pointer is already NULL.
 */
SITAPI void SituationUnloadImage(SituationImage image) {
    if (image.data != NULL) {
        free(image.data);
    }
}

/**
 * @brief Captures the current window content and saves it to an image file.
 * @details This is a high-level convenience function that combines `SituationLoadImageFromScreen` and `SituationExportImage`. It determines the output file format based on the provided file extension.
 *
 * @par Supported Formats
 *   - **`.png`:** Requires the `stb_image_write.h` implementation to be included in the project. Provides compressed, high-quality output.
 *   - **`.bmp`:** Uses a built-in writer as a fallback. Produces uncompressed, larger files.
 *
 * @param fileName The path and name of the file to save (e.g., "screenshots/my_game_01.png"). The directory must exist.
 *
 * @return `true` if the screenshot was successfully captured and saved, `false` otherwise.
 *
 * @note This function internally allocates and frees the memory for the screen capture, so the user does not need to call `SituationUnloadImage`.
 * @warning This can be a slow operation due to the underlying screen capture and file I/O.
 *
 * @see SituationLoadImageFromScreen(), SituationExportImage()
 */
SITAPI bool SituationTakeScreenshot(const char *fileName) {
    if (!SituationIsInitialized() || !fileName) {
        _SituationSetErrorFromCode(SITUATION_ERROR_INVALID_PARAM, "Cannot take screenshot");
        return false;
    }

    SituationImage image = SituationLoadImageFromScreen();
    if (image.data == NULL) {
        // Error is already set by SituationLoadImageFromScreen
        return false;
    }

    bool success = false;
    const char *ext = SituationGetFileExtension(fileName);

    if (ext != NULL && (strcmp(ext, ".png") == 0 || strcmp(ext, ".PNG") == 0)) {
        #if defined(STB_IMAGE_WRITE_IMPLEMENTATION)
            // Use stb_image_write to save as PNG
            int stride = image.width * 4;
            success = (stbi_write_png(fileName, image.width, image.height, 4, image.data, stride) != 0);
            if (!success) _SituationSetError("Failed to write PNG file using stb_image_write.");
        #else
            _SituationSetError("PNG support not available. Please implement stb_image_write.h.");
            success = false;
        #endif
    } else if (ext != NULL && (strcmp(ext, ".bmp") == 0 || strcmp(ext, ".BMP") == 0)) {
        // Use our internal BMP writer
        success = _SituationSaveImageBMP(fileName, &image);
    } else {
        _SituationSetError("Unsupported screenshot file format. Use .png or .bmp.");
        success = false;
    }

    SituationUnloadImage(image); // IMPORTANT: Free the pixel data
    return success;
}

/**
 * @brief Frees the memory for a string allocated and returned by the Situation library.
 * @details This function must be used to free any `char*` returned by functions like `SituationGetLastErrorMsg()`, `SituationGetBasePath()`, etc. It ensures that memory is deallocated using the same allocator the library used.
 * @param str A pointer to the string to be freed. It is safe to pass NULL.
 */
SITAPI void SituationFreeString(char* str) {
    if (str) {
        free(str);
    }
}

/**
 * @brief Frees the memory for the array of display information returned by `SituationGetDisplays`.
 * @details This function correctly handles the complex nested deallocation required for the `SituationDisplayInfo` array, freeing both the inner `available_modes` and the top-level array. This is the only safe way to clean up this resource.
 * @param displays The array of `SituationDisplayInfo` structs to be freed.
 * @param count The number of elements in the array, as returned by `SituationGetDisplays`.
 */
SITAPI void SituationFreeDisplays(SituationDisplayInfo* displays, int count) {
    if (!displays || count == 0) return;
    for (int i = 0; i < count; ++i) {
        if (displays[i].available_modes) {
            free(displays[i].available_modes);
        }
    }
    free(displays);
}

#endif // SITUATION_IMPLEMENTATION

#endif // SITUATION_H