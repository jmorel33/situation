Date: 2025-11-19
Version: 2.3.2 "Parity"

## DESCRIPTION

Version 2.3.2 addresses the major feature gaps identified in previous versions, achieving functional parity between the OpenGL and Vulkan backends, and introducing key new capabilities. This release enables "Advanced Blending" for Vulkan Virtual Displays, adds a complete Audio Capture (Microphone) API, and finalizes the 3D Model Exporting tools. Under the hood, it includes critical fixes for Vulkan synchronization (pipeline barriers), memory safety, and descriptor binding logic.

## NEW FEATURES

*   **Audio Capture API:** Added `SituationStartAudioCapture`, `SituationStopAudioCapture`, and the `SituationAudioCaptureCallback` type. This allows applications to record raw audio data (Mono, 32-bit Float, 44.1kHz) from the system's default input device for real-time processing.

*   **Vulkan Advanced Blending:** Implemented the complex "Copy-Before-Draw" architecture for the Vulkan backend. `SituationRenderVirtualDisplays` now correctly handles advanced blend modes (Overlay, Soft Light, etc.) on Vulkan by copying the swapchain image to a readable texture before rendering, matching the visual fidelity of the OpenGL backend.

*   **3D Model Exporting:** Finalized the `SituationSaveModelAsGltf` utility. This required implementing the previously stubbed `SituationGetMeshData` function to perform geometry readback from the GPU to CPU memory, enabling users to save runtime-generated or modified meshes to standard `.gltf` files.

## IMPROVEMENTS & FIXES

### [CRITICAL] Vulkan Synchronization & Stability
*   **Fixed Buffer Readback Synchronization:** Completely refactored `SituationGetBufferData`. It now uses a new internal helper `_SituationVulkanReadBackBuffer` that correctly inserts `vkCmdPipelineBarrier` commands before and after transfers. This fixes race conditions where the CPU would read stale data before the GPU finished writing.
*   **Fixed Texture Usage Flags:** `SituationCreateTexture` now automatically includes the `VK_IMAGE_USAGE_STORAGE_BIT`. This fixes a crash/validation error when attempting to bind textures as Storage Images in compute shaders (`SituationCmdBindComputeTexture`).
*   **Fixed Memory Leaks in Buffer Updates:** Resolved memory leaks in `SituationUpdateBuffer` where temporary staging buffers were not freed if mapping or command allocation failed.

### [BUG FIXES]
*   **OpenGL Initialization:** Implemented the missing `_SituationInitGLVirtualDisplayRenderer` function. Previously, the OpenGL Virtual Display compositor relied on uninitialized Vertex Array Objects, leading to potential rendering failures.
*   **Vulkan Compute Binding:** Fixed logic in `SituationCmdBindComputeTexture` that ignored the user's `binding` parameter and always bound to index 0.
*   **API Safety:** Explicitly disabled `SituationCmdSetVertexAttribute` on the Vulkan backend (returning `SITUATION_ERROR_NOT_IMPLEMENTED`), as dynamic vertex format changes are architecturally impossible in Vulkan pipelines.

### [REFACTORING]
*   **Internal Helpers:** Refactored massive logic blocks from `SituationGetBufferData` into reusable internal helpers, which allowed `SituationGetMeshData` to share the robust memory readback logic without code duplication.
*   **Documentation:** Added comprehensive header documentation for all new internal helpers (`_SituationVulkanCreateScreenCopyResource`, `_SituationVulkanReadBackBuffer`, etc.) and updated public API headers to reflect the new capabilities.

--------------------------------------------------------------------------------

Date: 2025-10-31
Version: 2.3.1A "Refinement"

## DESCRIPTION

Version 2.3.1A is a significant quality-of-life and performance refinement of the "Base" API. This update focuses on improving API safety, enhancing performance on the Vulkan backend, achieving greater feature parity between backends, and improving documentation clarity. While introducing no new major features, this release makes the existing API more robust, efficient, and easier to use correctly.

## CHANGES & IMPROVEMENTS

### [CRITICAL] API & Main Loop Refinement

*   **Deprecated SituationUpdate():** The monolithic SituationUpdate() function has been deprecated. It encouraged a main loop structure that was less explicit and prone to off-by-one-frame input bugs.

*   **New Main Loop Workflow:** Introduced two new core functions, SituationPollInputEvents() and SituationUpdateTimers().
    -   SituationPollInputEvents() is now the dedicated function for gathering all OS events and updating input state for the current frame.
    -   SituationUpdateTimers() is the dedicated function for advancing all internal clocks, calculating delta time, and updating joystick/gamepad state.

*   **Updated Documentation:** The API documentation has been updated to reflect this new, clearer main loop structure, providing a best-practice example to guide users.

### [PERFORMANCE] Vulkan Backend Enhancements

*   **High-Performance Virtual Display Compositing:** The SituationRenderVirtualDisplays() function on the Vulkan backend has been completely overhauled. It now uses the "Persistent Descriptor Set" pattern, pre-allocating a descriptor set for each virtual display at creation time. This eliminates all runtime descriptor allocation and updates from the main render loop, resulting in a massive performance improvement when compositing many virtual displays.

*   **Unified & Performant Resource Binding:**
    -   Introduced SituationCmdBindDescriptorSet() and SituationCmdBindTextureSet() as the new, primary API for binding buffers and textures.
    -   Deprecated the older, less explicit SituationCmdBindUniformBuffer, SituationCmdBindTexture, and SituationCmdBindComputeBuffer functions, which now wrap the new API.
    -   This change leverages the persistent descriptor set model for ALL buffers and textures, making resource binding a consistently fast, low-overhead operation on Vulkan.

### [BUG FIXES & STABILITY]

*   **Fixed Input System Crash:** Resolved a critical bug where the mouse input callbacks would attempt to use an uninitialized mutex, leading to a crash. The mouse state struct now correctly contains and initializes its mutex, ensuring thread-safe event handling.

*   **Fixed Vulkan Resource Leak:** Corrected a resource leak in the internal Vulkan pipeline creation logic. The VkPipelineLayout is now properly destroyed if the subsequent vkCreateGraphicsPipelines call fails, preventing leaks on shader compilation or linking errors.

### [DOCUMENTATION & API CLARITY]

*   **Detailed Color Function Docs:** The documentation for all color conversion functions (SituationRgbToHsv, SituationColorToYPQ, etc.) and SituationImageAdjustHSV has been significantly expanded to explain the color spaces, parameter ranges, and algorithms used.

*   **Improved Image Drawing Docs:** The documentation for all SituationImageDraw...() functions has been updated to clarify their distinct rendering methods (bitmap vs. SDF), performance characteristics, boundary handling, and alpha blending formulas.

*   **Added API Safety Functions:** Introduced new helper functions to make the library's manual memory management safer and more explicit:
    -   SituationFreeDisplays() for correctly deallocating the complex SituationDisplayInfo array.
    -   SituationFreeString() as the designated function for freeing strings returned by the library.
    -   Documentation for all functions that return heap-allocated data now explicitly points to these new, safe deallocation functions.

## KNOWN ISSUES & FEATURE GAPS

*   **Vulkan Advanced Blending:** The Vulkan backend's SituationRenderVirtualDisplays function currently only supports simple blend modes (Alpha, Additive, etc.). The complex, multi-pass logic required for advanced Photoshop-style blend modes (Overlay, Soft Light), which is fully implemented in the OpenGL backend, remains a feature gap. This will be addressed in a future update.

--------------------------------------------------------------------------------

Date: 2025-10-18
Version: 2.3.1 "Base"

## Description

Version 2.3.1, designated as the "Base" version, establishes the foundational public API for the "Situation" library. This release provides a single-file, cross-platform C/C++ library designed to abstract low-level system interactions for windowing, graphics, audio, and input. The primary goal of this version is to offer a stable, lean, and powerful foundation for building sophisticated, high-performance software, such as games, creative coding projects, and data visualization tools.

## Scope & Key Features

This version includes a comprehensive feature set across several core domains:

*   **Lifecycle & Windowing:** Full application lifecycle management (`SituationInit`, `SituationShutdown`) and robust window controls (fullscreen, borderless, multi-monitor awareness) via a GLFW3 backend.
*   **Dual Graphics Backend:** A unified graphics API with compile-time support for both modern OpenGL (4.6+ Core) and Vulkan (1.1+). This includes abstractions for shaders, meshes, textures, and generic buffers.
*   **Command Buffer Model:** A core architectural feature for recording rendering and compute commands. This provides a modern, explicit model for GPU interaction, inspired by Vulkan.
*   **Compute Shaders:** A unified API for GPGPU tasks, supporting both OpenGL Compute Shaders and Vulkan Compute Pipelines, with runtime GLSL-to-SPIR-V compilation via `shaderc`.
*   **2D & 3D Rendering:** High-level helpers for drawing 2D primitives (quads) and textured sprites, alongside a robust system for rendering 3D meshes. Includes a Virtual Display system for off-screen rendering, UI layering, and post-processing.
*   **Audio System:** A full-featured audio engine powered by `miniaudio`, supporting playback, capture, device enumeration, and a real-time effects chain (Filters, Echo, Reverb) with support for custom DSP callbacks.
*   **Input Handling:** Unified polling and event-based handling for keyboard, mouse, and gamepads.
*   **Timing System:** Includes high-resolution timers, FPS management, and an advanced "Temporal Oscillator System" for creating rhythmically synchronized events.
*   **Filesystem Utilities:** A cross-platform API for path manipulation and file I/O, including access to standard application directories.

## Implementation Details

*   **Header-Only Library:** The library is distributed as a single header file (`situation.h`). The implementation is included by defining `SITUATION_IMPLEMENTATION` in one C/C++ file.
*   **Dependencies:**
    *   **Required:** GLFW3, cglm.
    *   **Optional (Backend-Specific):** GLAD (for OpenGL), Vulkan SDK (for Vulkan).
    *   **Optional (Features):** `stb_image`, `stb_truetype`, `miniaudio`.
*   **Resource Management:** The library follows an explicit, manual resource management philosophy. All resources created with `SituationCreate*` or `SituationLoad*` functions must be manually destroyed with their corresponding `SituationDestroy*` or `SituationUnload*` functions. The library includes leak detection at shutdown to assist developers.

## Quirks & Notable Design Decisions

*   **[CRITICAL] Single-Threaded API:** All `SITAPI` functions **must** be called from the main thread (the thread that called `SituationInit`). The library is not internally synchronized, and calling API functions from other threads will lead to undefined behavior and likely crashes. Any multithreading must be managed by the client application, with communication back to the main thread for any API calls.
*   **[CRITICAL] Emulated OpenGL Command Buffer:** While the API presents a unified command buffer model, its execution differs significantly between backends. On Vulkan, commands are deferred and executed upon `SituationEndFrame()`. On OpenGL, the command buffer is an *emulation*, and `SituationCmd*` calls often translate to immediate OpenGL API calls. Developers must not write code that depends on the deferred execution of commands when using the OpenGL backend.
*   **Explicit Backend Selection:** The graphics backend (OpenGL or Vulkan) must be selected at compile time by defining either `SITUATION_USE_OPENGL` or `SITUATION_USE_VULKAN`.
*   **Manual Memory Management for Returned Data:** Functions that return dynamically allocated data (e.g., `SituationGetLastErrorMsg()`, `SituationGetDisplays()`) explicitly state that the caller is responsible for freeing the memory to prevent leaks.
